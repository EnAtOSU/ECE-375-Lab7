
AVRASM ver. 2.2.8  C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm Wed Dec 04 14:14:08 2024

[builtin](2): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm(17): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm(805): Including file 'C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\LCDDriver.asm'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\LCDDriver.asm(31): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
[builtin](2): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm(17): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm(805): Including file 'C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\LCDDriver.asm'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\LCDDriver.asm(31): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
                                 
                                 
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32U4.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32U4def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32U4
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32U4
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32U4DEF_INC_
                                 #define _M32U4DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega32U4
                                 #pragma AVRPART ADMIN PART_NAME ATmega32U4
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x95
                                 .equ	SIGNATURE_002	= 0x87
                                 
                                 #pragma AVRPART CORE CORE_VERSION V3
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	PLLCSR	= 0x29
                                 .equ	PLLFRQ	= 0x32
                                 .equ	UEINT	= 0xf4	; MEMORY MAPPED
                                 .equ	UEBCHX	= 0xf3	; MEMORY MAPPED
                                 .equ	UEBCLX	= 0xf2	; MEMORY MAPPED
                                 .equ	UEDATX	= 0xf1	; MEMORY MAPPED
                                 .equ	UEIENX	= 0xf0	; MEMORY MAPPED
                                 .equ	UESTA1X	= 0xef	; MEMORY MAPPED
                                 .equ	UESTA0X	= 0xee	; MEMORY MAPPED
                                 .equ	UECFG1X	= 0xed	; MEMORY MAPPED
                                 .equ	UECFG0X	= 0xec	; MEMORY MAPPED
                                 .equ	UECONX	= 0xeb	; MEMORY MAPPED
                                 .equ	UERST	= 0xea	; MEMORY MAPPED
                                 .equ	UENUM	= 0xe9	; MEMORY MAPPED
                                 .equ	UEINTX	= 0xe8	; MEMORY MAPPED
                                 .equ	UDMFN	= 0xe6	; MEMORY MAPPED
                                 .equ	UDFNUMH	= 0xe5	; MEMORY MAPPED
                                 .equ	UDFNUML	= 0xe4	; MEMORY MAPPED
                                 .equ	UDADDR	= 0xe3	; MEMORY MAPPED
                                 .equ	UDIEN	= 0xe2	; MEMORY MAPPED
                                 .equ	UDINT	= 0xe1	; MEMORY MAPPED
                                 .equ	UDCON	= 0xe0	; MEMORY MAPPED
                                 .equ	USBINT	= 0xda	; MEMORY MAPPED
                                 .equ	USBSTA	= 0xd9	; MEMORY MAPPED
                                 .equ	USBCON	= 0xd8	; MEMORY MAPPED
                                 .equ	UHWCON	= 0xd7	; MEMORY MAPPED
                                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                                 .equ 	TWAMR		= 0xbd	;
                                 .equ  TWCR		= 0xbc	;
                                 .equ 	TWDR		= 0xbb	;
                                 .equ 	TWAR		= 0xba 	;
                                 .equ 	TWSR		= 0xb9	;
                                 .equ 	TWBR		= 0xb8	;
                                 .equ	OCR3CL	= 0x9c	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x9d	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x8c	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x8d	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	DIDR2	= 0x7d	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	TIMSK4	= 0x72	; MEMORY MAPPED
                                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRB	= 0x6a	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	RCCTRL	= 0x67	; MEMORY MAPPED
                                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	EIND	= 0x3c
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	OCDR	= 0x31
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR4	= 0x19
                                 .equ	TIFR3	= 0x18
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTF	= 0x11
                                 .equ	DDRF	= 0x10
                                 .equ	PINF	= 0x0f
                                 .equ	PORTE	= 0x0e
                                 .equ	DDRE	= 0x0d
                                 .equ	PINE	= 0x0c
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 .equ	DT4	= 0xd4	; MEMORY MAPPED
                                 .equ	OCR4D	= 0xd2	; MEMORY MAPPED
                                 .equ	OCR4C	= 0xd1	; MEMORY MAPPED
                                 .equ	OCR4B	= 0xd0	; MEMORY MAPPED
                                 .equ	OCR4A	= 0xcf	; MEMORY MAPPED
                                 .equ	TCCR4E	= 0xc4	; MEMORY MAPPED
                                 .equ	TCCR4D	= 0xc3	; MEMORY MAPPED
                                 .equ	TCCR4C	= 0xc2	; MEMORY MAPPED
                                 .equ	TCCR4B	= 0xc1	; MEMORY MAPPED
                                 .equ	TCCR4A	= 0xc0	; MEMORY MAPPED
                                 .equ	TC4H	= 0xbf	; MEMORY MAPPED
                                 .equ	TCNT4	= 0xbe	; MEMORY MAPPED
                                 .equ	CLKSEL1	= 0xc6	; MEMORY MAPPED
                                 .equ	CLKSEL0	= 0xc5	; MEMORY MAPPED
                                 .equ	CLKSTA	= 0xc7	; MEMORY MAPPED
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCPHA1	= UCSZ10	; For compatibility
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	UDORD1	= UCSZ11	; For compatibility
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL10	= 6	; USART Mode Select
                                 .equ	UMSEL11	= 7	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register High Byte
                                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	SIGRD	= 5	; Signature Row Read
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARH - EEPROM Address Register Low Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                                 
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                                 .equ	OCIE3C	= 3	; Timer/Counter3 Output Compare C Match Interrupt Enable
                                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3A	= 1	; Output Compare Flag 3A
                                 .equ	OCF3B	= 2	; Output Compare Flag 3B
                                 .equ	OCF3C	= 3	; Output Compare Flag 3C
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode
                                 .equ	WGM31	= 1	; Waveform Generation Mode
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Output Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Prescaler source of Timer/Counter 3
                                 .equ	CS31	= 1	; Prescaler source of Timer/Counter 3
                                 .equ	CS32	= 2	; Prescaler source of Timer/Counter 3
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter 3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare 3C
                                 .equ	FOC3B	= 6	; Force Output Compare 3B
                                 .equ	FOC3A	= 7	; Force Output Compare 3A
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                                 .equ	OCIE1C	= 3	; Timer/Counter1 Output Compare C Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter1 Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	OCF1C	= 3	; Output Compare Flag 1C
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Output Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter 1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare 1C
                                 .equ	FOC1B	= 6	; Force Output Compare 1B
                                 .equ	FOC1A	= 7	; Force Output Compare 1A
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_4 **************
                                 ; DT4 - Timer/Counter 4 Dead Time Value
                                 .equ	DT4L0	= 0	; Timer/Counter 4 Dead Time Value Bit 0
                                 .equ	DT4L1	= 1	; Timer/Counter 4 Dead Time Value Bit 1
                                 .equ	DT4L2	= 2	; Timer/Counter 4 Dead Time Value Bit 2
                                 .equ	DT4L3	= 3	; Timer/Counter 4 Dead Time Value Bit 3
                                 .equ	DT4L4	= 4	; Timer/Counter 4 Dead Time Value Bit 4
                                 .equ	DT4L5	= 5	; Timer/Counter 4 Dead Time Value Bit 5
                                 .equ	DT4L6	= 6	; Timer/Counter 4 Dead Time Value Bit 6
                                 .equ	DT4L7	= 7	; Timer/Counter 4 Dead Time Value Bit 7
                                 
                                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                                 .equ	TOV4	= 2	; Timer/Counter4 Overflow Flag
                                 .equ	OCF4B	= 5	; Output Compare Flag 4B
                                 .equ	OCF4A	= 6	; Output Compare Flag 4A
                                 .equ	OCF4D	= 7	; Output Compare Flag 4D
                                 
                                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                                 .equ	TOIE4	= 2	; Timer/Counter4 Overflow Interrupt Enable
                                 .equ	OCIE4B	= 5	; Timer/Counter4 Output Compare B Match Interrupt Enable
                                 .equ	OCIE4A	= 6	; Timer/Counter4 Output Compare A Match Interrupt Enable
                                 .equ	OCIE4D	= 7	; Timer/Counter4 Output Compare D Match Interrupt Enable
                                 
                                 ; OCR4D - Timer/Counter4 Output Compare Register D
                                 .equ	OCR4D0	= 0	; Timer/Counter4 Output Compare Register Low Byte bit 0
                                 .equ	OCR4D1	= 1	; Timer/Counter4 Output Compare Register Low Byte bit 1
                                 .equ	OCR4D2	= 2	; Timer/Counter4 Output Compare Register Low Byte bit 2
                                 .equ	OCR4D3	= 3	; Timer/Counter4 Output Compare Register Low Byte bit 3
                                 .equ	OCR4D4	= 4	; Timer/Counter4 Output Compare Register Low Byte bit 4
                                 .equ	OCR4D5	= 5	; Timer/Counter4 Output Compare Register Low Byte bit 5
                                 .equ	OCR4D6	= 6	; Timer/Counter4 Output Compare Register Low Byte bit 6
                                 .equ	OCR4D7	= 7	; Timer/Counter4 Output Compare Register Low Byte bit 7
                                 
                                 ; OCR4C - Timer/Counter4 Output Compare Register C
                                 .equ	OCR4C0	= 0	; Timer/Counter4 Output Compare Register bit 0
                                 .equ	OCR4C1	= 1	; Timer/Counter4 Output Compare Register bit 1
                                 .equ	OCR4C2	= 2	; Timer/Counter4 Output Compare Register bit 2
                                 .equ	OCR4C3	= 3	; Timer/Counter4 Output Compare Register bit 3
                                 .equ	OCR4C4	= 4	; Timer/Counter4 Output Compare Register bit 4
                                 .equ	OCR4C5	= 5	; Timer/Counter4 Output Compare Register bit 5
                                 .equ	OCR4C6	= 6	; Timer/Counter4 Output Compare Register 6
                                 .equ	OCR4C7	= 7	; Timer/Counter4 Output Compare Register bit 7
                                 
                                 ; OCR4B - Timer/Counter4 Output Compare Register B
                                 .equ	OCR4B0	= 0	; Timer/Counter4 Output Compare Register bit 0
                                 .equ	OCR4B1	= 1	; Timer/Counter4 Output Compare Register bit 1
                                 .equ	OCR4B2	= 2	; Timer/Counter4 Output Compare Register bit 2
                                 .equ	OCR4B3	= 3	; Timer/Counter4 Output Compare Register bit 3
                                 .equ	OCR4B4	= 4	; Timer/Counter4 Output Compare Register bit 4
                                 .equ	OCR4B5	= 5	; Timer/Counter4 Output Compare Register bit 5
                                 .equ	OCR4B6	= 6	; Timer/Counter4 Output Compare Register bit 6
                                 .equ	OCR4B7	= 7	; Timer/Counter4 Output Compare Register bit 7
                                 
                                 ; OCR4A - Timer/Counter4 Output Compare Register A
                                 .equ	OCR4A0	= 0	; Timer/Counter4 Output Compare Register Bit 0
                                 .equ	OCR4A1	= 1	; Timer/Counter4 Output Compare Register Bit 1
                                 .equ	OCR4A2	= 2	; Timer/Counter4 Output Compare Register Low Byte Bit 2
                                 .equ	OCR4A3	= 3	; Timer/Counter4 Output Compare Register Low Byte Bit 3
                                 .equ	OCR4A4	= 4	; Timer/Counter4 Output Compare Register Bit 4
                                 .equ	OCR4A5	= 5	; Timer/Counter4 Output Compare Register Bit 5
                                 .equ	OCR4A6	= 6	; Timer/Counter4 Output Compare Register Bit 6
                                 .equ	OCR4A7	= 7	; Timer/Counter4 Output Compare Register Bit 7
                                 
                                 ; TC4H - Timer/Counter4
                                 .equ	TC48	= 0	; Timer/Counter4 bit 8
                                 .equ	TC49	= 1	; Timer/Counter4 bit 9
                                 .equ	TC410	= 2	; Timer/Counter4 bit 10
                                 
                                 ; TCNT4 - Timer/Counter4 Low Bytes
                                 .equ	TC40	= 0	; Timer/Counter4 bit 0
                                 .equ	TC41	= 1	; Timer/Counter4 bit 1
                                 .equ	TC42	= 2	; Timer/Counter4 bit 2
                                 .equ	TC43	= 3	; Timer/Counter4  bit 3
                                 .equ	TC44	= 4	; Timer/Counter4 bit 4
                                 .equ	TC45	= 5	; Timer/Counter4 bit 5
                                 .equ	TC46	= 6	; Timer/Counter4 bit 6
                                 .equ	TC47	= 7	; Timer/Counter4 bit 7
                                 
                                 ; TCCR4E - Timer/Counter 4 Control Register E
                                 .equ	OC4OE0	= 0	; Output Compare Override Enable bit
                                 .equ	OC4OE1	= 1	; Output Compare Override Enable bit
                                 .equ	OC4OE2	= 2	; Output Compare Override Enable bit
                                 .equ	OC4OE3	= 3	; Output Compare Override Enable bit
                                 .equ	OC4OE4	= 4	; Output Compare Override Enable bit
                                 .equ	OC4OE5	= 5	; Output Compare Override Enable bit
                                 .equ	ENHC4	= 6	; Enhanced Compare/PWM Mode
                                 .equ	TLOCK4	= 7	; Register Update Lock
                                 
                                 ; TCCR4D - Timer/Counter 4 Control Register D
                                 .equ	WGM40	= 0	; Waveform Generation Mode bits
                                 .equ	WGM41	= 1	; Waveform Generation Mode bits
                                 .equ	FPF4	= 2	; Fault Protection Interrupt Flag
                                 .equ	FPAC4	= 3	; Fault Protection Analog Comparator Enable
                                 .equ	FPES4	= 4	; Fault Protection Edge Select
                                 .equ	FPNC4	= 5	; Fault Protection Noise Canceler
                                 .equ	FPEN4	= 6	; Fault Protection Mode Enable
                                 .equ	FPIE4	= 7	; Fault Protection Interrupt Enable
                                 
                                 ; TCCR4C - Timer/Counter 4 Control Register C
                                 .equ	PWM4D	= 0	; Pulse Width Modulator D Enable
                                 .equ	FOC4D	= 1	; Force Output Compare Match 4D
                                 .equ	COM4D0	= 2	; Comparator D Output Mode
                                 .equ	COM4D1	= 3	; Comparator D Output Mode
                                 .equ	COM4B0S	= 4	; Comparator B Output Mode
                                 .equ	COM4B1S	= 5	; Comparator B Output Mode
                                 .equ	COM4A0S	= 6	; Comparator A Output Mode
                                 .equ	COM4A1S	= 7	; Comparator A Output Mode
                                 
                                 ; TCCR4B - Timer/Counter4 Control Register B
                                 .equ	CS40	= 0	; Clock Select Bit 0
                                 .equ	CS41	= 1	; Clock Select Bit 1
                                 .equ	CS42	= 2	; Clock Select Bit 2
                                 .equ	CS43	= 3	; Clock Select Bit 3
                                 .equ	DTPS40	= 4	; Dead Time Prescaler Bit 0
                                 .equ	DTPS41	= 5	; Dead Time Prescaler Bit 1
                                 .equ	PSR4	= 6	; Prescaler Reset Timer/Counter 4
                                 .equ	PWM4X	= 7	; PWM Inversion Mode
                                 
                                 ; TCCR4A - Timer/Counter4 Control Register A
                                 .equ	PWM4B	= 0	; 
                                 .equ	PWM4A	= 1	; 
                                 .equ	FOC4B	= 2	; Force Output Compare Match 4B
                                 .equ	FOC4A	= 3	; Force Output Compare Match 4A
                                 .equ	COM4B0	= 4	; Compare Output Mode 4B, bit 0
                                 .equ	COM4B1	= 5	; Compare Output Mode 4B, bit 1
                                 .equ	COM4A0	= 6	; Compare Output Mode 4A, bit 0
                                 .equ	COM4A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE6	= 6	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE6	= 6	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                                 .equ	ADTS3	= 4	; ADC Auto Trigger Source 3
                                 .equ	MUX5	= 5	; Analog Channel and Gain Selection Bits
                                 .equ	ADHSM	= 7	; ADC High Speed Mode
                                 
                                 ; DIDR0 - Digital Input Disable Register 1
                                 .equ	ADC0D	= 0	; ADC0 Digital input Disable
                                 .equ	ADC1D	= 1	; ADC1 Digital input Disable
                                 .equ	ADC2D	= 2	; ADC2 Digital input Disable
                                 .equ	ADC3D	= 3	; ADC3 Digital input Disable
                                 .equ	ADC4D	= 4	; ADC4 Digital input Disable
                                 .equ	ADC5D	= 5	; ADC5 Digital input Disable
                                 .equ	ADC6D	= 6	; ADC6 Digital input Disable
                                 .equ	ADC7D	= 7	; ADC7 Digital input Disable
                                 
                                 ; DIDR2 - Digital Input Disable Register 1
                                 .equ	ADC8D	= 0	; ADC8 Digital input Disable
                                 .equ	ADC9D	= 1	; ADC9 Digital input Disable
                                 .equ	ADC10D	= 2	; ADC10 Digital input Disable
                                 .equ	ADC11D	= 3	; ADC11 Digital input Disable
                                 .equ	ADC12D	= 4	; ADC12 Digital input Disable
                                 .equ	ADC13D	= 5	; ADC13 Digital input Disable
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - 
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PUD	= 4	; Pull-up disable
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; RCCTRL - Oscillator Control Register
                                 .equ	RCFREQ	= 0	; 
                                 
                                 ; CLKPR - 
                                 .equ	CLKPS0	= 0	; 
                                 .equ	CLKPS1	= 1	; 
                                 .equ	CLKPS2	= 2	; 
                                 .equ	CLKPS3	= 3	; 
                                 .equ	CLKPCE	= 7	; 
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                                 
                                 ; EIND - Extended Indirect Register
                                 .equ	EIND0	= 0	; Bit 0
                                 
                                 ; GPIOR2 - General Purpose IO Register 2
                                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                                 
                                 ; GPIOR1 - General Purpose IO Register 1
                                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                                 
                                 ; GPIOR0 - General Purpose IO Register 0
                                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                                 
                                 ; PRR1 - Power Reduction Register1
                                 .equ	PRUSART1	= 0	; Power Reduction USART1
                                 .equ	PRTIM3	= 3	; Power Reduction Timer/Counter3
                                 .equ	PRUSB	= 7	; Power Reduction USB
                                 
                                 ; PRR0 - Power Reduction Register0
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 ; CLKSTA - 
                                 .equ	EXTON	= 0	; 
                                 .equ	RCON	= 1	; 
                                 
                                 ; CLKSEL0 - 
                                 .equ	CLKS	= 0	; 
                                 .equ	EXTE	= 2	; 
                                 .equ	RCE	= 3	; 
                                 .equ	EXSUT0	= 4	; 
                                 .equ	EXSUT1	= 5	; 
                                 .equ	RCSUT0	= 6	; 
                                 .equ	RCSUT1	= 7	; 
                                 
                                 ; CLKSEL1 - 
                                 .equ	EXCKSEL0	= 0	; 
                                 .equ	EXCKSEL1	= 1	; 
                                 .equ	EXCKSEL2	= 2	; 
                                 .equ	EXCKSEL3	= 3	; 
                                 .equ	RCCKSEL0	= 4	; 
                                 .equ	RCCKSEL1	= 5	; 
                                 .equ	RCCKSEL2	= 6	; 
                                 .equ	RCCKSEL3	= 7	; 
                                 
                                 
                                 ; ***** PLL **************************
                                 ; PLLCSR - PLL Status and Control register
                                 .equ	PLOCK	= 0	; PLL Lock Status Bit
                                 .equ	PLLE	= 1	; PLL Enable Bit
                                 .equ	PINDIV	= 4	; PLL prescaler Bit 2
                                 
                                 ; PLLFRQ - PLL Frequency Control Register
                                 .equ	PDIV0	= 0	; 
                                 .equ	PDIV1	= 1	; 
                                 .equ	PDIV2	= 2	; 
                                 .equ	PDIV3	= 3	; 
                                 .equ	PLLTM0	= 4	; 
                                 .equ	PLLTM1	= 5	; 
                                 .equ	PLLUSB	= 6	; 
                                 .equ	PINMUX	= 7	; 
                                 
                                 
                                 ; ***** USB_DEVICE *******************
                                 ; USBCON - USB General Control Register
                                 .equ	VBUSTE	= 0	; 
                                 .equ	OTGPADE	= 4	; 
                                 .equ	FRZCLK	= 5	; 
                                 .equ	USBE	= 7	; 
                                 
                                 ; UDCON - 
                                 .equ	DETACH	= 0	; 
                                 .equ	RMWKUP	= 1	; 
                                 .equ	LSM	= 2	; USB low speed mode
                                 .equ	RSTCPU	= 3	; 
                                 
                                 ; UDINT - 
                                 .equ	SUSPI	= 0	; 
                                 .equ	SOFI	= 2	; 
                                 .equ	EORSTI	= 3	; 
                                 .equ	WAKEUPI	= 4	; 
                                 .equ	EORSMI	= 5	; 
                                 .equ	UPRSMI	= 6	; 
                                 
                                 ; UDIEN - 
                                 .equ	SUSPE	= 0	; 
                                 .equ	SOFE	= 2	; 
                                 .equ	EORSTE	= 3	; 
                                 .equ	WAKEUPE	= 4	; 
                                 .equ	EORSME	= 5	; 
                                 .equ	UPRSME	= 6	; 
                                 
                                 ; UDADDR - 
                                 .equ	UADD0	= 0	; 
                                 .equ	UADD1	= 1	; 
                                 .equ	UADD2	= 2	; 
                                 .equ	UADD3	= 3	; 
                                 .equ	UADD4	= 4	; 
                                 .equ	UADD5	= 5	; 
                                 .equ	UADD6	= 6	; 
                                 .equ	ADDEN	= 7	; 
                                 
                                 ; UDFNUML - 
                                 .equ	FNUM0	= 0	; 
                                 .equ	FNUM1	= 1	; 
                                 .equ	FNUM2	= 2	; 
                                 .equ	FNUM3	= 3	; 
                                 .equ	FNUM4	= 4	; 
                                 .equ	FNUM5	= 5	; 
                                 .equ	FNUM6	= 6	; 
                                 .equ	FNUM7	= 7	; 
                                 
                                 ; UDFNUMH - 
                                 .equ	FNUM8	= 0	; 
                                 .equ	FNUM9	= 1	; 
                                 .equ	FNUM10	= 2	; 
                                 
                                 ; UDMFN - 
                                 .equ	FNCERR	= 4	; 
                                 
                                 ; UEINTX - 
                                 .equ	TXINI	= 0	; 
                                 .equ	STALLEDI	= 1	; 
                                 .equ	RXOUTI	= 2	; 
                                 .equ	RXSTPI	= 3	; 
                                 .equ	NAKOUTI	= 4	; 
                                 .equ	RWAL	= 5	; 
                                 .equ	NAKINI	= 6	; 
                                 .equ	FIFOCON	= 7	; 
                                 
                                 ; UENUM - 
                                 .equ	UENUM_0	= 0	; 
                                 .equ	UENUM_1	= 1	; 
                                 .equ	UENUM_2	= 2	; 
                                 
                                 ; UERST - 
                                 .equ	EPRST0	= 0	; 
                                 .equ	EPRST1	= 1	; 
                                 .equ	EPRST2	= 2	; 
                                 .equ	EPRST3	= 3	; 
                                 .equ	EPRST4	= 4	; 
                                 .equ	EPRST5	= 5	; 
                                 .equ	EPRST6	= 6	; 
                                 
                                 ; UECONX - 
                                 .equ	EPEN	= 0	; 
                                 .equ	RSTDT	= 3	; 
                                 .equ	STALLRQC	= 4	; 
                                 .equ	STALLRQ	= 5	; 
                                 
                                 ; UECFG0X - 
                                 .equ	EPDIR	= 0	; 
                                 .equ	EPTYPE0	= 6	; 
                                 .equ	EPTYPE1	= 7	; 
                                 
                                 ; UECFG1X - 
                                 .equ	ALLOC	= 1	; 
                                 .equ	EPBK0	= 2	; 
                                 .equ	EPBK1	= 3	; 
                                 .equ	EPSIZE0	= 4	; 
                                 .equ	EPSIZE1	= 5	; 
                                 .equ	EPSIZE2	= 6	; 
                                 
                                 ; UESTA0X - 
                                 .equ	NBUSYBK0	= 0	; 
                                 .equ	NBUSYBK1	= 1	; 
                                 .equ	DTSEQ0	= 2	; 
                                 .equ	DTSEQ1	= 3	; 
                                 .equ	UNDERFI	= 5	; 
                                 .equ	OVERFI	= 6	; 
                                 .equ	CFGOK	= 7	; 
                                 
                                 ; UESTA1X - 
                                 .equ	CURRBK0	= 0	; 
                                 .equ	CURRBK1	= 1	; 
                                 .equ	CTRLDIR	= 2	; 
                                 
                                 ; UEIENX - 
                                 .equ	TXINE	= 0	; 
                                 .equ	STALLEDE	= 1	; 
                                 .equ	RXOUTE	= 2	; 
                                 .equ	RXSTPE	= 3	; 
                                 .equ	NAKOUTE	= 4	; 
                                 .equ	NAKINE	= 6	; 
                                 .equ	FLERRE	= 7	; 
                                 
                                 ; UEDATX - 
                                 .equ	DAT0	= 0	; 
                                 .equ	DAT1	= 1	; 
                                 .equ	DAT2	= 2	; 
                                 .equ	DAT3	= 3	; 
                                 .equ	DAT4	= 4	; 
                                 .equ	DAT5	= 5	; 
                                 .equ	DAT6	= 6	; 
                                 .equ	DAT7	= 7	; 
                                 
                                 ; UEBCLX - 
                                 .equ	BYCT0	= 0	; 
                                 .equ	BYCT1	= 1	; 
                                 .equ	BYCT2	= 2	; 
                                 .equ	BYCT3	= 3	; 
                                 .equ	BYCT4	= 4	; 
                                 .equ	BYCT5	= 5	; 
                                 .equ	BYCT6	= 6	; 
                                 .equ	BYCT7	= 7	; 
                                 
                                 ; UEINT - 
                                 .equ	EPINT0	= 0	; 
                                 .equ	EPINT1	= 1	; 
                                 .equ	EPINT2	= 2	; 
                                 .equ	EPINT3	= 3	; 
                                 .equ	EPINT4	= 4	; 
                                 .equ	EPINT5	= 5	; 
                                 .equ	EPINT6	= 6	; 
                                 
                                 ; USBINT - 
                                 .equ	VBUSTI	= 0	; 
                                 
                                 ; USBSTA - 
                                 .equ	VBUS	= 0	; 
                                 .equ	SPEED	= 3	; 
                                 
                                 ; USBCON - USB General Control Register
                                 ;.equ	VBUSTE	= 0	; 
                                 ;.equ	OTGPADE	= 4	; 
                                 ;.equ	FRZCLK	= 5	; 
                                 ;.equ	USBE	= 7	; 
                                 
                                 ; UHWCON - 
                                 .equ	UVREGE	= 0	; 
                                 
                                 ; TWCR - Two-Wire Interface Control
                                 .equ		TWIE	= 0	;
                                 .equ 		TWEN	= 2	;
                                 .equ 		TWWC	= 3	;
                                 .equ 		TWSTO	= 4	;
                                 .equ 		TWSTA	= 5	;
                                 .equ 		TWEA	= 6	;
                                 .equ 		TWINT	= 7	;
                                 
                                 ; TWSR - Two-Wire Status
                                 .equ 		TWPS0	= 0	;
                                 .equ 		TWPS1	= 1	;
                                 
                                 ; TWAR
                                 .equ 		TWGCE	= 0	;
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Oscillator options
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 .equ	HWBE	= 3	; Hardware Boot Enable
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 2560
                                 .equ	RAMEND	= 0x0aff
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x03ff
                                 .equ	EEPROMEND	= 0x03ff
                                 .equ	EEADRBITS	= 10
                                 #pragma AVRPART MEMORY PROG_FLASH 32768
                                 #pragma AVRPART MEMORY EEPROM 1024
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 2560
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x3800
                                 .equ	NRWW_STOP_ADDR	= 0x3fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x37ff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x3f00
                                 .equ	SECONDBOOTSTART	= 0x3e00
                                 .equ	THIRDBOOTSTART	= 0x3c00
                                 .equ	FOURTHBOOTSTART	= 0x3800
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	Reserved1addr	= 0x000a	; Reserved1
                                 .equ	Reserved2addr	= 0x000c	; Reserved2
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	Reserved3addr	= 0x0010	; Reserved3
                                 .equ	PCI0addr	= 0x0012	; Pin Change Interrupt Request 0
                                 .equ	USB_GENaddr	= 0x0014	; USB General Interrupt Request
                                 .equ	USB_COMaddr	= 0x0016	; USB Endpoint/Pipe Interrupt Communication Request
                                 .equ	WDTaddr	= 0x0018	; Watchdog Time-out Interrupt
                                 .equ	Reserved4addr	= 0x001a	; Reserved4
                                 .equ	Reserved5addr	= 0x001c	; Reserved5
                                 .equ	Reserved6addr	= 0x001e	; Reserved6
                                 .equ	ICP1addr	= 0x0020	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0022	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0024	; Timer/Counter1 Compare Match B
                                 .equ	OC1Caddr	= 0x0026	; Timer/Counter1 Compare Match C
                                 .equ	OVF1addr	= 0x0028	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x002a	; Timer/Counter0 Compare Match A
                                 .equ	OC0Baddr	= 0x002c	; Timer/Counter0 Compare Match B
                                 .equ	OVF0addr	= 0x002e	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0030	; SPI Serial Transfer Complete
                                 .equ	URXC1addr	= 0x0032	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x0034	; USART1 Data register Empty
                                 .equ	UTXC1addr	= 0x0036	; USART1, Tx Complete
                                 .equ	ACIaddr	= 0x0038	; Analog Comparator
                                 .equ	ADCCaddr	= 0x003a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x003c	; EEPROM Ready
                                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0044	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x0046	; Timer/Counter3 Overflow
                                 .equ	TWIaddr	= 0x0048	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x004a	; Store Program Memory Read
                                 .equ	OC4Aaddr	= 0x004c	; Timer/Counter4 Compare Match A
                                 .equ	OC4Baddr	= 0x004e	; Timer/Counter4 Compare Match B
                                 .equ	OC4Daddr	= 0x0050	; Timer/Counter4 Compare Match D
                                 .equ	OVF4addr	= 0x0052	; Timer/Counter4 Overflow
                                 .equ	TIMER4_FPFaddr	= 0x0054	; Timer/Counter4 Fault Protection Interrupt
                                 
                                 .equ	INT_VECTORS_SIZE	= 86	; size in words
                                 
                                 #endif  /* _M32U4DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;***********************************************************
                                 ;*
                                 ;*	This is the TRANSMIT skeleton file for Lab 7 of ECE 375
                                 ;*
                                 ;*  	Rock Paper Scissors
                                 ;* 	Requirement:
                                 ;* 	1. USART1 communication
                                 ;* 	2. Timer/counter1 Normal mode to create a 1.5-sec delay
                                 ;***********************************************************
                                 ;*
                                 ;*	 Author: Ian Kiser, Evan Shishido
                                 ;*	   Date: 12/6/2024
                                 ;*
                                 ;***********************************************************
                                 
                                 .include "m32U4def.inc"         ; Include definition file
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32U4.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32U4def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32U4
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32U4
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32U4DEF_INC_
                                 #endif  /* _M32U4DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;***********************************************************
                                 ;*  Internal Register Definitions and Constants
                                 ;***********************************************************
                                 .def    mpr = r16    ; Multi-Purpose Register		
                                 .def	choice_left = r17
                                 .def	choice_right = r18 ;makes sense to store choice values seperately from LCD because it will be easier to send between boards and interract with LCD
                                 
                                 ;r20-r22 reserved
                                 
                                 ; Use this signal code between two boards for their game ready
                                 .equ    SendReady = 0b11111111
                                 
                                 ;***********************************************************
                                 ;*  Start of Code Segment
                                 ;***********************************************************
                                 .cseg                           ; Beginning of code segment
                                 
                                 ;***********************************************************
                                 ;*  Interrupt Vectors
                                 ;***********************************************************
                                 .org    $0000                   ; Beginning of IVs
000000 c055                      	    rjmp    INIT            	; Reset interrupt
                                 
                                 .org		$0002 ;int 0, will be tied to PD4, interrupts will need EIMSK, and EICRA/B registers set correctly
                                 		;select choice left
000002 9518                      		reti
                                 
                                 .org		$0004 ;int 1, might be tied to PD5, for extra credit
                                 		;select choice right
000004 9518                      		reti
                                 
                                 ;.org read interrupt vector on usart 1
                                 
                                 .org    $0056                   ; End of Interrupt Vectors
                                 
                                 ;***********************************************************
                                 ;*  Program Initialization
                                 ;***********************************************************
                                 INIT:
                                 	;Stack Pointer (VERY IMPORTANT!!!!)
000056 ef0f                      	ldi mpr, low(RAMEND) ;retrieve ramend low from program memory
000057 bf0d                      	out SPL, mpr ;load ramend low into stack pointer low via mpr, out is needed as SP(stack pointer) is in io mem
000058 e00a                      	ldi mpr, high(RAMEND);retrieve ramend high from program memory
000059 bf0e                      	out SPH, mpr ;load ramend high into stack pointer low via mpr
                                 	
                                 
                                 
                                 	;I/O Ports
                                 	;port D -> input for button presses, 
00005a e000                      	ldi mpr, 0
00005b b90a                      	out DDRD, mpr ;set portD for input
00005c ef0f                      	ldi mpr, $FF
00005d b90b                      	out PORTD, mpr ;set pull up resistors
                                 
                                 	;port B -> PORTB[4:7] output for LED countdown/timer counter, PB[0:2] used by LCD driver
00005e ef0f                      	ldi mpr, $FF
00005f b904                      	out DDRB, mpr; set PORTB for output 
                                 
                                 	;configure external interrupts to trigger on falling edge ie button pressed, pin shorted to ground, for int0 and int1
                                 	;EICRA gets 0b00001010
000060 e00a                      	ldi mpr, 0b00001010
000061 9300 0069                 	sts EICRA, mpr
                                 
                                 	 
                                 
                                 
                                 
                                 	;USART1
                                 	;Set baudrate at 2400bps -> I believe system clock is 8MHz, therefore UBRR gets 207 by table 18-4 in data sheet
                                 	;Enable receiver and transmitter
                                 	;Set frame format: 8 data bits, 2 stop bits
                                 	;do not use SBI and CBI, and sbis sbic because of fifo 
                                 
                                 	;UCSR1A: bit 7 RXC1(recieve complete) -> 0, bit 6 TXC1 (transmit complete) -> 0, bit 5 UDRE1 (data reg empty) -> 1, error bits[4:2] -> 0
                                 	; bit 1 U2X1 (double transmit speed) -> 0 for normal speed, bit 0 MPCM1 (multi processor communication) -> 0 (do not want to send address info)
                                 
                                 	;UCSR1B: bit 7 RXCIE1 (RX complete interrupt enable) -> set for interrupt, bit 6 TXCIE1 (TX interrupt) -> set for interrupt, bit 5 UDRIE1 (interrupt for UDRE1 flag) -> set for interrupt
                                 	;bit 4 RXEN1 (reciever enable) -> 1, bit 3 TXEN1 (transmit enable) -> 1, bit 2 UCSZ12 (character size) -> 0 for 8 bit characters, bits[1:0] RX/TX 81 (recieve and transmit data bit 8) -> 0 I think since frams will be 8 bit  
                                 	
                                 	;UCSR1C: bits [7:6] UMSEL1 1/0 (usart mode select) -> 00 for asychronous, UPM1 1/0 (parit mode) -> 00 for disabled, bit 3 USBS1 (stop bit select) -> 1 for 2 bit, bits [2:1] UCSZ1 [1:0] (character size) -> 11 for 8 bit,
                                 	; bit 0 UCPOL1 (clock polarity) -> 0 for falling edge
                                 
                                 	;UCSR1D: might need to set bits 1:0 but probably not, they control something called transmission and reception flow control
                                 
                                 	;UCSR1A need not be loaded
                                 	;UCSR1B gets 0b10011000 -> enable read interrupt
                                 	;UCSR1C gets 0b00001110
                                 	;UBRRH1 gets 0b00000000
                                 	;UBRRL1 gets $CF -> 207
                                 
                                 
000063 e908                      	ldi mpr, 0b10011000 ; enable read interrupt
000064 9300 00c9                 	sts UCSR1B, mpr
000066 e00e                      	ldi mpr, 0b00001110
000067 9300 00ca                 	sts UCSR1C, mpr
                                 
000069 e000                      	ldi mpr, 0
00006a 9300 00cd                 	sts UBRR1H, mpr
00006c ec0f                      	ldi mpr, $CF
00006d 9300 00cc                 	sts UBRR1L, mpr
                                 
                                 
                                 	;TIMER/COUNTER1
                                 	;Set Normal mode
                                 	;No need for external pin interrupts -> all OC bits set low, Normal mode -> WGM bits low as well
                                 	;TCCR1A gets 0b00000000, This is initial value by default, no need to load
                                 	;no ICN stabilization, normal mode, and 1/256 prescaling -> TOV flag set about every 1.5 seconds when TCNT initially gets 48E4
                                 	;TCCR1B gets 0b00000010
00006f e000                      	ldi mpr, 0b00000000
000070 9300 0080                 	sts TCCR1A, mpr
000072 e004                      	ldi mpr, 0b00000100
000073 9300 0081                 	sts TCCR1B, mpr
                                 
                                 
                                 	
                                 
                                 	;Other
000075 d122                      	rcall LCDInit
000076 d143                      	rcall LCDBacklightOn 
000077 d15f                      	rcall LCDClr
000078 e010                      	ldi choice_left, 0
000079 e020                      	ldi choice_right, 0
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*  Main Program
                                 ;***********************************************************
                                 MAIN:
                                 
                                 ;launch to welcome screen, poll for PD7
                                 ;loop until PD7 pressed
                                 
                                 ;PD7 pressed
                                 ;begin continuously transmitting ready signal
                                 ;enable recieve interrupt 
                                 ;display ready and waiting screen
                                 
                                 ;ready recieved
                                 ;stop transmitting ready signal
                                 ;check if we have stopped recieving ready signal -> other board has recieved our ready -> both ready
                                 
                                 ;display game start
                                 ;wait 1.5 seconds
                                 ;start LED timer
                                 
                                 ;enable int 0 (and possibly int 1 if extra credit) in interrupt mask
                                 ;ldi mpr, 
                                 ;PD4 selects play option via interrupt
                                 
                                 ;timer ends
                                 ;disable int 0 (and possibly int 1 if extra credit) in interrupt mask
                                 ;begin continously transmitting choice(s), and stop when opponants choice recieved
                                 ;repeat for second choice if doing extra credit
                                 
                                 ;display choices
                                 ;timer start again
                                 
                                 ;if doing extra credit have shoot interface
                                 
                                 ;timer ends
                                 ;display win/lose screen
                                 ;timer start again
                                 
                                 ;timer ends
                                 ;restart code
                                 
                                 
                                 main_loop:
                                 
                                 ;testing
                                 ;call welcome
00007a d01c                      rcall welcome
                                 
                                 ;mpr means somethig past here
                                 transmit_loop:
                                 ;try to read -> set mpr to ready recieved
00007b 9100 00ce                 lds mpr, UDR1 ;mpr now either holds ready, or is empty
                                 ;wait for UDR1 reg empty flag
00007d d012                      rcall check_UDR1
                                 
00007e 930f                      push mpr ;save recieve value
                                 ;transmit ready -> must not be done on mpr so we can check afterwards
00007f ef0f                      ldi mpr, SendReady
000080 9300 00ce                 sts UDR1, mpr
000082 910f                      pop mpr ;restore recieve value
                                 
                                 ;again wait for data reg empty flag
000083 d00c                      rcall check_UDR1
                                 
                                 
000084 3f0f                      cpi mpr, SendReady
000085 f7a9                      brne transmit_loop ;loop if mpr is not set to ready
                                 ;then read to clear URD1 reg
000086 9100 00ce                 lds mpr, UDR1
                                 
000088 d007                      rcall check_UDR1 
                                 ;continue
                                 
000089 d14d                      rcall LCDClr
                                 
                                 
00008a ece8                      ldi ZL, low(str_paper<<1)
00008b e0f2                      ldi ZH, high(str_paper<<1)
                                 
00008c ecce                      ldi YL, low(str_paper_end<<1)
00008d e0d2                      ldi YH, high(str_paper_end<<1)
                                 
00008e d083                      rcall print_zy_top
                                 
                                 
                                 
                                 
                                 
                                 
00008f cfea                      rjmp main_loop
                                 
                                 ;***********************************************************
                                 ;*	Functions and Subroutines
                                 ;***********************************************************
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: check_UDR1
                                 ;*	desc: returns once the UDR1 register has been cleared, uses 
                                 ;***********************************************************
                                 check_UDR1:
000090 930f                      push mpr
                                 
                                 check_UDR1_not_clear:
000091 9100 00c8                 lds mpr, UCSR1A
000093 ff05                      sbrs mpr, 5
000094 f7e1                      brne check_UDR1_not_clear ;if data reg not empty wait for it to be empty
                                 
                                 
                                 
000095 910f                      pop mpr
000096 9508                      ret
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: welcome
                                 ;*	desc: display welcome screen and poll for PD7, exit when pressed and then released
                                 ;***********************************************************
                                 welcome:
000097 930f                      push mpr
                                 
                                 
000098 efe0                      ldi ZL, low(str_welcome1<<1)
000099 e0f2                      ldi ZH, high(str_welcome1<<1)
                                 
00009a efc8                      ldi YL, low(str_welcome1_end<<1)
00009b e0d2                      ldi YH, high(str_welcome1_end<<1)
                                 
00009c d075                      rcall print_zy_top
                                 
00009d efe8                      ldi ZL, low(str_welcome2<<1)
00009e e0f2                      ldi ZH, high(str_welcome2<<1)
                                 
00009f e0c8                      ldi YL, low(str_welcome2_end<<1)
0000a0 e0d3                      ldi YH, high(str_welcome2_end<<1)
                                 
0000a1 d086                      rcall print_zy_bottom
                                 
                                 
                                 welcome_not_pressed:
0000a2 994f                      sbic PIND, PD7
0000a3 cffe                      rjmp welcome_not_pressed
                                 ;PD7 is now pressed
0000a4 0000                      nop
0000a5 0000                      nop ;avoid some debouncing
                                 welcome_pressed:
0000a6 9b4f                      sbis PIND, PD7
0000a7 cffe                      rjmp welcome_pressed
                                 ;PD7 is now released
                                 
                                 
                                 
0000a8 910f                      pop mpr
0000a9 9508                      ret
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: select_choice_left
                                 ;*	desc: cycles through choices for rock paper scissors and prints them to the LCD on the left hand side, preserves right hand side of LCD
                                 ;***********************************************************
                                 select_choice_left:
0000aa 930f                      push mpr
0000ab 932f                      push choice_right
                                 ;changes made to choice left will be saved globally
                                 
                                 ;valid choice values include 1,2,3, for rock paper and scissors respectively. 0 will be initialization value so when button is first pressed rock is shown 
                                 ;check if choice left is 10, load with 00 if so
                                 ;otherwise increment choice left
                                 
0000ac 3013                      cpi choice_left, 3
0000ad f011                      breq select_choice_left_rollover ;if at two do not increment
                                 
0000ae 9513                      inc choice_left
                                 
0000af c001                      rjmp select_choice_left_chosen ;do not roll over if unneeded 
                                 
                                 select_choice_left_rollover:
0000b0 e011                      ldi choice_left, 1
                                 
                                 select_choice_left_chosen:
                                 ;load z and y with labels for str clear
                                 ;call zy print function to write spaces to left hand side of LCD without clearing right hand side
                                 ;based on choice left value load Z and Y with appropriate labels for word
                                 ;call zy print function
                                 
0000b1 ebec                      ldi ZL, low(str_clear<<1)
0000b2 e0f2                      ldi ZH, high(str_clear<<1)
                                 
0000b3 ecc4                      ldi YL, low(str_clear_end<<1)
0000b4 e0d2                      ldi YH, high(str_clear_end<<1)
                                 
0000b5 d072                      rcall print_zy_bottom ;write clear string to left side of LCD
0000b6 d013                      rcall load_choice_left ;load Z and Y registers with correct string lables
0000b7 d070                      rcall print_zy_bottom ;print correct choice of string to LCD
                                 
                                 
                                 
                                 
0000b8 912f                      pop choice_right
0000b9 910f                      pop mpr
0000ba 9508                      ret
                                 ;end select_choice_left
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: select_choice_right
                                 ;*	desc: cycles through choices for rock paper scissors and prints them to the LCD on the left hand side, preserves right hand side of LCD
                                 ;***********************************************************
                                 select_choice_right:
0000bb 930f                      push mpr
                                 
                                 ;changes made to choice left will be saved globally
                                 
                                 ;valid choice values include 1,2,3, for rock paper and scissors respectively. 0 will be initialization value so when button is first pressed rock is shown 
                                 ;check if choice left is 10, load with 00 if so
                                 ;otherwise increment choice left
                                 
0000bc 3023                      cpi choice_right, 3
0000bd f011                      breq select_choice_right_rollover ;if at two do not increment
                                 
0000be 9523                      inc choice_right
                                 
0000bf c001                      rjmp select_choice_right_chosen ;do not roll over if unneeded 
                                 
                                 select_choice_right_rollover:
0000c0 e021                      ldi choice_right, 1
                                 
                                 select_choice_right_chosen:
                                 ;load z and y with labels for str clear
                                 ;call zy print function to write spaces to left hand side of LCD without clearing right hand side
                                 ;based on choice left value load Z and Y with appropriate labels for word
                                 ;call zy print function
                                 
0000c1 ebec                      ldi ZL, low(str_clear<<1)
0000c2 e0f2                      ldi ZH, high(str_clear<<1)
                                 
0000c3 ecc4                      ldi YL, low(str_clear_end<<1)
0000c4 e0d2                      ldi YH, high(str_clear_end<<1)
                                 
0000c5 d078                      rcall print_yz_bottom ;write clear string to left side of LCD
0000c6 d01a                      rcall load_choice_right ;load Z and Y registers with correct string lables
0000c7 d076                      rcall print_yz_bottom ;print correct choice of string to LCD
                                 
                                 
                                 
0000c8 910f                      pop mpr
0000c9 9508                      ret
                                 ;end select_choice_right
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: load_choice_left
                                 ;*	desc: loads correct string into Z and Y registers depending on choice left value
                                 ;***********************************************************
                                 load_choice_left:
0000ca 930f                      push mpr
                                 
0000cb 3011                      cpi choice_left, 1
0000cc f021                      breq load_choice_left_rock
                                 
0000cd 3012                      cpi choice_left, 2
0000ce f039                      breq load_choice_left_paper		;find choice_left value
                                 
0000cf 3013                      cpi choice_left, 3
0000d0 f051                      breq load_choice_left_scissors
                                 
                                 
                                 load_choice_left_rock:
0000d1 ece4                      ldi ZL, low(str_rock<<1)
0000d2 e0f2                      ldi ZH, high(str_rock<<1)
                                 
0000d3 ecc8                      ldi YL, low(str_rock_end<<1)
0000d4 e0d2                      ldi YH, high(str_rock_end<<1)
                                 
0000d5 c009                      rjmp load_choice_left_end
                                 
                                 load_choice_left_paper:				;load correct string beginning into Z, and end into Y
0000d6 ece8                      ldi ZL, low(str_paper<<1)
0000d7 e0f2                      ldi ZH, high(str_paper<<1)
                                 
0000d8 ecce                      ldi YL, low(str_paper_end<<1)
0000d9 e0d2                      ldi YH, high(str_paper_end<<1)
                                 
0000da c004                      rjmp load_choice_left_end
                                 
                                 load_choice_left_scissors:
0000db ecee                      ldi ZL, low(str_scissors<<1)
0000dc e0f2                      ldi ZH, high(str_scissors<<1)
                                 
0000dd edc6                      ldi YL, low(str_scissors_end<<1)
0000de e0d2                      ldi YH, high(str_scissors_end<<1)
                                 
                                 load_choice_left_end:
0000df 910f                      pop mpr
0000e0 9508                      ret
                                 ;end load_choice_left
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: load_choice_right
                                 ;*	desc: loads correct string into Z and Y registers depending on choice right value
                                 ;***********************************************************
                                 load_choice_right:
0000e1 930f                      push mpr
                                 
0000e2 3021                      cpi choice_right, 1
0000e3 f021                      breq load_choice_right_rock
                                 
0000e4 3022                      cpi choice_right, 2
0000e5 f039                      breq load_choice_right_paper		;find choice_left value
                                 
0000e6 3023                      cpi choice_right, 3
0000e7 f051                      breq load_choice_right_scissors
                                 
                                 
                                 load_choice_right_rock:
0000e8 ece4                      ldi ZL, low(str_rock<<1)
0000e9 e0f2                      ldi ZH, high(str_rock<<1)
                                 
0000ea ecc8                      ldi YL, low(str_rock_end<<1)
0000eb e0d2                      ldi YH, high(str_rock_end<<1)
                                 
0000ec c009                      rjmp load_choice_right_end
                                 
                                 load_choice_right_paper:				;load correct string beginning into Z, and end into Y
0000ed ece8                      ldi ZL, low(str_paper<<1)
0000ee e0f2                      ldi ZH, high(str_paper<<1)
                                 
0000ef ecce                      ldi YL, low(str_paper_end<<1)
0000f0 e0d2                      ldi YH, high(str_paper_end<<1)
                                 
0000f1 c004                      rjmp load_choice_right_end
                                 
                                 load_choice_right_scissors:
0000f2 ecee                      ldi ZL, low(str_scissors<<1)
0000f3 e0f2                      ldi ZH, high(str_scissors<<1)
                                 
0000f4 edc6                      ldi YL, low(str_scissors_end<<1)
0000f5 e0d2                      ldi YH, high(str_scissors_end<<1)
                                 
                                 load_choice_right_end:
0000f6 910f                      pop mpr
0000f7 9508                      ret
                                 
                                 ;end load_choice_right
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: led_countdown
                                 ;*	desc: counts down 6 seconds and displays on led's
                                 ;***********************************************************
                                 led_countdown:
0000f8 930f                      push mpr
                                 
0000f9 b105                      in mpr, PORTB
0000fa 6f00                      ori mpr, 0b11110000
0000fb b905                      out PORTB, mpr ;all led's are now set
                                 
0000fc d009                      rcall timer_1_5 ;wait
0000fd 982c                      cbi PORTB, 4 ;clear bit 4
0000fe d007                      rcall timer_1_5 ;repeat for other bits
0000ff 982d                      cbi PORTB, 5
000100 d005                      rcall timer_1_5
000101 982e                      cbi PORTB, 6
000102 d003                      rcall timer_1_5
000103 982f                      cbi PORTB, 7
                                 
000104 910f                      pop mpr
000105 9508                      ret
                                 ;end led_countdown
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: timer_1_5
                                 ;*	desc: polls timer counter 1 for a 1.5 second timer
                                 ;***********************************************************
                                 timer_1_5:
                                 ;push stuff to stack
000106 930f                      push mpr
                                 
                                 
                                 
000107 e408                      ldi mpr, $48
000108 9300 0085                 sts TCNT1H, mpr
00010a ee04                      ldi mpr, $E4
00010b 9300 0084                 sts TCNT1L, mpr
                                 
                                 timer_1_5_NoFlag:
00010d 9bb0                      sbis TIFR1, 0 ;skip loop if TOV1 is set
00010e cffe                      rjmp timer_1_5_NoFlag
                                 
00010f 9ab0                      sbi TIFR1, 0 ;reset TOV1
                                 
                                 ;pop stuff from stack
                                 
000110 910f                      pop mpr
000111 9508                      ret
                                 ;end timer_1_5
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: print_zy_top
                                 ;*	desc: stores string stored in program memory and writes it to the top line of the LCD screen
                                 ;*	REMEMBER: the address stored in z and in y must be initially bit shifted by 1 due to least sig bit being low or high indicator.
                                 ;*	WARNING - assumes Z stores the address of the beginning of the string and Y stores the end of the string to print.
                                 ;***********************************************************
                                 print_zy_top:
000112 930f                      push mpr
000113 93af                      push XL
000114 93bf                      push XH
000115 93ef                      push ZL
000116 93ff                      push ZH
000117 93cf                      push YL
000118 93df                      push YH
                                 
                                 
000119 e0a0                      ldi XL, LOW(lcd_buffer_addr) ;point X to the top line of the LCD buffer address in data memory
00011a e0b1                      ldi XH, HIGH(lcd_buffer_addr)
                                 
                                 print_zy_top_loop:
00011b 9105                      lpm mpr, Z+ ;load value stored at the address to the beginning of the string (stored in X) to mpr, then inc X to point to next char. ie. first character of string is loaded into mpr
00011c 930d                      st X+, mpr ;Store that character to the beginning of the LCD buffer, then increment to next spot in LCD buffer
                                 
00011d 17ec                      cp ZL, YL  ;compare where Z points (current address) to Y (end of string), we only need Low byte since start and end are definitely far enough away to cause roll over errors
00011e f7e1                      brne print_zy_top_loop ;if not at end keep loading LCD buffer
                                 
00011f d0a1                      rcall	LCDWrLn1 ;once done write to LCD
                                 
000120 91df                      pop YH
000121 91cf                      pop YL
000122 91ff                      pop ZH
000123 91ef                      pop ZL
000124 91bf                      pop XH
000125 91af                      pop XL 
000126 910f                      pop mpr
000127 9508                      ret
                                 ;end print_zy_top
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: print_zy_bottom
                                 ;*	desc: stores string stored in program memory and writes it to the bottom line of the LCD screen on the left
                                 ;*	REMEMBER: the address stored in z and in y must be initially bit shifted by 1 due to least sig bit being low or high indicator. 
                                 ;*	REMEMBER: you must clear line outside of this function to prevent overwriting
                                 ;*	WARNING: assumes Z stores the address of the beginning of the string and Y stores the end of the string to print.
                                 ;***********************************************************
                                 print_zy_bottom:
000128 930f                      push mpr
000129 93af                      push XL
00012a 93bf                      push XH
00012b 93ef                      push ZL
00012c 93ff                      push ZH
00012d 93cf                      push YL
00012e 93df                      push YH
                                 
                                 
00012f e1a0                      ldi XL, LOW(lcd_buffer_addr+16) ;point x to the bottom line of the LCD buffer address in data memory
000130 e0b1                      ldi XH, HIGH(lcd_buffer_addr+16)
                                 
                                 print_zy_bottom_left_loop:
000131 9105                      lpm mpr, Z+ ;load value stored at the address to the beginning of the string (stored in X) to mpr, then inc X to point to next char. ie. first character of string is loaded into mpr
000132 930d                      st X+, mpr ;Store that character to the beginning of the LCD buffer, then increment to next spot in LCD buffer
                                 
000133 17ec                      cp ZL, YL ;compare where Z points (current address) to Y (end of string), we only need Low byte since start and end are definitely not far enough away to cause roll over errors
000134 f7e1                      brne print_zy_bottom_left_loop ;if not at end keep loading LCD buffer
                                 
000135 d096                      rcall	LCDWrLn2 ;once done write to LCD 
                                 
000136 91df                      pop YH
000137 91cf                      pop YL
000138 91ff                      pop ZH
000139 91ef                      pop ZL
00013a 91bf                      pop XH
00013b 91af                      pop XL 
00013c 910f                      pop mpr
00013d 9508                      ret
                                 ;end print_zy_bottom
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: print_yz_bottom
                                 ;*	desc: stores string stored in program memory and writes it to the bottom line of the LCD screen on the right
                                 ;*	REMEMBER: the address stored in z and in y must be initially bit shifted by 1 due to least sig bit being low or high indicator. 
                                 ;*	REMEMBER: you must clear line outside of this function to prevent overwriting
                                 ;*	WARNING: assumes Z stores the address of the beginning of the string and Y stores the end of the string to print.
                                 ;***********************************************************
                                 print_yz_bottom:
00013e 930f                      push mpr
00013f 93af                      push XL
000140 93bf                      push XH
000141 93ef                      push ZL
000142 93ff                      push ZH
000143 93cf                      push YL
000144 93df                      push YH
                                 
                                 ;must call lpm on Z, and need to call at end adress so shift Z->Y, and Y->Z for sake of function
000145 2fae                      mov XL, ZL
000146 2fbf                      mov XH, ZH ;X now temporarily holds old Z
                                 
000147 2fec                      mov ZL, YL
000148 2ffd                      mov ZH, YH ;Z now holds old Y 
                                 
000149 2fca                      mov YL, XL
00014a 2fdb                      mov YH, XH ;Y now holds old Z via X
                                 
00014b e2a0                      ldi XL, LOW(lcd_buffer_addr+32) ;point x to the bottom line of the LCD buffer address in data memory
00014c e0b1                      ldi XH, HIGH(lcd_buffer_addr+32)
                                 
                                 print_yz_bottom_loop:
00014d 9104                      lpm mpr, Z ;load value stored at the address to the beginning of the string (stored in X) to mpr, then inc X to point to next char. ie. first character of string is loaded into mpr
00014e 930c                      st X, mpr ;Store that character to the beginning of the LCD buffer, then increment to next spot in LCD buffer
                                 
00014f 9731                      sbiw ZH:ZL, 1
000150 9711                      sbiw XH:XL, 1
                                 
                                 
000151 17ec                      cp ZL, YL ;compare where Z points (beginning of string) to Y (Current address), we only need Low byte since start and end are definitely not far enough away to cause roll over errors
000152 f7d1                      brne print_yz_bottom_loop ;if not at end keep loading LCD buffer
                                 
000153 9104                      lpm mpr, Z; store last character (dec YL inside loop triggers reset interrupt for some reason)
000154 930c                      st X, mpr
                                 
000155 d076                      rcall	LCDWrLn2 ;once done write to LCD 
                                 
000156 91df                      pop YH
000157 91cf                      pop YL
000158 91ff                      pop ZH
000159 91ef                      pop ZL
00015a 91bf                      pop XH
00015b 91af                      pop XL 
00015c 910f                      pop mpr
00015d 9508                      ret
                                 ;end print_yz_bottom
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Stored Program Data
                                 ;***********************************************************
                                 
                                 ;-----------------------------------------------------------
                                 ; An example of storing a string. Note the labels before and
                                 ; after the .DB directive; these can help to access the data
                                 ;-----------------------------------------------------------
                                 
                                 str_clear:
00015e 2020
00015f 2020
000160 2020
000161 2020                      .db "        "
                                 str_clear_end:
                                 
                                 str_rock:
000162 6f52
000163 6b63                      .db	"Rock"		
                                 str_rock_end:
                                 
                                 str_paper:
000164 6170
000165 6570
000166 2072                      .db "paper "
                                 str_paper_end:
                                 
                                 str_scissors:
000167 6373
000168 7369
000169 6f73
00016a 2072                      .db "scissor "
                                 str_scissors_end:
                                 
                                 str_lose:
00016b 6f59
00016c 2075
00016d 6f4c
00016e 6573                      .db "You Lose"
                                 str_lose_end:
                                 
                                 str_win:
00016f 6f59
000170 2075
000171 6957
000172 216e                      .db "You Win!"
                                 str_win_end:
                                 
                                 str_draw:
000173 6f59
000174 2075
000175 7244
000176 7761
000177 2021                      .db "You Draw! "
                                 str_draw_end:
                                 
                                 str_welcome1:
000178 6577
000179 636c
00017a 6d6f
00017b 2065                      .db "welcome "
                                 str_welcome1_end:
                                 
                                 str_welcome2:
00017c 6c50
00017d 6165
00017e 6573
00017f 5020
000180 6572
000181 7373
000182 5020
000183 3744                      .db "Please Press PD7"
                                 str_welcome2_end:
                                 
                                 str_start1:
000184 6552
000185 6461
000186 2c79
000187 5720
000188 6961
000189 6974
00018a 676e                      .db "Ready, Waiting"
                                 str_start1_end:
                                 
                                 str_start2:
00018b 6f66
00018c 2072
00018d 6874
00018e 2065
00018f 706f
000190 6f70
000191 656e
000192 746e                      .db "for the opponent"
                                 str_start2_end:
                                 
                                 str_game:
000193 6147
000194 656d
000195 5320
000196 6174
000197 7472                      .db "Game Start"
                                 str_game_end:
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Additional Program Includes
                                 ;***********************************************************
                                 .include "LCDDriver.asm"		; Include the LCD Driver
                                 
                                 ;*	Oregon State University
                                 ;*	ST7565R LCD Driver
                                 ;*	This code configures the graphical LCD and emulates
                                 ;*	the behavior of a 2x16 character display.
                                 ;*
                                 ;*	The LCD has room for 32 characters in total
                                 ;*	(16 on the top and 16 on the bottom).
                                 ;*	The upper 16 characters should be located in SRAM starting at 0x0100.
                                 ;*	The lower 16 characters should be located in SRAM starting at 0x0110.
                                 ;*
                                 ;*	NOTE: Register r16 MUST be named 'mpr' in the Main Code
                                 ;*	Something like this:
                                 ;*	.def	mpr = r16
                                 ;*
                                 ;*	WARNING: Register r20-r22 are reserved and cannot be
                                 ;*		renamed outside of the LCD Driver functions. Doing
                                 ;*		so will damage the functionality of the LCD Driver
                                 ;*
                                 ;*	Acknowledgements: the Bin2ASCII and div10 procedures were written by
                                 ;*	David Zier for a previous board. The code has been retained intact.
                                 ;*
                                 ;*********************************************************************
                                 ;*	Rev	Date		Name			Description
                                 ;*--------------------------------------------------------------------
                                 ;*	-	8/18/22	Justin Goins	Version 1.0
                                 ;*
                                 ;*
                                 ;*********************************************************************
                                 
                                 .include "m32U4def.inc"				; Include definition file
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32U4.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32U4def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32U4
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32U4
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32U4DEF_INC_
                                 #endif  /* _M32U4DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; Register definitions
                                 .def	count = r20			; Character Counter
                                 .def	q = r21			; Quotient for div10
                                 .def	r = r22			; Remander for div10
                                 
                                 ; The following constants are not intended to be modified.
                                 .equ 	lcd_buffer_addr = 0x0100 ; define the SRAM base address of the LCD buffer
                                 
                                 ; This information is gathered from the ST7565R datasheet.
                                 ; define some command patterns
                                 .equ	lcd_c_disp_en = 0b10101110 ; lsb indicates whether the LCD is on (1) or off (0)
                                 .equ	lcd_c_disp_set_start_ln = 0b01000000 ; lower 6 bits indicate the line index (0 - 63)
                                 .equ	lcd_c_disp_set_page_addr = 0b10110000 ; lower 4 bits indicate the page address (page 3 is at top and page 0 is at bottom)
                                 ; together, these commands allow you to specify a column index from (0 - 131):
                                 .equ	lcd_c_disp_set_col_addr_h = 0b00010000 ; lower 4 bits indicate the 4 high bits of the column address
                                 .equ	lcd_c_disp_set_col_addr_l = 0b00000000 ; lower 4 bits indicate the 4 low bits of the column address
                                 .equ	lcd_c_disp_set_invert = 0b10100110 ; lsb indicates whether the LCD is normal (0) or inverted (1)
                                 .equ	lcd_c_disp_fill = 0b10100100 ; lsb indicates whether the LCD is normal (0) or filled with dots (1)
                                 .equ	lcd_c_disp_reset = 0b11100010 ; resets the line/page addresses and other stuff, does not affect data RAM
                                 .equ	lcd_c_disp_set_bias = 0xA2 ; 1/6 bias (in 1/33 duty mode)
                                 .equ	lcd_c_disp_set_scandir = 0b11000000 ; select normal scan direction (most significant bit is placed at top of LCD)
                                 .equ	lcd_c_disp_set_contrast_1 = 0b10000001 ; first we send this command then we pass the value
                                 .equ	lcd_c_disp_set_contrast_2 = 15 ; can select a contrast value between 1 and 63
                                 .equ	lcd_c_disp_set_res_ratio = 0x22 ; see the datasheet
                                 .equ	lcd_c_disp_vreg_on = 0x2F ; enable voltage booster, voltage regulator, and voltage follower
                                 
                                 ; use this command to write into the LCD RAM:
                                 .equ	lcd_c_disp_write = 0b00000000 ; these 8 bits are the data to be placed in the target. 
                                 ; note that the column address is automatically incremented by 1 after each write to the LCD data
                                 
                                 ; everything in this driver file needs to go into the code segment
                                 .cseg
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDInit
                                 ;* Desc:	This function initializes the LCD control pins and
                                 ;*		sets reasonable values for the configuration registers.
                                 ;*****************************************************************
                                 LCDInit:
000198 930f                      	push	mpr
                                 
                                 	; set MOSI, SCL, and SS as outputs
000199 9a22                      	sbi	DDRB, DDB2	; Port B 2
00019a 9a21                      	sbi	DDRB, DDB1	; Port B 1
00019b 9a20                      	sbi	DDRB, DDB0	; Port B 0
                                 	; ensure that SS is deactivated (active low)
00019c 9a28                      	sbi	PORTB, 0
                                 	; set lcd_A0 as output
00019d 9a81                      	sbi	DDRF, DDF1	; Port F 1
                                 	; enable LCD backlight control
00019e 9a3f                      	sbi	DDRC, DDC7	; Port C 7
                                 	; set lcd_RST_N as output
00019f 9a80                      	sbi	DDRF, DDF0	; Port F 0
                                 	; we pull lcd_RST_N low for 1 millisecond
0001a0 9888                      	cbi	PORTF, 0
0001a1 940e 0283                 	call	LCDDelay
0001a3 9a88                      	sbi	PORTF, 0
                                 	; Enable SPI mode 3, master configuration, set clock rate fck/2 using SPI2X
0001a4 e50c                      	ldi	mpr, (1<<SPE)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)
0001a5 bd0c                      	out	SPCR, mpr
0001a6 e001                      	ldi	mpr, (1<<SPI2X)
0001a7 bd0d                      	out	SPSR, mpr
                                 	; Note: after transmitting a byte, the SPI interrupt flag will
                                 	; be automatically cleared next time we: 1) read SPSR and ALSO 2) access SPDR
                                 
0001a8 9828                      	cbi	PORTB, 0	; activate slave select
                                 	; send a string of initialization commands
0001a9 ea02                      	ldi	mpr, lcd_c_disp_set_bias
0001aa d0d2                      	rcall	LCD_Internal_WriteCMD
0001ab ec00                      	ldi	mpr, lcd_c_disp_set_scandir
0001ac d0d0                      	rcall	LCD_Internal_WriteCMD
0001ad e801                      	ldi	mpr, lcd_c_disp_set_contrast_1
0001ae d0ce                      	rcall	LCD_Internal_WriteCMD
0001af e00f                      	ldi	mpr, lcd_c_disp_set_contrast_2
0001b0 d0cc                      	rcall	LCD_Internal_WriteCMD
0001b1 e202                      	ldi	mpr, lcd_c_disp_set_res_ratio
0001b2 d0ca                      	rcall	LCD_Internal_WriteCMD
0001b3 e20f                      	ldi	mpr, lcd_c_disp_vreg_on
0001b4 d0c8                      	rcall	LCD_Internal_WriteCMD
0001b5 ea0f                      	ldi	mpr, (lcd_c_disp_en | 1 << 0)
0001b6 d0c6                      	rcall	LCD_Internal_WriteCMD
0001b7 9a28                      	sbi	PORTB, 0	; deactivate slave select
                                 
0001b8 910f                      	pop	mpr
0001b9 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDBacklightOn
                                 ;* Desc:	Enables the backlight
                                 ;*****************************************************************
                                 LCDBacklightOn:
0001ba 9a47                      	sbi	PORTC, 7
0001bb 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDBacklightOff
                                 ;* Desc:	Disables the backlight
                                 ;*****************************************************************
                                 LCDBacklightOff:
0001bc 9847                      	cbi	PORTC, 7
0001bd 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDWrite
                                 ;* Desc:	This function writes 32 characters to the LCD screen...
                                 ;*		16 chars on the top line and 16 chars on the bottom line.
                                 ;*****************************************************************
                                 LCDWrite:
                                 	
0001be d002                      	rcall	LCDWrLn1
0001bf d00c                      	rcall	LCDWrLn2
0001c0 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDWrLn1
                                 ;* Desc:	This function writes 16 characters to the top line.
                                 ;*****************************************************************
                                 LCDWrLn1:
0001c1 93bf                      	push	XH
0001c2 93af                      	push	XL
0001c3 931f                      	push 	r17
                                 	; r17 specifies the destination bank in LCD RAM
0001c4 e013                      	ldi	r17, 3
                                 	; point X at the ASCII data
0001c5 e0b1                      	ldi	XH, HIGH(lcd_buffer_addr)
0001c6 e0a0                      	ldi	XL, LOW(lcd_buffer_addr)
0001c7 d05c                      	rcall	LCD_Internal_WriteLn
0001c8 911f                      	pop	r17
0001c9 91af                      	pop	XL
0001ca 91bf                      	pop	XH
0001cb 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDWrLn2
                                 ;* Desc:	This function writes 16 characters to the bottom line.
                                 ;*****************************************************************
                                 LCDWrLn2:
0001cc 93bf                      	push	XH
0001cd 93af                      	push	XL
0001ce 931f                      	push	 r17
                                 	; r17 specifies the destination bank in LCD RAM
0001cf e011                      	ldi	r17, 1
                                 	; point X at the ASCII data
0001d0 e0b1                      	ldi	XH, HIGH(lcd_buffer_addr+16)
0001d1 e1a0                      	ldi	XL, LOW(lcd_buffer_addr+16)
0001d2 d051                      	rcall	LCD_Internal_WriteLn
0001d3 911f                      	pop	r17
0001d4 91af                      	pop	XL
0001d5 91bf                      	pop	XH
0001d6 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDClr
                                 ;* Desc:	This function clears the entire LCD screen.
                                 ;*****************************************************************
                                 LCDClr:
0001d7 d022                      	rcall	LCDClrLn1
0001d8 d027                      	rcall	LCDClrLn2
                                 
0001d9 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	CLRDM1
                                 ;* Desc:	This function clears Data Memory by writing 16 
                                 ;*		consecutive ASCII spaces $20 to the memory at $0100.
                                 ;*****************************************************************
                                 CLRDM1:
                                     ; Set X register points to $0100
0001da 93bf                      	   push	   XH
0001db 93af                      	   PUSH	   XL
0001dc 930f                                 push    r16
0001dd 931f                                 push    r17
                                 
0001de e0b1                                 ldi     XH, HIGH(lcd_buffer_addr)
0001df e0a0                                 ldi     XL, LOW(lcd_buffer_addr)
0001e0 e110                                 ldi     r17, 16
0001e1 e200                                 ldi     r16, ' '
                                    CLRloop1:
0001e2 930d                                 st      X+, r16         ; load data to DM
0001e3 951a                                 dec     r17
0001e4 f7e9                                 brne    CLRloop1
                                 
0001e5 911f                      	   pop	   r17
0001e6 910f                      	   pop	   r16
0001e7 91af                      	   pop	   XL
0001e8 91bf                      	   pop	   XH
                                 
0001e9 9508                                 ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	CLRDM2
                                 ;* Desc:	This function clears Data Memory by writing 16 
                                 ;*		consecutive ASCII spaces $20 to the memory at $0110.
                                 ;*****************************************************************
                                 CLRDM2:
                                     ; Set X register points to $0110
0001ea 93bf                      	   push	   XH
0001eb 93af                      	   PUSH	   XL
0001ec 930f                                 push    r16
0001ed 931f                                 push    r17
                                 
0001ee e0b1                                 ldi     XH, HIGH(lcd_buffer_addr+16)
0001ef e1a0                                 ldi     XL, LOW(lcd_buffer_addr+16)
0001f0 e110                                 ldi     r17, 16
0001f1 e200                                 ldi     r16, ' '
                                    CLRloop2:
0001f2 930d                                 st      X+, r16         ; load data to DM
0001f3 951a                                 dec     r17
0001f4 f7e9                                 brne    CLRloop2
                                 
0001f5 911f                      	   pop	   r17
0001f6 910f                      	   pop	   r16
0001f7 91af                      	   pop	   XL
0001f8 91bf                      	   pop	   XH
                                 
0001f9 9508                                 ret
                                 ;*****************************************************************
                                 ;* Func:	LCDClrLn1
                                 ;* Desc:	This function clears the top line of the LCD screen.
                                 ;*****************************************************************
                                 LCDClrLn1:
0001fa 931f                      	push	 r17
                                 	; r17 specifies the target bank in LCD RAM
0001fb e013                      	ldi	r17, 3
0001fc d060                      	rcall	LCD_Internal_ClearLn
0001fd dfdc                      	rcall	CLRDM1
0001fe 911f                      	pop	r17
0001ff 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDClrLn2
                                 ;* Desc:	This function clears the bottom line of the LCD screen.
                                 ;*****************************************************************
                                 LCDClrLn2:
000200 931f                      	push	 r17
                                 	; r17 specifies the target bank in LCD RAM
000201 e011                      	ldi	r17, 1
000202 d05a                      	rcall	LCD_Internal_ClearLn
000203 dfe6                      	rcall	CLRDM2
000204 911f                      	pop	r17
000205 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	Bin2ASCII
                                 ;* Desc:	Converts a binary number into an ASCII 
                                 ;*			text string equivalent. 
                                 ;*			- The binary number needs to be in the mpr
                                 ;*			- The Start Address of where the text will
                                 ;*			 	be placed needs to be in the X Register
                                 ;*			- The count of the characters created are 
                                 ;*				added to the count register
                                 ;*****************************************************************
                                 Bin2ASCII:
000206 930f                      	push	 mpr			; save mpr
000207 936f                      	push	 r			; save r
000208 935f                      	push	 q			; save q
000209 93bf                      	push	 XH			; save X-pointer
00020a 93af                      	push	 XL			;
                                 
                                 	; Determine the range of mpr
00020b 3604                      	cpi	mpr, 100		; is mpr >= 100
00020c f018                      	brlo	 B2A_1			; goto next check
00020d e043                      	ldi	count, 3		; Three chars are written
00020e 9613                      	adiw	 XL, 3			; Increment X 3 address spaces
00020f c007                      	rjmp	 B2A_3			; Continue with program
                                 B2A_1:
000210 300a                      	cpi	mpr, 10		; is mpr >= 10
000211 f018                      	brlo	 B2A_2			; Continue with program
000212 e042                      	ldi	count, 2		; Two chars are written
000213 9612                      	adiw	 XL, 2			; Increment X 2 address spaces
000214 c002                      	rjmp	 B2A_3			; Continue with program
                                 B2A_2:
000215 9611                      	adiw	 XL, 1			; Increment X 1 address space
000216 e041                      	ldi	count, 1		; One char is written
                                 
                                 B2A_3:
                                 	; Do-While statement that converts Binary to ASCII
000217 d076                      	rcall	div10			; Call the div10 function
000218 e300                      	ldi	mpr, '0'		; Set the base ASCII integer value
000219 0f06                      	add	mpr, r		; Create the ASCII integer value
00021a 930e                      	st	-X, mpr		; Load ASCII value to memory
00021b 2f05                      	mov	mpr, q		; Set mpr to quotient value
00021c 3000                      	cpi	mpr, 0		; does mpr == 0
00021d f7c9                      	brne 	B2A_3			; do while (mpr != 0)
                                 
00021e 91af                      	pop	XL			; restore X-pointer
00021f 91bf                      	pop	XH			;
000220 915f                      	pop	q			; restore q
000221 916f                      	pop	r			; restore r
000222 910f                      	pop	mpr			; restore mpr
000223 9508                      	ret				; return from function
                                 
                                 ;*****************************************************************
                                 ;*	The functions below here are intended for internal use only.
                                 ;*****************************************************************
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCD_Internal_WriteLn
                                 ;* Desc:	Sends 16 characters of information to the LCD panel
                                 ;*		This is slightly more complicated than it sounds because the
                                 ;*		characters straddle two banks of the LCD memory.
                                 ;*		X is pointing at the first ASCII character to be displayed.
                                 ;*		r17 holds the index of the destination bank in LCD RAM.
                                 ;*		
                                 ;*****************************************************************
                                 LCD_Internal_WriteLn:
000224 920f                      	push	 r0
000225 921f                      	push	 r1
000226 930f                      	push	 mpr
000227 932f                      	push	 r18
000228 933f                      	push	 r19
000229 938f                      	push	 r24
00022a 939f                      	push	 r25
00022b 93ef                      	push	 ZL
00022c 93ff                      	push	 ZH
                                 
                                 	; r25:24 holds a pointer to the base address of the bitmap array
00022d e095                      	ldi	r25, HIGH(FontBitmap << 1);
00022e e688                      	ldi	r24, LOW(FontBitmap << 1);
                                 
00022f 9828                      	cbi	PORTB, 0	; activate slave select
                                 
                                 	; use a counter to track if we are on the top chunk or bottom chunk of each char
000230 e022                      	ldi	r18, 2
                                 
                                 LCD_WL_display_bank:
                                 	; set the column to 0
000231 e100                      	ldi	mpr, lcd_c_disp_set_col_addr_h
000232 d04a                      	rcall	LCD_Internal_WriteCMD
000233 e000                      	ldi	mpr, lcd_c_disp_set_col_addr_l
000234 d048                      	rcall	LCD_Internal_WriteCMD
                                 	; we need to select the appropriate page
000235 eb00                      	ldi	mpr, lcd_c_disp_set_page_addr
000236 2b01                      	or	mpr, r17	; set the lower 4 bits
000237 d045                      	rcall	LCD_Internal_WriteCMD
                                 
000238 e130                      	ldi	r19, 16	; there are 16 characters per line
                                 
                                 LCD_WL_next_char:
                                 	; get ascii code point & determine location of corresponding character bitmap
000239 900d                      	ld	r0, X+	; this should be a value from 0 to 255
00023a e100                      	ldi	mpr, 16	; there are 16 bytes per character
00023b 9e00                      	mul	r0, mpr	; determine the byte offset for the desired char
00023c 01fc                      	movw	 ZH:ZL, r25:r24	; copy the base address to Z
00023d 0de0                      	add	ZL, r0	; finally, compute a pointer to the char bitmap
00023e 1df1                      	adc	ZH, r1
                                 
00023f e008                      	ldi	mpr, 8	; there are 8 columns for each character
                                 
                                 	; this is where we display the chunk of character (either a top chunk or bottom chunk)
000240 9004                      	lpm	r0, Z
                                 LCD_WL_next_col:
000241 bc0e                      	out	SPDR, r0
000242 9a89                      	sbi	PORTF, 1	; set lcd_A0 to specify data mode
000243 9632                      	adiw	 ZH:ZL, 2	; point Z at the next column for this bank
000244 9004                      	lpm	r0, Z		; this is a sneaky way to save a few clock cycles (since we are waiting for the SPI communication)
                                 LCD_WL_wait_spi:
000245 b41d                      	in	r1, SPSR
000246 fe17                      	sbrs	 r1, SPIF	; wait for SPI to finish
000247 cffd                      	rjmp	 LCD_WL_wait_spi
                                 
                                 	; keep going until we have displayed all the columns for this character
000248 950a                      	dec	mpr
000249 f7b9                      	brne	 LCD_WL_next_col
                                 
                                 	; move to the next character
00024a 953a                      	dec	r19
00024b f769                      	brne	 LCD_WL_next_char
                                 
                                 	; if we are at the end of the line, configure the bank and starting array offset for the bottom half of each char
00024c 952a                      	dec	r18		; did we display both banks yet?
00024d f021                      	breq	 LCD_WL_all_done
                                 	; if not, then prepare to display the bottom chunk of each character
00024e 951a                      	dec	r17		; decrement the bank number
00024f 9750                      	sbiw	 XH:XL, 16	; X needs to point back at the beginning character of the line
000250 9601                      	adiw	 r25:r24, 1	; increment the base address pointer (now it will point to the second chunk of each char)
000251 cfdf                      	rjmp	 LCD_WL_display_bank
                                 
                                 LCD_WL_all_done:
000252 9a28                      	sbi	PORTB, 0	; deactivate slave select
                                 
000253 91ff                      	pop	ZH
000254 91ef                      	pop	ZL
000255 919f                      	pop	r25
000256 918f                      	pop	r24
000257 913f                      	pop	r19
000258 912f                      	pop	r18
000259 910f                      	pop	mpr
00025a 901f                      	pop	r1
00025b 900f                      	pop	r0
00025c 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCD_Internal_ClearLn
                                 ;* Desc:	This function clears two of the LCD memory banks.
                                 ;*		r17 specifies the starting bank to wipe.
                                 ;*****************************************************************
                                 LCD_Internal_ClearLn:
00025d 930f                      	push 	mpr
00025e 921f                      	push 	r1
00025f 932f                      	push	 r18
000260 933f                      	push	 r19
                                 
000261 9828                      	cbi	PORTB, 0	; activate slave select
000262 e032                      	ldi	r19, 2	; we are going to clear two banks
                                 
                                 LCD_CLRLN_clear_bank:
                                 	; set the column to 0
000263 e100                      	ldi	mpr, lcd_c_disp_set_col_addr_h
000264 d018                      	rcall	LCD_Internal_WriteCMD
000265 e000                      	ldi	mpr, lcd_c_disp_set_col_addr_l
000266 d016                      	rcall	LCD_Internal_WriteCMD
                                 	; we need to select the appropriate page
000267 eb00                      	ldi	mpr, lcd_c_disp_set_page_addr
000268 2b01                      	or	mpr, r17	; configure the lower 4 bits
000269 d013                      	rcall	LCD_Internal_WriteCMD
                                 
00026a e820                      	ldi	r18, 128	; there are 128 columns on the LCD
00026b 2700                      	clr	mpr		; we will fill each column with empty dots (i.e. blank space)
00026c 9a89                      	sbi	PORTF, 1	; set lcd_A0 to specify data mode
                                 
                                 LCD_CLRLN_write_col:
00026d bd0e                      	out	SPDR, mpr	; send an empty column to the LCD via SPI
                                 LCD_CLRLN_wait_spi:
00026e b41d                      	in	r1, SPSR
00026f fe17                      	sbrs	 r1, SPIF	; wait for SPI to finish
000270 cffd                      	rjmp 	LCD_CLRLN_wait_spi
                                 
000271 952a                      	dec	r18
000272 f7d1                      	brne	LCD_CLRLN_write_col	; cycle through all 128 columns
                                 
                                 	; clear the remaining bank if we haven't done so already
000273 953a                      	dec	r19
000274 f011                      	breq	LCD_CLRLN_all_done
000275 951a                      	dec	r17		; decrement the bank index
000276 cfec                      	rjmp	LCD_CLRLN_clear_bank
                                 
                                 LCD_CLRLN_all_done:
000277 9a28                      	sbi	PORTB, 0	; deactivate slave select	
                                 	
                                 	; pop registers...
000278 913f                      	pop	r19
000279 912f                      	pop	r18
00027a 901f                      	pop	r1
00027b 910f                      	pop	mpr
00027c 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCD_Internal_WriteCMD
                                 ;* Desc:	Sends the byte in mpr
                                 ;*		If you use this function directly,
                                 ;*		YOU ARE RESPONSIBLE for handling the slave select line!
                                 ;*****************************************************************
                                 LCD_Internal_WriteCMD:
00027d bd0e                      	out	SPDR, mpr	; initiate transmission
00027e 9889                      	cbi	PORTF, 1	; clear lcd_A0 to put the lcd into command mode
                                 				; (this just has to be done before the 8th bit
                                 				; is transmitted via SPI)
                                 LCD_IWC_L1:
00027f b50d                      	in	mpr, SPSR
000280 ff07                      	sbrs	 mpr, SPIF	; wait for SPI to finish
000281 cffd                      	rjmp LCD_IWC_L1
000282 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDDelay
                                 ;* Desc:	A wait loop that will consume roughly 1ms
                                 ;*		Note that a CALL takes 4 cycles on top of this delay.
                                 ;*****************************************************************
                                 LCDDelay:
000283 930f                      	push 	mpr		; 2 cycles
000284 931f                      	push	 r17		; 2 cycles
000285 e01b                      	ldi	r17, 11	; 1 cycle
                                 LCDDelay_L1:
000286 ef02                      	ldi	mpr, 242	; 1 cycle
                                 LCDDelay_L2:
000287 950a                      	dec	mpr		; 1 cycle
000288 f7f1                      	brne	LCDDelay_L2	; 2 cycles on branch, 1 if no branch
000289 951a                      	dec	r17		; 1 cycle
00028a f7d9                      	brne	LCDDelay_L1	; 2 cycles on branch, 1 if no branch
00028b 911f                      	pop	r17		; 2 cycles
00028c 910f                      	pop	mpr		; 2 cycles
00028d 9508                      	ret			; 4 cycles
                                 
                                 ;*****************************************************************
                                 ;* Func:	div10
                                 ;* Desc:	Divides the value in the mpr by 10 and 
                                 ;*			puts the remainder in the 'r' register
                                 ;*			and the quotient in the 'q' register.
                                 ;*	DO NOT modify this function, trust me, it does
                                 ;*	divide by 10 :)  ~DZ		
                                 ;*****************************************************************
                                 div10:
00028e 920f                      	push	r0		; Save register
                                 
                                 	; q = mpr / 10 = mpr * 0.000110011001101b
00028f 2f50                      	mov	q, mpr	; q = mpr * 1.0b
000290 9556                      	lsr	q		; q >> 2
000291 9556                      	lsr	q		; q = mpr * 0.01b
000292 0f50                      	add	q, mpr	; q = (q + mpr) >> 1
000293 9556                      	lsr	q		; q = mpr * 0.101b
000294 0f50                      	add	q, mpr	; q = (q + mpr) >> 3
000295 9556                      	lsr	q
000296 9556                      	lsr	q
000297 9556                      	lsr	q		; q = mpr * 0.001101b
000298 0f50                      	add	q, mpr	; q = (q + mpr) >> 1
000299 9556                      	lsr	q		; q = mpr * 0.1001101b
00029a 0f50                      	add	q, mpr	; q = (q + mpr) >> 3
00029b 9556                      	lsr	q				
00029c 9556                      	lsr	q
00029d 9556                      	lsr	q		; q = mpr * 0.0011001101b
00029e 0f50                      	add	q, mpr	; q = (q + mpr) >> 1
00029f 9556                      	lsr	q		; q = mpr * 0.10011001101b
0002a0 0f50                      	add	q, mpr	; q = (q + mpr) >> 4
0002a1 9556                      	lsr	q
0002a2 9556                      	lsr	q
0002a3 9556                      	lsr	q
0002a4 9556                      	lsr	q		; q = mpr * 0.000110011001101b
                                 
                                 	; compute the remainder as r = i - 10 * q
                                 	; calculate r = q * 10 = q * 1010b
0002a5 2f65                      	mov	r, q		; r = q * 1
0002a6 0f66                      	lsl	r		; r << 2
0002a7 0f66                      	lsl	r		; r = q * 100b
0002a8 0f65                      	add	r, q		; r = (r + q) << 1
0002a9 0f66                      	lsl	r		; r = q * 1010b
0002aa 2e06                      	mov	r0, r		; r0 = 10 * q
0002ab 2f60                      	mov	r, mpr	; r = mpr
0002ac 1960                      	sub	r, r0		; r = mpr - 10 * q
                                 
                                 	; Fix any errors that occur
                                 div10_1:
0002ad 306a                      	cpi	r, 10		; Compare with 10
0002ae f018                      	brlo	 div10_2	; do nothing if r < 10
0002af 9553                      	inc	q		; fix quotient
0002b0 506a                      	subi	r, 10		; fix remainder
0002b1 cffb                      	rjmp	 div10_1	; Continue until error is corrected
                                 
                                 div10_2:
0002b2 900f                      	pop	r0		; Restore registers
0002b3 9508                      	ret			; Return from function
                                 
                                 ;*********************************************************************
                                 ;*	Bitmap Font Information
                                 ;*	Adapted into assembly code by Justin Goins.
                                 ;*	You can edit characters or add symbols if you choose (by modifying the data below)
                                 ;*	Each character is represented as a 8 x 16 pattern of dots (8 dots wide and 16 dots high).
                                 ;*	This implies that 16 bytes are allocated to represent each character.
                                 ;*
                                 ;*	The character information is arranged so that each line below equates to a single character.
                                 ;*	The first line is ASCII character 0, the next line is ASCII character 1,
                                 ;*	the next line is ASCII character 2, and so on.
                                 ;*	You can assign characters to any index within the extended ASCII range (0 to 255).
                                 ;*	With a bit of experimentation it's possible to define and display emojis (or any other graphical output).
                                 ;*	Be creative and have fun!
                                 ;*
                                 ;*	From original license file:
                                 ;*	Copyright 2011 Suraj N. Kurapati <https://github.com/sunaku/tamzen-font>
                                 ;*	Tamzen font is free.  You are hereby granted permission to use, copy, modify, and distribute it as you see fit.
                                 ;*	Tamzen font is provided "as is" without any express or implied warranty.
                                 ;*********************************************************************
                                 FontBitmap:
0002b4 0000
0002b5 f00f
0002b6 1008
0002b7 1008
0002b8 1008
0002b9 1008
0002ba f00f
0002bb 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x0F, 0xF0, 0x00, 0x00	; U+0000
0002bc fe03
0002bd fa7f
0002be f683
0002bf ea83
0002c0 d683
0002c1 aa83
0002c2 567f
0002c3 fe03                      .DB	0x03, 0xFE, 0x7F, 0xFA, 0x83, 0xF6, 0x83, 0xEA, 0x83, 0xD6, 0x83, 0xAA, 0x7F, 0x56, 0x03, 0xFE	; U+E0A2
0002c4 5455
0002c5 aaaa
0002c6 5455
0002c7 aaaa
0002c8 5455
0002c9 aaaa
0002ca 5455
0002cb aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; U+2592
0002cc 5455
0002cd aaaa
0002ce 5455
0002cf aaaa
0002d0 5455
0002d1 aaaa
0002d2 5455
0002d3 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0002d4 5455
0002d5 aaaa
0002d6 5455
0002d7 aaaa
0002d8 5455
0002d9 aaaa
0002da 5455
0002db aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0002dc 5455
0002dd aaaa
0002de 5455
0002df aaaa
0002e0 5455
0002e1 aaaa
0002e2 5455
0002e3 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0002e4 5455
0002e5 aaaa
0002e6 5455
0002e7 aaaa
0002e8 5455
0002e9 aaaa
0002ea 5455
0002eb aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0002ec 0000
0002ed 0007
0002ee 8008
0002ef 8008
0002f0 8008
0002f1 0007
0002f2 0000
0002f3 0000                      .DB	0x00, 0x00, 0x07, 0x00, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00B0
0002f4 5455
0002f5 aaaa
0002f6 5455
0002f7 aaaa
0002f8 5455
0002f9 aaaa
0002fa 5455
0002fb aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0002fc 5455
0002fd aaaa
0002fe 5455
0002ff aaaa
000300 5455
000301 aaaa
000302 5455
000303 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000304 5455
000305 aaaa
000306 5455
000307 aaaa
000308 5455
000309 aaaa
00030a 5455
00030b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00030c 8000
00030d 8000
00030e 8000
00030f 8000
000310 80ff
000311 0000
000312 0000
000313 0000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2518
000314 8000
000315 8000
000316 8000
000317 8000
000318 fe00
000319 0000
00031a 0000
00031b 0000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2510
00031c 0000
00031d 0000
00031e 0000
00031f 0000
000320 fe00
000321 8000
000322 8000
000323 8000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+250C
000324 0000
000325 0000
000326 0000
000327 0000
000328 80ff
000329 8000
00032a 8000
00032b 8000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+2514
00032c 8000
00032d 8000
00032e 8000
00032f 8000
000330 feff
000331 8000
000332 8000
000333 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+253C
000334 5455
000335 aaaa
000336 5455
000337 aaaa
000338 5455
000339 aaaa
00033a 5455
00033b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00033c 5455
00033d aaaa
00033e 5455
00033f aaaa
000340 5455
000341 aaaa
000342 5455
000343 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000344 8000
000345 8000
000346 8000
000347 8000
000348 8000
000349 8000
00034a 8000
00034b 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+2500
00034c 5455
00034d aaaa
00034e 5455
00034f aaaa
000350 5455
000351 aaaa
000352 5455
000353 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000354 5455
000355 aaaa
000356 5455
000357 aaaa
000358 5455
000359 aaaa
00035a 5455
00035b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00035c 0000
00035d 0000
00035e 0000
00035f 0000
000360 feff
000361 8000
000362 8000
000363 8000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+251C
000364 8000
000365 8000
000366 8000
000367 8000
000368 feff
000369 0000
00036a 0000
00036b 0000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2524
00036c 8000
00036d 8000
00036e 8000
00036f 8000
000370 80ff
000371 8000
000372 8000
000373 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+2534
000374 8000
000375 8000
000376 8000
000377 8000
000378 fe00
000379 8000
00037a 8000
00037b 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+252C
00037c 0000
00037d 0000
00037e 0000
00037f 0000
000380 feff
000381 0000
000382 0000
000383 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2502
000384 5455
000385 aaaa
000386 5455
000387 aaaa
000388 5455
000389 aaaa
00038a 5455
00038b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00038c 5455
00038d aaaa
00038e 5455
00038f aaaa
000390 5455
000391 aaaa
000392 5455
000393 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000394 5455
000395 aaaa
000396 5455
000397 aaaa
000398 5455
000399 aaaa
00039a 5455
00039b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00039c 5455
00039d aaaa
00039e 5455
00039f aaaa
0003a0 5455
0003a1 aaaa
0003a2 5455
0003a3 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0003a4 0000
0003a5 1001
0003a6 2001
0003a7 e007
0003a8 2009
0003a9 1009
0003aa 1008
0003ab 2004                      .DB	0x00, 0x00, 0x01, 0x10, 0x01, 0x20, 0x07, 0xE0, 0x09, 0x20, 0x09, 0x10, 0x08, 0x10, 0x04, 0x20	; U+00A3
0003ac 5455
0003ad aaaa
0003ae 5455
0003af aaaa
0003b0 5455
0003b1 aaaa
0003b2 5455
0003b3 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0003b4 0000
0003b5 0000
0003b6 0000
0003b7 0000
0003b8 0000
0003b9 0000
0003ba 0000
0003bb 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0020
0003bc 0000
0003bd 0000
0003be 0000
0003bf 301f
0003c0 0000
0003c1 0000
0003c2 0000
0003c3 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0021
0003c4 0000
0003c5 0000
0003c6 001e
0003c7 0000
0003c8 0000
0003c9 001e
0003ca 0000
0003cb 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0022
0003cc 0000
0003cd 4002
0003ce f00f
0003cf 4002
0003d0 4002
0003d1 f00f
0003d2 4002
0003d3 0000                      .DB	0x00, 0x00, 0x02, 0x40, 0x0F, 0xF0, 0x02, 0x40, 0x02, 0x40, 0x0F, 0xF0, 0x02, 0x40, 0x00, 0x00	; U+0023
0003d4 0000
0003d5 0000
0003d6 2006
0003d7 2009
0003d8 3839
0003d9 2009
0003da c008
0003db 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x06, 0x20, 0x09, 0x20, 0x39, 0x38, 0x09, 0x20, 0x08, 0xC0, 0x00, 0x00	; U+0024
0003dc 0000
0003dd 200c
0003de 4012
0003df 8012
0003e0 600d
0003e1 9002
0003e2 9004
0003e3 6008                      .DB	0x00, 0x00, 0x0C, 0x20, 0x12, 0x40, 0x12, 0x80, 0x0D, 0x60, 0x02, 0x90, 0x04, 0x90, 0x08, 0x60	; U+0025
0003e4 0000
0003e5 e00c
0003e6 1013
0003e7 1013
0003e8 900c
0003e9 6000
0003ea 6000
0003eb 9001                      .DB	0x00, 0x00, 0x0C, 0xE0, 0x13, 0x10, 0x13, 0x10, 0x0C, 0x90, 0x00, 0x60, 0x00, 0x60, 0x01, 0x90	; U+0026
0003ec 0000
0003ed 0000
0003ee 0000
0003ef 001e
0003f0 0000
0003f1 0000
0003f2 0000
0003f3 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0027
0003f4 0000
0003f5 0000
0003f6 0000
0003f7 e003
0003f8 180c
0003f9 0410
0003fa 0000
0003fb 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x0C, 0x18, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00	; U+0028
0003fc 0000
0003fd 0000
0003fe 0410
0003ff 180c
000400 e003
000401 0000
000402 0000
000403 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0x0C, 0x18, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0029
000404 0000
000405 8000
000406 a002
000407 c001
000408 c001
000409 a002
00040a 8000
00040b 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x02, 0xA0, 0x01, 0xC0, 0x01, 0xC0, 0x02, 0xA0, 0x00, 0x80, 0x00, 0x00	; U+002A
00040c 0000
00040d 8000
00040e 8000
00040f 8000
000410 f007
000411 8000
000412 8000
000413 8000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x07, 0xF0, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+002B
000414 0000
000415 0000
000416 0000
000417 3200
000418 3c00
000419 0000
00041a 0000
00041b 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+002C
00041c 0000
00041d 8000
00041e 8000
00041f 8000
000420 8000
000421 8000
000422 8000
000423 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00	; U+002D
000424 0000
000425 0000
000426 0000
000427 3000
000428 3000
000429 0000
00042a 0000
00042b 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+002E
00042c 0000
00042d 0c00
00042e 3000
00042f c000
000430 0003
000431 000c
000432 0000
000433 0000                      .DB	0x00, 0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x03, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00	; U+002F
000434 0000
000435 e007
000436 5008
000437 9008
000438 1009
000439 100a
00043a e007
00043b 0000                      .DB	0x00, 0x00, 0x07, 0xE0, 0x08, 0x50, 0x08, 0x90, 0x09, 0x10, 0x0A, 0x10, 0x07, 0xE0, 0x00, 0x00	; U+0030
00043c 0000
00043d 0000
00043e 1002
00043f 1004
000440 f00f
000441 1000
000442 1000
000443 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x04, 0x10, 0x0F, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+0031
000444 0000
000445 1004
000446 3008
000447 5008
000448 9008
000449 1009
00044a 1006
00044b 0000                      .DB	0x00, 0x00, 0x04, 0x10, 0x08, 0x30, 0x08, 0x50, 0x08, 0x90, 0x09, 0x10, 0x06, 0x10, 0x00, 0x00	; U+0032
00044c 0000
00044d 2008
00044e 1008
00044f 1009
000450 100b
000451 100d
000452 e008
000453 0000                      .DB	0x00, 0x00, 0x08, 0x20, 0x08, 0x10, 0x09, 0x10, 0x0B, 0x10, 0x0D, 0x10, 0x08, 0xE0, 0x00, 0x00	; U+0033
000454 0000
000455 c000
000456 4001
000457 4002
000458 4004
000459 f00f
00045a 4000
00045b 0000                      .DB	0x00, 0x00, 0x00, 0xC0, 0x01, 0x40, 0x02, 0x40, 0x04, 0x40, 0x0F, 0xF0, 0x00, 0x40, 0x00, 0x00	; U+0034
00045c 0000
00045d 200f
00045e 1009
00045f 1009
000460 1009
000461 1009
000462 e008
000463 0000                      .DB	0x00, 0x00, 0x0F, 0x20, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0xE0, 0x00, 0x00	; U+0035
000464 0000
000465 e003
000466 1005
000467 1009
000468 1009
000469 1001
00046a e000
00046b 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x05, 0x10, 0x09, 0x10, 0x09, 0x10, 0x01, 0x10, 0x00, 0xE0, 0x00, 0x00	; U+0036
00046c 0000
00046d 0008
00046e 0008
00046f 3008
000470 c008
000471 000b
000472 000c
000473 0000                      .DB	0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x30, 0x08, 0xC0, 0x0B, 0x00, 0x0C, 0x00, 0x00, 0x00	; U+0037
000474 0000
000475 e006
000476 1009
000477 1009
000478 1009
000479 1009
00047a e006
00047b 0000                      .DB	0x00, 0x00, 0x06, 0xE0, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x06, 0xE0, 0x00, 0x00	; U+0038
00047c 0000
00047d 0007
00047e 8008
00047f 9008
000480 9008
000481 a008
000482 c007
000483 0000                      .DB	0x00, 0x00, 0x07, 0x00, 0x08, 0x80, 0x08, 0x90, 0x08, 0x90, 0x08, 0xA0, 0x07, 0xC0, 0x00, 0x00	; U+0039
000484 0000
000485 0000
000486 0000
000487 3006
000488 3006
000489 0000
00048a 0000
00048b 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x30, 0x06, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+003A
00048c 0000
00048d 0000
00048e 0000
00048f 3206
000490 3c06
000491 0000
000492 0000
000493 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x06, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+003B
000494 0000
000495 0000
000496 8000
000497 4001
000498 2002
000499 1004
00049a 0000
00049b 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00	; U+003C
00049c 0000
00049d 4002
00049e 4002
00049f 4002
0004a0 4002
0004a1 4002
0004a2 4002
0004a3 0000                      .DB	0x00, 0x00, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x00, 0x00	; U+003D
0004a4 0000
0004a5 0000
0004a6 1004
0004a7 2002
0004a8 4001
0004a9 8000
0004aa 0000
0004ab 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00	; U+003E
0004ac 0000
0004ad 0008
0004ae 0010
0004af 3011
0004b0 0012
0004b1 0014
0004b2 0008
0004b3 0000                      .DB	0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x11, 0x30, 0x12, 0x00, 0x14, 0x00, 0x08, 0x00, 0x00, 0x00	; U+003F
0004b4 0000
0004b5 f007
0004b6 0808
0004b7 c411
0004b8 2412
0004b9 2412
0004ba 440a
0004bb e407                      .DB	0x00, 0x00, 0x07, 0xF0, 0x08, 0x08, 0x11, 0xC4, 0x12, 0x24, 0x12, 0x24, 0x0A, 0x44, 0x07, 0xE4	; U+0040
0004bc 0000
0004bd f003
0004be 8004
0004bf 8008
0004c0 8008
0004c1 8004
0004c2 f003
0004c3 0000                      .DB	0x00, 0x00, 0x03, 0xF0, 0x04, 0x80, 0x08, 0x80, 0x08, 0x80, 0x04, 0x80, 0x03, 0xF0, 0x00, 0x00	; U+0041
0004c4 0000
0004c5 f00f
0004c6 1009
0004c7 1009
0004c8 1009
0004c9 1009
0004ca e006
0004cb 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x06, 0xE0, 0x00, 0x00	; U+0042
0004cc 0000
0004cd c003
0004ce 2004
0004cf 1008
0004d0 1008
0004d1 1008
0004d2 1008
0004d3 0000                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+0043
0004d4 0000
0004d5 f00f
0004d6 1008
0004d7 1008
0004d8 1008
0004d9 2004
0004da c003
0004db 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x04, 0x20, 0x03, 0xC0, 0x00, 0x00	; U+0044
0004dc 0000
0004dd f00f
0004de 1009
0004df 1009
0004e0 1009
0004e1 1009
0004e2 1008
0004e3 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10, 0x00, 0x00	; U+0045
0004e4 0000
0004e5 f00f
0004e6 0009
0004e7 0009
0004e8 0009
0004e9 0009
0004ea 0008
0004eb 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00	; U+0046
0004ec 0000
0004ed c003
0004ee 2004
0004ef 1008
0004f0 1008
0004f1 9008
0004f2 f008
0004f3 0000                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x08, 0x10, 0x08, 0x10, 0x08, 0x90, 0x08, 0xF0, 0x00, 0x00	; U+0047
0004f4 0000
0004f5 f00f
0004f6 0001
0004f7 0001
0004f8 0001
0004f9 0001
0004fa f00f
0004fb 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x0F, 0xF0, 0x00, 0x00	; U+0048
0004fc 0000
0004fd 0000
0004fe 1008
0004ff 1008
000500 f00f
000501 1008
000502 1008
000503 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x08, 0x10, 0x0F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+0049
000504 0000
000505 6000
000506 1000
000507 1000
000508 1000
000509 1000
00050a e00f
00050b 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+004A
00050c 0000
00050d f00f
00050e 8001
00050f 8001
000510 4002
000511 2004
000512 1008
000513 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x01, 0x80, 0x01, 0x80, 0x02, 0x40, 0x04, 0x20, 0x08, 0x10, 0x00, 0x00	; U+004B
000514 0000
000515 f00f
000516 1000
000517 1000
000518 1000
000519 1000
00051a 1000
00051b 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+004C
00051c 0000
00051d f00f
00051e 0004
00051f 0002
000520 8001
000521 0002
000522 0004
000523 f00f                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x04, 0x00, 0x02, 0x00, 0x01, 0x80, 0x02, 0x00, 0x04, 0x00, 0x0F, 0xF0	; U+004D
000524 0000
000525 f00f
000526 0004
000527 0002
000528 0001
000529 8000
00052a f00f
00052b 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x0F, 0xF0, 0x00, 0x00	; U+004E
00052c 0000
00052d e007
00052e 1008
00052f 1008
000530 1008
000531 1008
000532 e007
000533 0000                      .DB	0x00, 0x00, 0x07, 0xE0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x07, 0xE0, 0x00, 0x00	; U+004F
000534 0000
000535 f00f
000536 8008
000537 8008
000538 8008
000539 8008
00053a 0007
00053b 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x07, 0x00, 0x00, 0x00	; U+0050
00053c 0000
00053d e007
00053e 1008
00053f 1008
000540 1008
000541 1808
000542 e407
000543 0000                      .DB	0x00, 0x00, 0x07, 0xE0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x18, 0x07, 0xE4, 0x00, 0x00	; U+0051
000544 0000
000545 f00f
000546 8008
000547 8008
000548 c008
000549 a008
00054a 1007
00054b 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x80, 0x08, 0x80, 0x08, 0xC0, 0x08, 0xA0, 0x07, 0x10, 0x00, 0x00	; U+0052
00054c 0000
00054d 1006
00054e 1009
00054f 1009
000550 9008
000551 9008
000552 6008
000553 0000                      .DB	0x00, 0x00, 0x06, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0x90, 0x08, 0x90, 0x08, 0x60, 0x00, 0x00	; U+0053
000554 0000
000555 0008
000556 0008
000557 0008
000558 f00f
000559 0008
00055a 0008
00055b 0008                      .DB	0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x0F, 0xF0, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00	; U+0054
00055c 0000
00055d e00f
00055e 1000
00055f 1000
000560 1000
000561 1000
000562 e00f
000563 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+0055
000564 0000
000565 000f
000566 c000
000567 3000
000568 3000
000569 c000
00056a 000f
00056b 0000                      .DB	0x00, 0x00, 0x0F, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x30, 0x00, 0xC0, 0x0F, 0x00, 0x00, 0x00	; U+0056
00056c 0000
00056d f00f
00056e 1000
00056f 2000
000570 c000
000571 2000
000572 1000
000573 f00f                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x00, 0x10, 0x00, 0x20, 0x00, 0xC0, 0x00, 0x20, 0x00, 0x10, 0x0F, 0xF0	; U+0057
000574 0000
000575 300c
000576 4002
000577 8001
000578 8001
000579 4002
00057a 300c
00057b 0000                      .DB	0x00, 0x00, 0x0C, 0x30, 0x02, 0x40, 0x01, 0x80, 0x01, 0x80, 0x02, 0x40, 0x0C, 0x30, 0x00, 0x00	; U+0058
00057c 0000
00057d 000c
00057e 0002
00057f 0001
000580 f000
000581 0001
000582 0002
000583 000c                      .DB	0x00, 0x00, 0x0C, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x0C, 0x00	; U+0059
000584 0000
000585 3008
000586 5008
000587 9008
000588 1009
000589 100a
00058a 100c
00058b 1008                      .DB	0x00, 0x00, 0x08, 0x30, 0x08, 0x50, 0x08, 0x90, 0x09, 0x10, 0x0A, 0x10, 0x0C, 0x10, 0x08, 0x10	; U+005A
00058c 0000
00058d 0000
00058e 0000
00058f fc1f
000590 0410
000591 0410
000592 0410
000593 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFC, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x00, 0x00	; U+005B
000594 0000
000595 000c
000596 0003
000597 c000
000598 3000
000599 0c00
00059a 0000
00059b 0000                      .DB	0x00, 0x00, 0x0C, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00	; U+005C
00059c 0000
00059d 0410
00059e 0410
00059f 0410
0005a0 fc1f
0005a1 0000
0005a2 0000
0005a3 0000                      .DB	0x00, 0x00, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+005D
0005a4 0000
0005a5 0002
0005a6 0004
0005a7 0008
0005a8 0004
0005a9 0002
0005aa 0000
0005ab 0000                      .DB	0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00	; U+005E
0005ac 0400
0005ad 0400
0005ae 0400
0005af 0400
0005b0 0400
0005b1 0400
0005b2 0400
0005b3 0400                      .DB	0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04	; U+005F
0005b4 0000
0005b5 0000
0005b6 0000
0005b7 0010
0005b8 0008
0005b9 0004
0005ba 0000
0005bb 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0060
0005bc 0000
0005bd 6000
0005be 9002
0005bf 9002
0005c0 9002
0005c1 9002
0005c2 f001
0005c3 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+0061
0005c4 0000
0005c5 f01f
0005c6 1001
0005c7 1002
0005c8 1002
0005c9 1002
0005ca e001
0005cb 0000                      .DB	0x00, 0x00, 0x1F, 0xF0, 0x01, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+0062
0005cc 0000
0005cd e001
0005ce 1002
0005cf 1002
0005d0 1002
0005d1 1002
0005d2 2001
0005d3 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0x20, 0x00, 0x00	; U+0063
0005d4 0000
0005d5 e001
0005d6 1002
0005d7 1002
0005d8 1002
0005d9 2002
0005da f01f
0005db 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x20, 0x1F, 0xF0, 0x00, 0x00	; U+0064
0005dc 0000
0005dd e001
0005de 9002
0005df 9002
0005e0 9002
0005e1 9002
0005e2 9001
0005e3 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0x90, 0x00, 0x00	; U+0065
0005e4 0000
0005e5 0002
0005e6 0002
0005e7 f00f
0005e8 0012
0005e9 0012
0005ea 0012
0005eb 0000                      .DB	0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0F, 0xF0, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x00, 0x00	; U+0066
0005ec 0000
0005ed e001
0005ee 1202
0005ef 1202
0005f0 1202
0005f1 1202
0005f2 fc03
0005f3 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x03, 0xFC, 0x00, 0x00	; U+0067
0005f4 0000
0005f5 f01f
0005f6 0001
0005f7 0002
0005f8 0002
0005f9 0002
0005fa f001
0005fb 0000                      .DB	0x00, 0x00, 0x1F, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0, 0x00, 0x00	; U+0068
0005fc 0000
0005fd 0000
0005fe 1002
0005ff 1002
000600 f01b
000601 1000
000602 1000
000603 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x02, 0x10, 0x1B, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+0069
000604 0000
000605 0000
000606 0200
000607 0202
000608 0202
000609 fc1b
00060a 0000
00060b 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x1B, 0xFC, 0x00, 0x00, 0x00, 0x00	; U+006A
00060c 0000
00060d f01f
00060e 4000
00060f 8000
000610 4001
000611 2002
000612 1000
000613 0000                      .DB	0x00, 0x00, 0x1F, 0xF0, 0x00, 0x40, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x00, 0x10, 0x00, 0x00	; U+006B
000614 0000
000615 0010
000616 0010
000617 e01f
000618 1000
000619 1000
00061a 1000
00061b 0000                      .DB	0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x1F, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+006c
00061c 0000
00061d f003
00061e 0002
00061f 0002
000620 f001
000621 0002
000622 0002
000623 f001                      .DB	0x00, 0x00, 0x03, 0xF0, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0	; U+006d
000624 0000
000625 f003
000626 0001
000627 0002
000628 0002
000629 0002
00062a f001
00062b 0000                      .DB	0x00, 0x00, 0x03, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0, 0x00, 0x00	; U+006e
00062c 0000
00062d e001
00062e 1002
00062f 1002
000630 1002
000631 1002
000632 e001
000633 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+006F
000634 0000
000635 fe03
000636 1001
000637 1002
000638 1002
000639 1002
00063a e001
00063b 0000                      .DB	0x00, 0x00, 0x03, 0xFE, 0x01, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+0070
00063c 0000
00063d e001
00063e 1002
00063f 1002
000640 1002
000641 2002
000642 fe03
000643 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x20, 0x03, 0xFE, 0x00, 0x00	; U+0071
000644 0000
000645 f003
000646 0001
000647 0002
000648 0002
000649 0002
00064a 0001
00064b 0000                      .DB	0x00, 0x00, 0x03, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00	; U+0072
00064c 0000
00064d 1001
00064e 9002
00064f 9002
000650 5002
000651 5002
000652 2002
000653 0000                      .DB	0x00, 0x00, 0x01, 0x10, 0x02, 0x90, 0x02, 0x90, 0x02, 0x50, 0x02, 0x50, 0x02, 0x20, 0x00, 0x00	; U+0073
000654 0000
000655 0002
000656 0002
000657 e00f
000658 1002
000659 1002
00065a 1002
00065b 0000                      .DB	0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0F, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x00, 0x00	; U+0074
00065c 0000
00065d e003
00065e 1000
00065f 1000
000660 1000
000661 2000
000662 f003
000663 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x20, 0x03, 0xF0, 0x00, 0x00	; U+0075
000664 0000
000665 0003
000666 c000
000667 3000
000668 3000
000669 c000
00066a 0003
00066b 0000                      .DB	0x00, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x30, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00	; U+0076
00066c 0000
00066d e003
00066e 1000
00066f 1000
000670 e001
000671 1000
000672 1000
000673 e003                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x01, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x03, 0xE0	; U+0077
000674 0000
000675 1002
000676 2001
000677 c000
000678 c000
000679 2001
00067a 1002
00067b 0000                      .DB	0x00, 0x00, 0x02, 0x10, 0x01, 0x20, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0x20, 0x02, 0x10, 0x00, 0x00	; U+0078
00067c 0000
00067d e003
00067e 1200
00067f 1200
000680 1200
000681 2200
000682 fc03
000683 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x22, 0x03, 0xFC, 0x00, 0x00	; U+0079
000684 0000
000685 1002
000686 3002
000687 5002
000688 9002
000689 1003
00068a 1002
00068b 0000                      .DB	0x00, 0x00, 0x02, 0x10, 0x02, 0x30, 0x02, 0x50, 0x02, 0x90, 0x03, 0x10, 0x02, 0x10, 0x00, 0x00	; U+007A
00068c 0000
00068d 0000
00068e 8000
00068f 8000
000690 780f
000691 0410
000692 0410
000693 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x0F, 0x78, 0x10, 0x04, 0x10, 0x04, 0x00, 0x00	; U+007B
000694 0000
000695 0000
000696 0000
000697 0000
000698 fc3f
000699 0000
00069a 0000
00069b 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+007C
00069c 0000
00069d 0410
00069e 0410
00069f 780f
0006a0 8000
0006a1 8000
0006a2 0000
0006a3 0000                      .DB	0x00, 0x00, 0x10, 0x04, 0x10, 0x04, 0x0F, 0x78, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00	; U+007D
0006a4 0000
0006a5 0006
0006a6 0008
0006a7 0008
0006a8 0004
0006a9 0002
0006aa 0002
0006ab 000c                      .DB	0x00, 0x00, 0x06, 0x00, 0x08, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0C, 0x00	; U+007E
0006ac 5455
0006ad aaaa
0006ae 5455
0006af aaaa
0006b0 5455
0006b1 aaaa
0006b2 5455
0006b3 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0006b4 5455
0006b5 aaaa
0006b6 5455
0006b7 aaaa
0006b8 5455
0006b9 aaaa
0006ba 5455
0006bb aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0006bc 5455
0006bd aaaa
0006be 5455
0006bf aaaa
0006c0 5455
0006c1 aaaa
0006c2 5455
0006c3 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0006c4 5455
0006c5 aaaa
0006c6 5455
0006c7 aaaa
0006c8 5455
0006c9 aaaa
0006ca 5455
0006cb aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0006cc 5455
0006cd aaaa
0006ce 5455
0006cf aaaa
0006d0 5455
0006d1 aaaa
0006d2 5455
0006d3 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0006d4 5455
0006d5 aaaa
0006d6 5455
0006d7 aaaa
0006d8 5455
0006d9 aaaa
0006da 5455
0006db aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0006dc 5455
0006dd aaaa
0006de 5455
0006df aaaa
0006e0 5455
0006e1 aaaa
0006e2 5455
0006e3 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0006e4 5455
0006e5 aaaa
0006e6 5455
0006e7 aaaa
0006e8 5455
0006e9 aaaa
0006ea 5455
0006eb aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0006ec 5455
0006ed aaaa
0006ee 5455
0006ef aaaa
0006f0 5455
0006f1 aaaa
0006f2 5455
0006f3 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0006f4 5455
0006f5 aaaa
0006f6 5455
0006f7 aaaa
0006f8 5455
0006f9 aaaa
0006fa 5455
0006fb aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0006fc 5455
0006fd aaaa
0006fe 5455
0006ff aaaa
000700 5455
000701 aaaa
000702 5455
000703 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000704 5455
000705 aaaa
000706 5455
000707 aaaa
000708 5455
000709 aaaa
00070a 5455
00070b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00070c 5455
00070d aaaa
00070e 5455
00070f aaaa
000710 5455
000711 aaaa
000712 5455
000713 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000714 5455
000715 aaaa
000716 5455
000717 aaaa
000718 5455
000719 aaaa
00071a 5455
00071b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00071c 5455
00071d aaaa
00071e 5455
00071f aaaa
000720 5455
000721 aaaa
000722 5455
000723 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000724 5455
000725 aaaa
000726 5455
000727 aaaa
000728 5455
000729 aaaa
00072a 5455
00072b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00072c 5455
00072d aaaa
00072e 5455
00072f aaaa
000730 5455
000731 aaaa
000732 5455
000733 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000734 5455
000735 aaaa
000736 5455
000737 aaaa
000738 5455
000739 aaaa
00073a 5455
00073b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00073c 5455
00073d aaaa
00073e 5455
00073f aaaa
000740 5455
000741 aaaa
000742 5455
000743 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000744 5455
000745 aaaa
000746 5455
000747 aaaa
000748 5455
000749 aaaa
00074a 5455
00074b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00074c 5455
00074d aaaa
00074e 5455
00074f aaaa
000750 5455
000751 aaaa
000752 5455
000753 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000754 5455
000755 aaaa
000756 5455
000757 aaaa
000758 5455
000759 aaaa
00075a 5455
00075b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00075c 5455
00075d aaaa
00075e 5455
00075f aaaa
000760 5455
000761 aaaa
000762 5455
000763 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000764 5455
000765 aaaa
000766 5455
000767 aaaa
000768 5455
000769 aaaa
00076a 5455
00076b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00076c 5455
00076d aaaa
00076e 5455
00076f aaaa
000770 5455
000771 aaaa
000772 5455
000773 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000774 5455
000775 aaaa
000776 5455
000777 aaaa
000778 5455
000779 aaaa
00077a 5455
00077b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00077c 5455
00077d aaaa
00077e 5455
00077f aaaa
000780 5455
000781 aaaa
000782 5455
000783 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000784 5455
000785 aaaa
000786 5455
000787 aaaa
000788 5455
000789 aaaa
00078a 5455
00078b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00078c 5455
00078d aaaa
00078e 5455
00078f aaaa
000790 5455
000791 aaaa
000792 5455
000793 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000794 5455
000795 aaaa
000796 5455
000797 aaaa
000798 5455
000799 aaaa
00079a 5455
00079b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00079c 5455
00079d aaaa
00079e 5455
00079f aaaa
0007a0 5455
0007a1 aaaa
0007a2 5455
0007a3 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007a4 5455
0007a5 aaaa
0007a6 5455
0007a7 aaaa
0007a8 5455
0007a9 aaaa
0007aa 5455
0007ab aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007ac 5455
0007ad aaaa
0007ae 5455
0007af aaaa
0007b0 5455
0007b1 aaaa
0007b2 5455
0007b3 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007b4 0000
0007b5 0000
0007b6 0000
0007b7 0000
0007b8 0000
0007b9 0000
0007ba 0000
0007bb 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A0
0007bc 0000
0007bd 0000
0007be 0000
0007bf 3e03
0007c0 0000
0007c1 0000
0007c2 0000
0007c3 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A1
0007c4 0000
0007c5 c003
0007c6 2004
0007c7 2004
0007c8 f81f
0007c9 2004
0007ca 2004
0007cb 4002                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x04, 0x20, 0x1F, 0xF8, 0x04, 0x20, 0x04, 0x20, 0x02, 0x40	; U+00A2
0007cc 0000
0007cd 1001
0007ce 2001
0007cf e007
0007d0 2009
0007d1 1009
0007d2 1008
0007d3 2004                      .DB	0x00, 0x00, 0x01, 0x10, 0x01, 0x20, 0x07, 0xE0, 0x09, 0x20, 0x09, 0x10, 0x08, 0x10, 0x04, 0x20	; U+00A3
0007d4 0000
0007d5 2004
0007d6 c003
0007d7 4002
0007d8 4002
0007d9 c003
0007da 2004
0007db 0000                      .DB	0x00, 0x00, 0x04, 0x20, 0x03, 0xC0, 0x02, 0x40, 0x02, 0x40, 0x03, 0xC0, 0x04, 0x20, 0x00, 0x00	; U+00A4
0007dc 0000
0007dd 0008
0007de 4005
0007df 4003
0007e0 f001
0007e1 4003
0007e2 4005
0007e3 0008                      .DB	0x00, 0x00, 0x08, 0x00, 0x05, 0x40, 0x03, 0x40, 0x01, 0xF0, 0x03, 0x40, 0x05, 0x40, 0x08, 0x00	; U+00A5
0007e4 0000
0007e5 0000
0007e6 0000
0007e7 0000
0007e8 3c0f
0007e9 0000
0007ea 0000
0007eb 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A6
0007ec 5455
0007ed aaaa
0007ee 5455
0007ef aaaa
0007f0 5455
0007f1 aaaa
0007f2 5455
0007f3 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007f4 0000
0007f5 0000
0007f6 0060
0007f7 0000
0007f8 0000
0007f9 0060
0007fa 0000
0007fb 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A8
0007fc 0000
0007fd c003
0007fe 2004
0007ff 9009
000800 500a
000801 500a
000802 2004
000803 c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x09, 0x90, 0x0A, 0x50, 0x0A, 0x50, 0x04, 0x20, 0x03, 0xC0	; U+00A9
000804 5455
000805 aaaa
000806 5455
000807 aaaa
000808 5455
000809 aaaa
00080a 5455
00080b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00080c 0000
00080d 8000
00080e 4001
00080f 2002
000810 9004
000811 4001
000812 2002
000813 1004                      .DB	0x00, 0x00, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x90, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10	; U+00AB
000814 5455
000815 aaaa
000816 5455
000817 aaaa
000818 5455
000819 aaaa
00081a 5455
00081b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00081c 0000
00081d 8000
00081e 8000
00081f 8000
000820 8000
000821 8000
000822 8000
000823 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00	; U+00AD
000824 5455
000825 aaaa
000826 5455
000827 aaaa
000828 5455
000829 aaaa
00082a 5455
00082b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00082c 5455
00082d aaaa
00082e 5455
00082f aaaa
000830 5455
000831 aaaa
000832 5455
000833 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000834 0000
000835 0007
000836 8008
000837 8008
000838 8008
000839 0007
00083a 0000
00083b 0000                      .DB	0x00, 0x00, 0x07, 0x00, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00B0
00083c 5455
00083d aaaa
00083e 5455
00083f aaaa
000840 5455
000841 aaaa
000842 5455
000843 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000844 5455
000845 aaaa
000846 5455
000847 aaaa
000848 5455
000849 aaaa
00084a 5455
00084b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00084c 5455
00084d aaaa
00084e 5455
00084f aaaa
000850 5455
000851 aaaa
000852 5455
000853 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000854 5455
000855 aaaa
000856 5455
000857 aaaa
000858 5455
000859 aaaa
00085a 5455
00085b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00085c 5455
00085d aaaa
00085e 5455
00085f aaaa
000860 5455
000861 aaaa
000862 5455
000863 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000864 5455
000865 aaaa
000866 5455
000867 aaaa
000868 5455
000869 aaaa
00086a 5455
00086b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00086c 5455
00086d aaaa
00086e 5455
00086f aaaa
000870 5455
000871 aaaa
000872 5455
000873 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000874 0000
000875 0000
000876 0200
000877 0200
000878 0c00
000879 0000
00087a 0000
00087b 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00B8
00087c 5455
00087d aaaa
00087e 5455
00087f aaaa
000880 5455
000881 aaaa
000882 5455
000883 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000884 5455
000885 aaaa
000886 5455
000887 aaaa
000888 5455
000889 aaaa
00088a 5455
00088b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00088c 0000
00088d 1004
00088e 2002
00088f 4001
000890 9004
000891 2002
000892 4001
000893 8000                      .DB	0x00, 0x00, 0x04, 0x10, 0x02, 0x20, 0x01, 0x40, 0x04, 0x90, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80	; U+00BB
000894 5455
000895 aaaa
000896 5455
000897 aaaa
000898 5455
000899 aaaa
00089a 5455
00089b aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00089c 5455
00089d aaaa
00089e 5455
00089f aaaa
0008a0 5455
0008a1 aaaa
0008a2 5455
0008a3 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008a4 5455
0008a5 aaaa
0008a6 5455
0008a7 aaaa
0008a8 5455
0008a9 aaaa
0008aa 5455
0008ab aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008ac 0000
0008ad 0000
0008ae 0c00
0008af 1200
0008b0 2203
0008b1 0200
0008b2 0400
0008b3 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x12, 0x03, 0x22, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00	; U+00BF
0008b4 0000
0008b5 7000
0008b6 c043
0008b7 402c
0008b8 400c
0008b9 c003
0008ba 7000
0008bb 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x43, 0xC0, 0x2C, 0x40, 0x0C, 0x40, 0x03, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C0
0008bc 0000
0008bd 7000
0008be c003
0008bf 400c
0008c0 402c
0008c1 c043
0008c2 7000
0008c3 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x03, 0xC0, 0x0C, 0x40, 0x2C, 0x40, 0x43, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C1
0008c4 0000
0008c5 7000
0008c6 c023
0008c7 404c
0008c8 404c
0008c9 c023
0008ca 7000
0008cb 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x23, 0xC0, 0x4C, 0x40, 0x4C, 0x40, 0x23, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C2
0008cc 0000
0008cd 7020
0008ce c043
0008cf 404c
0008d0 402c
0008d1 c023
0008d2 7040
0008d3 0000                      .DB	0x00, 0x00, 0x20, 0x70, 0x43, 0xC0, 0x4C, 0x40, 0x2C, 0x40, 0x23, 0xC0, 0x40, 0x70, 0x00, 0x00	; U+00C3
0008d4 0000
0008d5 7000
0008d6 c063
0008d7 400c
0008d8 400c
0008d9 c063
0008da 7000
0008db 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x63, 0xC0, 0x0C, 0x40, 0x0C, 0x40, 0x63, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C4
0008dc 0000
0008dd 7000
0008de c033
0008df 404c
0008e0 404c
0008e1 c033
0008e2 7000
0008e3 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x33, 0xC0, 0x4C, 0x40, 0x4C, 0x40, 0x33, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C5
0008e4 0000
0008e5 7000
0008e6 c003
0008e7 400c
0008e8 f00f
0008e9 1009
0008ea 1009
0008eb 1008                      .DB	0x00, 0x00, 0x00, 0x70, 0x03, 0xC0, 0x0C, 0x40, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10	; U+00C6
0008ec 0000
0008ed c003
0008ee 2204
0008ef 1208
0008f0 1c08
0008f1 1008
0008f2 1008
0008f3 0000                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x22, 0x08, 0x12, 0x08, 0x1C, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00C7
0008f4 0000
0008f5 f00f
0008f6 1049
0008f7 1029
0008f8 1009
0008f9 1009
0008fa 1008
0008fb 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x49, 0x10, 0x29, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00C8
0008fc 0000
0008fd f00f
0008fe 1009
0008ff 1009
000900 1029
000901 1049
000902 1008
000903 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x29, 0x10, 0x49, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00C9
000904 0000
000905 f00f
000906 1029
000907 1049
000908 1049
000909 1029
00090a 1008
00090b 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x29, 0x10, 0x49, 0x10, 0x49, 0x10, 0x29, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CA
00090c 0000
00090d f00f
00090e 1069
00090f 1009
000910 1009
000911 1069
000912 1008
000913 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x69, 0x10, 0x09, 0x10, 0x09, 0x10, 0x69, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CB
000914 0000
000915 0000
000916 1008
000917 1048
000918 f02f
000919 1008
00091a 1008
00091b 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x48, 0x10, 0x2F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CC
00091c 0000
00091d 0000
00091e 1008
00091f 1008
000920 f02f
000921 1048
000922 1008
000923 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x08, 0x10, 0x2F, 0xF0, 0x48, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CD
000924 0000
000925 0000
000926 1008
000927 1028
000928 f04f
000929 1028
00092a 1008
00092b 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x28, 0x10, 0x4F, 0xF0, 0x28, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CE
00092c 0000
00092d 0000
00092e 1008
00092f 1068
000930 f00f
000931 1068
000932 1008
000933 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x68, 0x10, 0x0F, 0xF0, 0x68, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CF
000934 0000
000935 0001
000936 f00f
000937 1009
000938 1009
000939 1008
00093a 2004
00093b c003                      .DB	0x00, 0x00, 0x01, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D0
00093c 0000
00093d f02f
00093e 0044
00093f 0042
000940 0021
000941 8020
000942 f04f
000943 0000                      .DB	0x00, 0x00, 0x2F, 0xF0, 0x44, 0x00, 0x42, 0x00, 0x21, 0x00, 0x20, 0x80, 0x4F, 0xF0, 0x00, 0x00	; U+00D1
000944 0000
000945 c003
000946 2004
000947 1048
000948 1028
000949 1008
00094a 2004
00094b c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x48, 0x10, 0x28, 0x10, 0x08, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D2
00094c 0000
00094d c003
00094e 2004
00094f 1008
000950 1028
000951 1048
000952 2004
000953 c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x08, 0x10, 0x28, 0x10, 0x48, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D3
000954 0000
000955 c003
000956 2004
000957 1028
000958 1048
000959 1028
00095a 2004
00095b c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x28, 0x10, 0x48, 0x10, 0x28, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D4
00095c 0000
00095d c003
00095e 2024
00095f 1048
000960 1048
000961 1028
000962 2024
000963 c043                      .DB	0x00, 0x00, 0x03, 0xC0, 0x24, 0x20, 0x48, 0x10, 0x48, 0x10, 0x28, 0x10, 0x24, 0x20, 0x43, 0xC0	; U+00D5
000964 0000
000965 c003
000966 2064
000967 1008
000968 1008
000969 1008
00096a 2064
00096b c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x64, 0x20, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x64, 0x20, 0x03, 0xC0	; U+00D6
00096c 0000
00096d 0000
00096e 2002
00096f 4001
000970 8000
000971 4001
000972 2002
000973 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x00, 0x00	; U+00D7
000974 0000
000975 c803
000976 3004
000977 5008
000978 9009
000979 100a
00097a 200c
00097b c013                      .DB	0x00, 0x00, 0x03, 0xC8, 0x04, 0x30, 0x08, 0x50, 0x09, 0x90, 0x0A, 0x10, 0x0C, 0x20, 0x13, 0xC0	; U+00D8
00097c 0000
00097d e00f
00097e 1040
00097f 1020
000980 1000
000981 1000
000982 e00f
000983 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x40, 0x10, 0x20, 0x10, 0x00, 0x10, 0x00, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00D9
000984 0000
000985 e00f
000986 1000
000987 1000
000988 1020
000989 1040
00098a e00f
00098b 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x20, 0x10, 0x40, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00DA
00098c 0000
00098d e00f
00098e 1020
00098f 1040
000990 1040
000991 1020
000992 e00f
000993 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x20, 0x10, 0x40, 0x10, 0x40, 0x10, 0x20, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00DB
000994 0000
000995 e00f
000996 1060
000997 1000
000998 1000
000999 1060
00099a e00f
00099b 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x60, 0x10, 0x00, 0x10, 0x00, 0x10, 0x60, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00DC
00099c 0000
00099d 000c
00099e 0062
00099f 0001
0009a0 f000
0009a1 0001
0009a2 0062
0009a3 000c                      .DB	0x00, 0x00, 0x0C, 0x00, 0x62, 0x00, 0x01, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x62, 0x00, 0x0C, 0x00	; U+00DD
0009a4 0000
0009a5 f00f
0009a6 2004
0009a7 2004
0009a8 2004
0009a9 2004
0009aa c003
0009ab 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x03, 0xC0, 0x00, 0x00	; U+00DE
0009ac 0000
0009ad f007
0009ae 0008
0009af 0008
0009b0 1009
0009b1 100b
0009b2 e004
0009b3 0000                      .DB	0x00, 0x00, 0x07, 0xF0, 0x08, 0x00, 0x08, 0x00, 0x09, 0x10, 0x0B, 0x10, 0x04, 0xE0, 0x00, 0x00	; U+00DF
0009b4 0000
0009b5 6000
0009b6 9012
0009b7 900a
0009b8 9002
0009b9 9002
0009ba f001
0009bb 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x12, 0x90, 0x0A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E0
0009bc 0000
0009bd 6000
0009be 9002
0009bf 9002
0009c0 900a
0009c1 9012
0009c2 f001
0009c3 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x02, 0x90, 0x02, 0x90, 0x0A, 0x90, 0x12, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E1
0009c4 0000
0009c5 6000
0009c6 900a
0009c7 9012
0009c8 9012
0009c9 900a
0009ca f001
0009cb 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x0A, 0x90, 0x12, 0x90, 0x12, 0x90, 0x0A, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E2
0009cc 0000
0009cd 6008
0009ce 9012
0009cf 9012
0009d0 900a
0009d1 900a
0009d2 f011
0009d3 0000                      .DB	0x00, 0x00, 0x08, 0x60, 0x12, 0x90, 0x12, 0x90, 0x0A, 0x90, 0x0A, 0x90, 0x11, 0xF0, 0x00, 0x00	; U+00E3
0009d4 0000
0009d5 6000
0009d6 901a
0009d7 9002
0009d8 9002
0009d9 901a
0009da f001
0009db 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x1A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x1A, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E4
0009dc 0000
0009dd 6000
0009de 9032
0009df 904a
0009e0 904a
0009e1 9032
0009e2 f001
0009e3 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x32, 0x90, 0x4A, 0x90, 0x4A, 0x90, 0x32, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E5
0009e4 0000
0009e5 6000
0009e6 9002
0009e7 9002
0009e8 e001
0009e9 9002
0009ea 9002
0009eb 9001                      .DB	0x00, 0x00, 0x00, 0x60, 0x02, 0x90, 0x02, 0x90, 0x01, 0xE0, 0x02, 0x90, 0x02, 0x90, 0x01, 0x90	; U+00E6
0009ec 0000
0009ed e001
0009ee 1202
0009ef 1202
0009f0 1c02
0009f1 1002
0009f2 2001
0009f3 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x12, 0x02, 0x12, 0x02, 0x1C, 0x02, 0x10, 0x01, 0x20, 0x00, 0x00	; U+00E7
0009f4 0000
0009f5 e001
0009f6 9012
0009f7 900a
0009f8 9002
0009f9 9002
0009fa 9001
0009fb 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x12, 0x90, 0x0A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00E8
0009fc 0000
0009fd e001
0009fe 9002
0009ff 9002
000a00 900a
000a01 9012
000a02 9001
000a03 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x90, 0x02, 0x90, 0x0A, 0x90, 0x12, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00E9
000a04 0000
000a05 e001
000a06 900a
000a07 9012
000a08 9012
000a09 900a
000a0a 9001
000a0b 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x0A, 0x90, 0x12, 0x90, 0x12, 0x90, 0x0A, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00EA
000a0c 0000
000a0d e001
000a0e 901a
000a0f 9002
000a10 9002
000a11 901a
000a12 9001
000a13 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x1A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x1A, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00EB
000a14 0000
000a15 0000
000a16 1012
000a17 100a
000a18 f003
000a19 1000
000a1a 1000
000a1b 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x12, 0x10, 0x0A, 0x10, 0x03, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00EC
000a1c 0000
000a1d 0000
000a1e 1002
000a1f 1002
000a20 f00b
000a21 1010
000a22 1000
000a23 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x02, 0x10, 0x0B, 0xF0, 0x10, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00ED
000a24 0000
000a25 0000
000a26 100a
000a27 1012
000a28 f013
000a29 1008
000a2a 1000
000a2b 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x0A, 0x10, 0x12, 0x10, 0x13, 0xF0, 0x08, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00EE
000a2c 0000
000a2d 0000
000a2e 101a
000a2f 1002
000a30 f003
000a31 1018
000a32 1000
000a33 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x1A, 0x10, 0x02, 0x10, 0x03, 0xF0, 0x18, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00EF
000a34 0000
000a35 e001
000a36 100a
000a37 102a
000a38 101a
000a39 1016
000a3a e021
000a3b 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x0A, 0x10, 0x2A, 0x10, 0x1A, 0x10, 0x16, 0x10, 0x21, 0xE0, 0x00, 0x00	; U+00F0
000a3c 0000
000a3d f00b
000a3e 0012
000a3f 0012
000a40 000a
000a41 000a
000a42 f011
000a43 0000                      .DB	0x00, 0x00, 0x0B, 0xF0, 0x12, 0x00, 0x12, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x11, 0xF0, 0x00, 0x00	; U+00F1
000a44 0000
000a45 e001
000a46 1012
000a47 100a
000a48 1002
000a49 1002
000a4a e001
000a4b 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x12, 0x10, 0x0A, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F2
000a4c 0000
000a4d e001
000a4e 1002
000a4f 1002
000a50 100a
000a51 1012
000a52 e001
000a53 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x0A, 0x10, 0x12, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F3
000a54 0000
000a55 e001
000a56 100a
000a57 1012
000a58 1012
000a59 100a
000a5a e001
000a5b 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x0A, 0x10, 0x12, 0x10, 0x12, 0x10, 0x0A, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F4
000a5c 0000
000a5d e009
000a5e 1012
000a5f 1012
000a60 100a
000a61 100a
000a62 e011
000a63 0000                      .DB	0x00, 0x00, 0x09, 0xE0, 0x12, 0x10, 0x12, 0x10, 0x0A, 0x10, 0x0A, 0x10, 0x11, 0xE0, 0x00, 0x00	; U+00F5
000a64 0000
000a65 e001
000a66 101a
000a67 1002
000a68 1002
000a69 101a
000a6a e001
000a6b 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x1A, 0x10, 0x02, 0x10, 0x02, 0x10, 0x1A, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F6
000a6c 0000
000a6d 8000
000a6e 8000
000a6f b006
000a70 b006
000a71 8000
000a72 8000
000a73 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x06, 0xB0, 0x06, 0xB0, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00	; U+00F7
000a74 0000
000a75 e801
000a76 3002
000a77 5002
000a78 9002
000a79 1003
000a7a e005
000a7b 0000                      .DB	0x00, 0x00, 0x01, 0xE8, 0x02, 0x30, 0x02, 0x50, 0x02, 0x90, 0x03, 0x10, 0x05, 0xE0, 0x00, 0x00	; U+00F8
000a7c 0000
000a7d e003
000a7e 1010
000a7f 1008
000a80 1000
000a81 1000
000a82 f003
000a83 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x10, 0x10, 0x08, 0x10, 0x00, 0x10, 0x00, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00F9
000a84 0000
000a85 e003
000a86 1000
000a87 1000
000a88 1008
000a89 1010
000a8a f003
000a8b 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x08, 0x10, 0x10, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00FA
000a8c 0000
000a8d e003
000a8e 1008
000a8f 1010
000a90 1010
000a91 1008
000a92 f003
000a93 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x08, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00FB
000a94 0000
000a95 e003
000a96 1018
000a97 1000
000a98 1000
000a99 1018
000a9a f003
000a9b 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x18, 0x10, 0x00, 0x10, 0x00, 0x10, 0x18, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00FC
000a9c 0000
000a9d e003
000a9e 1200
000a9f 1200
000aa0 1208
000aa1 1210
000aa2 fc03
000aa3 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x12, 0x00, 0x12, 0x08, 0x12, 0x10, 0x12, 0x03, 0xFC, 0x00, 0x00	; U+00FD
000aa4 0000
000aa5 fe1f
000aa6 1002
000aa7 1002
000aa8 1002
000aa9 1002
000aaa e001
000aab 0000                      .DB	0x00, 0x00, 0x1F, 0xFE, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00FE
000aac 0000
000aad e003
000aae 1218
000aaf 1200
000ab0 1200
000ab1 1218
000ab2 fc03
000ab3 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x18, 0x12, 0x00, 0x12, 0x00, 0x12, 0x18, 0x12, 0x03, 0xFC, 0x00, 0x00	; U+00FF
                                 
                                 
                                 
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega32U4" register use summary:
x  :   8 y  :   0 z  :   6 r0 :  12 r1 :   9 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 133 r17:  35 r18:  17 r19:   8 r20:   3 
r21:  28 r22:  13 r23:   0 r24:   5 r25:   5 r26:  30 r27:  27 r28:  22 
r29:  19 r30:  28 r31:  25 
Registers used: 19 out of 35 (54.3%)

"ATmega32U4" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   1 add   :   9 adiw  :   5 and   :   0 
andi  :   0 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  10 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   3 brlt  :   0 brmi  :   0 
brne  :  13 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   1 cbi   :  10 cbr   :   0 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :   1 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   3 cpc   :   0 
cpi   :  13 cpse  :   0 dec   :  11 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :   4 inc   :   3 jmp   :   0 
ld    :   1 ldd   :   0 ldi   : 114 lds   :   3 lpm   :  10 lsl   :   3 
lsr   :  15 mov   :  11 movw  :   1 mul   :   1 muls  :   0 mulsu :   0 
neg   :   0 nop   :   2 or    :   2 ori   :   1 out   :  11 pop   :  69 
push  :  69 rcall :  48 ret   :  28 reti  :   2 rjmp  :  19 rol   :   0 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :  15 sbic  :   1 sbis  :   2 
sbiw  :   3 sbr   :   0 sbrc  :   0 sbrs  :   4 sec   :   0 seh   :   0 
sei   :   0 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :   7 std   :   0 sts   :  10 
sub   :   1 subi  :   1 swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 42 out of 113 (37.2%)

"ATmega32U4" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x001568   1102   4212   5314   32768  16.2%
[.dseg] 0x000100 0x000100      0      0      0    2560   0.0%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 0 warnings
