
AVRASM ver. 2.2.8  C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm Thu Dec 05 13:22:56 2024

[builtin](2): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm(17): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm(1429): Including file 'C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\LCDDriver.asm'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\LCDDriver.asm(31): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
[builtin](2): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm(17): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm(1429): Including file 'C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\LCDDriver.asm'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\LCDDriver.asm(31): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
                                 
                                 
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32U4.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32U4def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32U4
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32U4
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32U4DEF_INC_
                                 #define _M32U4DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega32U4
                                 #pragma AVRPART ADMIN PART_NAME ATmega32U4
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x95
                                 .equ	SIGNATURE_002	= 0x87
                                 
                                 #pragma AVRPART CORE CORE_VERSION V3
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	PLLCSR	= 0x29
                                 .equ	PLLFRQ	= 0x32
                                 .equ	UEINT	= 0xf4	; MEMORY MAPPED
                                 .equ	UEBCHX	= 0xf3	; MEMORY MAPPED
                                 .equ	UEBCLX	= 0xf2	; MEMORY MAPPED
                                 .equ	UEDATX	= 0xf1	; MEMORY MAPPED
                                 .equ	UEIENX	= 0xf0	; MEMORY MAPPED
                                 .equ	UESTA1X	= 0xef	; MEMORY MAPPED
                                 .equ	UESTA0X	= 0xee	; MEMORY MAPPED
                                 .equ	UECFG1X	= 0xed	; MEMORY MAPPED
                                 .equ	UECFG0X	= 0xec	; MEMORY MAPPED
                                 .equ	UECONX	= 0xeb	; MEMORY MAPPED
                                 .equ	UERST	= 0xea	; MEMORY MAPPED
                                 .equ	UENUM	= 0xe9	; MEMORY MAPPED
                                 .equ	UEINTX	= 0xe8	; MEMORY MAPPED
                                 .equ	UDMFN	= 0xe6	; MEMORY MAPPED
                                 .equ	UDFNUMH	= 0xe5	; MEMORY MAPPED
                                 .equ	UDFNUML	= 0xe4	; MEMORY MAPPED
                                 .equ	UDADDR	= 0xe3	; MEMORY MAPPED
                                 .equ	UDIEN	= 0xe2	; MEMORY MAPPED
                                 .equ	UDINT	= 0xe1	; MEMORY MAPPED
                                 .equ	UDCON	= 0xe0	; MEMORY MAPPED
                                 .equ	USBINT	= 0xda	; MEMORY MAPPED
                                 .equ	USBSTA	= 0xd9	; MEMORY MAPPED
                                 .equ	USBCON	= 0xd8	; MEMORY MAPPED
                                 .equ	UHWCON	= 0xd7	; MEMORY MAPPED
                                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                                 .equ 	TWAMR		= 0xbd	;
                                 .equ  TWCR		= 0xbc	;
                                 .equ 	TWDR		= 0xbb	;
                                 .equ 	TWAR		= 0xba 	;
                                 .equ 	TWSR		= 0xb9	;
                                 .equ 	TWBR		= 0xb8	;
                                 .equ	OCR3CL	= 0x9c	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x9d	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x8c	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x8d	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	DIDR2	= 0x7d	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	TIMSK4	= 0x72	; MEMORY MAPPED
                                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRB	= 0x6a	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	RCCTRL	= 0x67	; MEMORY MAPPED
                                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	EIND	= 0x3c
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	OCDR	= 0x31
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR4	= 0x19
                                 .equ	TIFR3	= 0x18
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTF	= 0x11
                                 .equ	DDRF	= 0x10
                                 .equ	PINF	= 0x0f
                                 .equ	PORTE	= 0x0e
                                 .equ	DDRE	= 0x0d
                                 .equ	PINE	= 0x0c
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 .equ	DT4	= 0xd4	; MEMORY MAPPED
                                 .equ	OCR4D	= 0xd2	; MEMORY MAPPED
                                 .equ	OCR4C	= 0xd1	; MEMORY MAPPED
                                 .equ	OCR4B	= 0xd0	; MEMORY MAPPED
                                 .equ	OCR4A	= 0xcf	; MEMORY MAPPED
                                 .equ	TCCR4E	= 0xc4	; MEMORY MAPPED
                                 .equ	TCCR4D	= 0xc3	; MEMORY MAPPED
                                 .equ	TCCR4C	= 0xc2	; MEMORY MAPPED
                                 .equ	TCCR4B	= 0xc1	; MEMORY MAPPED
                                 .equ	TCCR4A	= 0xc0	; MEMORY MAPPED
                                 .equ	TC4H	= 0xbf	; MEMORY MAPPED
                                 .equ	TCNT4	= 0xbe	; MEMORY MAPPED
                                 .equ	CLKSEL1	= 0xc6	; MEMORY MAPPED
                                 .equ	CLKSEL0	= 0xc5	; MEMORY MAPPED
                                 .equ	CLKSTA	= 0xc7	; MEMORY MAPPED
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCPHA1	= UCSZ10	; For compatibility
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	UDORD1	= UCSZ11	; For compatibility
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL10	= 6	; USART Mode Select
                                 .equ	UMSEL11	= 7	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register High Byte
                                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	SIGRD	= 5	; Signature Row Read
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARH - EEPROM Address Register Low Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                                 
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                                 .equ	OCIE3C	= 3	; Timer/Counter3 Output Compare C Match Interrupt Enable
                                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3A	= 1	; Output Compare Flag 3A
                                 .equ	OCF3B	= 2	; Output Compare Flag 3B
                                 .equ	OCF3C	= 3	; Output Compare Flag 3C
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode
                                 .equ	WGM31	= 1	; Waveform Generation Mode
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Output Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Prescaler source of Timer/Counter 3
                                 .equ	CS31	= 1	; Prescaler source of Timer/Counter 3
                                 .equ	CS32	= 2	; Prescaler source of Timer/Counter 3
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter 3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare 3C
                                 .equ	FOC3B	= 6	; Force Output Compare 3B
                                 .equ	FOC3A	= 7	; Force Output Compare 3A
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                                 .equ	OCIE1C	= 3	; Timer/Counter1 Output Compare C Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter1 Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	OCF1C	= 3	; Output Compare Flag 1C
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Output Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter 1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare 1C
                                 .equ	FOC1B	= 6	; Force Output Compare 1B
                                 .equ	FOC1A	= 7	; Force Output Compare 1A
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_4 **************
                                 ; DT4 - Timer/Counter 4 Dead Time Value
                                 .equ	DT4L0	= 0	; Timer/Counter 4 Dead Time Value Bit 0
                                 .equ	DT4L1	= 1	; Timer/Counter 4 Dead Time Value Bit 1
                                 .equ	DT4L2	= 2	; Timer/Counter 4 Dead Time Value Bit 2
                                 .equ	DT4L3	= 3	; Timer/Counter 4 Dead Time Value Bit 3
                                 .equ	DT4L4	= 4	; Timer/Counter 4 Dead Time Value Bit 4
                                 .equ	DT4L5	= 5	; Timer/Counter 4 Dead Time Value Bit 5
                                 .equ	DT4L6	= 6	; Timer/Counter 4 Dead Time Value Bit 6
                                 .equ	DT4L7	= 7	; Timer/Counter 4 Dead Time Value Bit 7
                                 
                                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                                 .equ	TOV4	= 2	; Timer/Counter4 Overflow Flag
                                 .equ	OCF4B	= 5	; Output Compare Flag 4B
                                 .equ	OCF4A	= 6	; Output Compare Flag 4A
                                 .equ	OCF4D	= 7	; Output Compare Flag 4D
                                 
                                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                                 .equ	TOIE4	= 2	; Timer/Counter4 Overflow Interrupt Enable
                                 .equ	OCIE4B	= 5	; Timer/Counter4 Output Compare B Match Interrupt Enable
                                 .equ	OCIE4A	= 6	; Timer/Counter4 Output Compare A Match Interrupt Enable
                                 .equ	OCIE4D	= 7	; Timer/Counter4 Output Compare D Match Interrupt Enable
                                 
                                 ; OCR4D - Timer/Counter4 Output Compare Register D
                                 .equ	OCR4D0	= 0	; Timer/Counter4 Output Compare Register Low Byte bit 0
                                 .equ	OCR4D1	= 1	; Timer/Counter4 Output Compare Register Low Byte bit 1
                                 .equ	OCR4D2	= 2	; Timer/Counter4 Output Compare Register Low Byte bit 2
                                 .equ	OCR4D3	= 3	; Timer/Counter4 Output Compare Register Low Byte bit 3
                                 .equ	OCR4D4	= 4	; Timer/Counter4 Output Compare Register Low Byte bit 4
                                 .equ	OCR4D5	= 5	; Timer/Counter4 Output Compare Register Low Byte bit 5
                                 .equ	OCR4D6	= 6	; Timer/Counter4 Output Compare Register Low Byte bit 6
                                 .equ	OCR4D7	= 7	; Timer/Counter4 Output Compare Register Low Byte bit 7
                                 
                                 ; OCR4C - Timer/Counter4 Output Compare Register C
                                 .equ	OCR4C0	= 0	; Timer/Counter4 Output Compare Register bit 0
                                 .equ	OCR4C1	= 1	; Timer/Counter4 Output Compare Register bit 1
                                 .equ	OCR4C2	= 2	; Timer/Counter4 Output Compare Register bit 2
                                 .equ	OCR4C3	= 3	; Timer/Counter4 Output Compare Register bit 3
                                 .equ	OCR4C4	= 4	; Timer/Counter4 Output Compare Register bit 4
                                 .equ	OCR4C5	= 5	; Timer/Counter4 Output Compare Register bit 5
                                 .equ	OCR4C6	= 6	; Timer/Counter4 Output Compare Register 6
                                 .equ	OCR4C7	= 7	; Timer/Counter4 Output Compare Register bit 7
                                 
                                 ; OCR4B - Timer/Counter4 Output Compare Register B
                                 .equ	OCR4B0	= 0	; Timer/Counter4 Output Compare Register bit 0
                                 .equ	OCR4B1	= 1	; Timer/Counter4 Output Compare Register bit 1
                                 .equ	OCR4B2	= 2	; Timer/Counter4 Output Compare Register bit 2
                                 .equ	OCR4B3	= 3	; Timer/Counter4 Output Compare Register bit 3
                                 .equ	OCR4B4	= 4	; Timer/Counter4 Output Compare Register bit 4
                                 .equ	OCR4B5	= 5	; Timer/Counter4 Output Compare Register bit 5
                                 .equ	OCR4B6	= 6	; Timer/Counter4 Output Compare Register bit 6
                                 .equ	OCR4B7	= 7	; Timer/Counter4 Output Compare Register bit 7
                                 
                                 ; OCR4A - Timer/Counter4 Output Compare Register A
                                 .equ	OCR4A0	= 0	; Timer/Counter4 Output Compare Register Bit 0
                                 .equ	OCR4A1	= 1	; Timer/Counter4 Output Compare Register Bit 1
                                 .equ	OCR4A2	= 2	; Timer/Counter4 Output Compare Register Low Byte Bit 2
                                 .equ	OCR4A3	= 3	; Timer/Counter4 Output Compare Register Low Byte Bit 3
                                 .equ	OCR4A4	= 4	; Timer/Counter4 Output Compare Register Bit 4
                                 .equ	OCR4A5	= 5	; Timer/Counter4 Output Compare Register Bit 5
                                 .equ	OCR4A6	= 6	; Timer/Counter4 Output Compare Register Bit 6
                                 .equ	OCR4A7	= 7	; Timer/Counter4 Output Compare Register Bit 7
                                 
                                 ; TC4H - Timer/Counter4
                                 .equ	TC48	= 0	; Timer/Counter4 bit 8
                                 .equ	TC49	= 1	; Timer/Counter4 bit 9
                                 .equ	TC410	= 2	; Timer/Counter4 bit 10
                                 
                                 ; TCNT4 - Timer/Counter4 Low Bytes
                                 .equ	TC40	= 0	; Timer/Counter4 bit 0
                                 .equ	TC41	= 1	; Timer/Counter4 bit 1
                                 .equ	TC42	= 2	; Timer/Counter4 bit 2
                                 .equ	TC43	= 3	; Timer/Counter4  bit 3
                                 .equ	TC44	= 4	; Timer/Counter4 bit 4
                                 .equ	TC45	= 5	; Timer/Counter4 bit 5
                                 .equ	TC46	= 6	; Timer/Counter4 bit 6
                                 .equ	TC47	= 7	; Timer/Counter4 bit 7
                                 
                                 ; TCCR4E - Timer/Counter 4 Control Register E
                                 .equ	OC4OE0	= 0	; Output Compare Override Enable bit
                                 .equ	OC4OE1	= 1	; Output Compare Override Enable bit
                                 .equ	OC4OE2	= 2	; Output Compare Override Enable bit
                                 .equ	OC4OE3	= 3	; Output Compare Override Enable bit
                                 .equ	OC4OE4	= 4	; Output Compare Override Enable bit
                                 .equ	OC4OE5	= 5	; Output Compare Override Enable bit
                                 .equ	ENHC4	= 6	; Enhanced Compare/PWM Mode
                                 .equ	TLOCK4	= 7	; Register Update Lock
                                 
                                 ; TCCR4D - Timer/Counter 4 Control Register D
                                 .equ	WGM40	= 0	; Waveform Generation Mode bits
                                 .equ	WGM41	= 1	; Waveform Generation Mode bits
                                 .equ	FPF4	= 2	; Fault Protection Interrupt Flag
                                 .equ	FPAC4	= 3	; Fault Protection Analog Comparator Enable
                                 .equ	FPES4	= 4	; Fault Protection Edge Select
                                 .equ	FPNC4	= 5	; Fault Protection Noise Canceler
                                 .equ	FPEN4	= 6	; Fault Protection Mode Enable
                                 .equ	FPIE4	= 7	; Fault Protection Interrupt Enable
                                 
                                 ; TCCR4C - Timer/Counter 4 Control Register C
                                 .equ	PWM4D	= 0	; Pulse Width Modulator D Enable
                                 .equ	FOC4D	= 1	; Force Output Compare Match 4D
                                 .equ	COM4D0	= 2	; Comparator D Output Mode
                                 .equ	COM4D1	= 3	; Comparator D Output Mode
                                 .equ	COM4B0S	= 4	; Comparator B Output Mode
                                 .equ	COM4B1S	= 5	; Comparator B Output Mode
                                 .equ	COM4A0S	= 6	; Comparator A Output Mode
                                 .equ	COM4A1S	= 7	; Comparator A Output Mode
                                 
                                 ; TCCR4B - Timer/Counter4 Control Register B
                                 .equ	CS40	= 0	; Clock Select Bit 0
                                 .equ	CS41	= 1	; Clock Select Bit 1
                                 .equ	CS42	= 2	; Clock Select Bit 2
                                 .equ	CS43	= 3	; Clock Select Bit 3
                                 .equ	DTPS40	= 4	; Dead Time Prescaler Bit 0
                                 .equ	DTPS41	= 5	; Dead Time Prescaler Bit 1
                                 .equ	PSR4	= 6	; Prescaler Reset Timer/Counter 4
                                 .equ	PWM4X	= 7	; PWM Inversion Mode
                                 
                                 ; TCCR4A - Timer/Counter4 Control Register A
                                 .equ	PWM4B	= 0	; 
                                 .equ	PWM4A	= 1	; 
                                 .equ	FOC4B	= 2	; Force Output Compare Match 4B
                                 .equ	FOC4A	= 3	; Force Output Compare Match 4A
                                 .equ	COM4B0	= 4	; Compare Output Mode 4B, bit 0
                                 .equ	COM4B1	= 5	; Compare Output Mode 4B, bit 1
                                 .equ	COM4A0	= 6	; Compare Output Mode 4A, bit 0
                                 .equ	COM4A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE6	= 6	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE6	= 6	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                                 .equ	ADTS3	= 4	; ADC Auto Trigger Source 3
                                 .equ	MUX5	= 5	; Analog Channel and Gain Selection Bits
                                 .equ	ADHSM	= 7	; ADC High Speed Mode
                                 
                                 ; DIDR0 - Digital Input Disable Register 1
                                 .equ	ADC0D	= 0	; ADC0 Digital input Disable
                                 .equ	ADC1D	= 1	; ADC1 Digital input Disable
                                 .equ	ADC2D	= 2	; ADC2 Digital input Disable
                                 .equ	ADC3D	= 3	; ADC3 Digital input Disable
                                 .equ	ADC4D	= 4	; ADC4 Digital input Disable
                                 .equ	ADC5D	= 5	; ADC5 Digital input Disable
                                 .equ	ADC6D	= 6	; ADC6 Digital input Disable
                                 .equ	ADC7D	= 7	; ADC7 Digital input Disable
                                 
                                 ; DIDR2 - Digital Input Disable Register 1
                                 .equ	ADC8D	= 0	; ADC8 Digital input Disable
                                 .equ	ADC9D	= 1	; ADC9 Digital input Disable
                                 .equ	ADC10D	= 2	; ADC10 Digital input Disable
                                 .equ	ADC11D	= 3	; ADC11 Digital input Disable
                                 .equ	ADC12D	= 4	; ADC12 Digital input Disable
                                 .equ	ADC13D	= 5	; ADC13 Digital input Disable
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - 
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PUD	= 4	; Pull-up disable
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; RCCTRL - Oscillator Control Register
                                 .equ	RCFREQ	= 0	; 
                                 
                                 ; CLKPR - 
                                 .equ	CLKPS0	= 0	; 
                                 .equ	CLKPS1	= 1	; 
                                 .equ	CLKPS2	= 2	; 
                                 .equ	CLKPS3	= 3	; 
                                 .equ	CLKPCE	= 7	; 
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                                 
                                 ; EIND - Extended Indirect Register
                                 .equ	EIND0	= 0	; Bit 0
                                 
                                 ; GPIOR2 - General Purpose IO Register 2
                                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                                 
                                 ; GPIOR1 - General Purpose IO Register 1
                                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                                 
                                 ; GPIOR0 - General Purpose IO Register 0
                                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                                 
                                 ; PRR1 - Power Reduction Register1
                                 .equ	PRUSART1	= 0	; Power Reduction USART1
                                 .equ	PRTIM3	= 3	; Power Reduction Timer/Counter3
                                 .equ	PRUSB	= 7	; Power Reduction USB
                                 
                                 ; PRR0 - Power Reduction Register0
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 ; CLKSTA - 
                                 .equ	EXTON	= 0	; 
                                 .equ	RCON	= 1	; 
                                 
                                 ; CLKSEL0 - 
                                 .equ	CLKS	= 0	; 
                                 .equ	EXTE	= 2	; 
                                 .equ	RCE	= 3	; 
                                 .equ	EXSUT0	= 4	; 
                                 .equ	EXSUT1	= 5	; 
                                 .equ	RCSUT0	= 6	; 
                                 .equ	RCSUT1	= 7	; 
                                 
                                 ; CLKSEL1 - 
                                 .equ	EXCKSEL0	= 0	; 
                                 .equ	EXCKSEL1	= 1	; 
                                 .equ	EXCKSEL2	= 2	; 
                                 .equ	EXCKSEL3	= 3	; 
                                 .equ	RCCKSEL0	= 4	; 
                                 .equ	RCCKSEL1	= 5	; 
                                 .equ	RCCKSEL2	= 6	; 
                                 .equ	RCCKSEL3	= 7	; 
                                 
                                 
                                 ; ***** PLL **************************
                                 ; PLLCSR - PLL Status and Control register
                                 .equ	PLOCK	= 0	; PLL Lock Status Bit
                                 .equ	PLLE	= 1	; PLL Enable Bit
                                 .equ	PINDIV	= 4	; PLL prescaler Bit 2
                                 
                                 ; PLLFRQ - PLL Frequency Control Register
                                 .equ	PDIV0	= 0	; 
                                 .equ	PDIV1	= 1	; 
                                 .equ	PDIV2	= 2	; 
                                 .equ	PDIV3	= 3	; 
                                 .equ	PLLTM0	= 4	; 
                                 .equ	PLLTM1	= 5	; 
                                 .equ	PLLUSB	= 6	; 
                                 .equ	PINMUX	= 7	; 
                                 
                                 
                                 ; ***** USB_DEVICE *******************
                                 ; USBCON - USB General Control Register
                                 .equ	VBUSTE	= 0	; 
                                 .equ	OTGPADE	= 4	; 
                                 .equ	FRZCLK	= 5	; 
                                 .equ	USBE	= 7	; 
                                 
                                 ; UDCON - 
                                 .equ	DETACH	= 0	; 
                                 .equ	RMWKUP	= 1	; 
                                 .equ	LSM	= 2	; USB low speed mode
                                 .equ	RSTCPU	= 3	; 
                                 
                                 ; UDINT - 
                                 .equ	SUSPI	= 0	; 
                                 .equ	SOFI	= 2	; 
                                 .equ	EORSTI	= 3	; 
                                 .equ	WAKEUPI	= 4	; 
                                 .equ	EORSMI	= 5	; 
                                 .equ	UPRSMI	= 6	; 
                                 
                                 ; UDIEN - 
                                 .equ	SUSPE	= 0	; 
                                 .equ	SOFE	= 2	; 
                                 .equ	EORSTE	= 3	; 
                                 .equ	WAKEUPE	= 4	; 
                                 .equ	EORSME	= 5	; 
                                 .equ	UPRSME	= 6	; 
                                 
                                 ; UDADDR - 
                                 .equ	UADD0	= 0	; 
                                 .equ	UADD1	= 1	; 
                                 .equ	UADD2	= 2	; 
                                 .equ	UADD3	= 3	; 
                                 .equ	UADD4	= 4	; 
                                 .equ	UADD5	= 5	; 
                                 .equ	UADD6	= 6	; 
                                 .equ	ADDEN	= 7	; 
                                 
                                 ; UDFNUML - 
                                 .equ	FNUM0	= 0	; 
                                 .equ	FNUM1	= 1	; 
                                 .equ	FNUM2	= 2	; 
                                 .equ	FNUM3	= 3	; 
                                 .equ	FNUM4	= 4	; 
                                 .equ	FNUM5	= 5	; 
                                 .equ	FNUM6	= 6	; 
                                 .equ	FNUM7	= 7	; 
                                 
                                 ; UDFNUMH - 
                                 .equ	FNUM8	= 0	; 
                                 .equ	FNUM9	= 1	; 
                                 .equ	FNUM10	= 2	; 
                                 
                                 ; UDMFN - 
                                 .equ	FNCERR	= 4	; 
                                 
                                 ; UEINTX - 
                                 .equ	TXINI	= 0	; 
                                 .equ	STALLEDI	= 1	; 
                                 .equ	RXOUTI	= 2	; 
                                 .equ	RXSTPI	= 3	; 
                                 .equ	NAKOUTI	= 4	; 
                                 .equ	RWAL	= 5	; 
                                 .equ	NAKINI	= 6	; 
                                 .equ	FIFOCON	= 7	; 
                                 
                                 ; UENUM - 
                                 .equ	UENUM_0	= 0	; 
                                 .equ	UENUM_1	= 1	; 
                                 .equ	UENUM_2	= 2	; 
                                 
                                 ; UERST - 
                                 .equ	EPRST0	= 0	; 
                                 .equ	EPRST1	= 1	; 
                                 .equ	EPRST2	= 2	; 
                                 .equ	EPRST3	= 3	; 
                                 .equ	EPRST4	= 4	; 
                                 .equ	EPRST5	= 5	; 
                                 .equ	EPRST6	= 6	; 
                                 
                                 ; UECONX - 
                                 .equ	EPEN	= 0	; 
                                 .equ	RSTDT	= 3	; 
                                 .equ	STALLRQC	= 4	; 
                                 .equ	STALLRQ	= 5	; 
                                 
                                 ; UECFG0X - 
                                 .equ	EPDIR	= 0	; 
                                 .equ	EPTYPE0	= 6	; 
                                 .equ	EPTYPE1	= 7	; 
                                 
                                 ; UECFG1X - 
                                 .equ	ALLOC	= 1	; 
                                 .equ	EPBK0	= 2	; 
                                 .equ	EPBK1	= 3	; 
                                 .equ	EPSIZE0	= 4	; 
                                 .equ	EPSIZE1	= 5	; 
                                 .equ	EPSIZE2	= 6	; 
                                 
                                 ; UESTA0X - 
                                 .equ	NBUSYBK0	= 0	; 
                                 .equ	NBUSYBK1	= 1	; 
                                 .equ	DTSEQ0	= 2	; 
                                 .equ	DTSEQ1	= 3	; 
                                 .equ	UNDERFI	= 5	; 
                                 .equ	OVERFI	= 6	; 
                                 .equ	CFGOK	= 7	; 
                                 
                                 ; UESTA1X - 
                                 .equ	CURRBK0	= 0	; 
                                 .equ	CURRBK1	= 1	; 
                                 .equ	CTRLDIR	= 2	; 
                                 
                                 ; UEIENX - 
                                 .equ	TXINE	= 0	; 
                                 .equ	STALLEDE	= 1	; 
                                 .equ	RXOUTE	= 2	; 
                                 .equ	RXSTPE	= 3	; 
                                 .equ	NAKOUTE	= 4	; 
                                 .equ	NAKINE	= 6	; 
                                 .equ	FLERRE	= 7	; 
                                 
                                 ; UEDATX - 
                                 .equ	DAT0	= 0	; 
                                 .equ	DAT1	= 1	; 
                                 .equ	DAT2	= 2	; 
                                 .equ	DAT3	= 3	; 
                                 .equ	DAT4	= 4	; 
                                 .equ	DAT5	= 5	; 
                                 .equ	DAT6	= 6	; 
                                 .equ	DAT7	= 7	; 
                                 
                                 ; UEBCLX - 
                                 .equ	BYCT0	= 0	; 
                                 .equ	BYCT1	= 1	; 
                                 .equ	BYCT2	= 2	; 
                                 .equ	BYCT3	= 3	; 
                                 .equ	BYCT4	= 4	; 
                                 .equ	BYCT5	= 5	; 
                                 .equ	BYCT6	= 6	; 
                                 .equ	BYCT7	= 7	; 
                                 
                                 ; UEINT - 
                                 .equ	EPINT0	= 0	; 
                                 .equ	EPINT1	= 1	; 
                                 .equ	EPINT2	= 2	; 
                                 .equ	EPINT3	= 3	; 
                                 .equ	EPINT4	= 4	; 
                                 .equ	EPINT5	= 5	; 
                                 .equ	EPINT6	= 6	; 
                                 
                                 ; USBINT - 
                                 .equ	VBUSTI	= 0	; 
                                 
                                 ; USBSTA - 
                                 .equ	VBUS	= 0	; 
                                 .equ	SPEED	= 3	; 
                                 
                                 ; USBCON - USB General Control Register
                                 ;.equ	VBUSTE	= 0	; 
                                 ;.equ	OTGPADE	= 4	; 
                                 ;.equ	FRZCLK	= 5	; 
                                 ;.equ	USBE	= 7	; 
                                 
                                 ; UHWCON - 
                                 .equ	UVREGE	= 0	; 
                                 
                                 ; TWCR - Two-Wire Interface Control
                                 .equ		TWIE	= 0	;
                                 .equ 		TWEN	= 2	;
                                 .equ 		TWWC	= 3	;
                                 .equ 		TWSTO	= 4	;
                                 .equ 		TWSTA	= 5	;
                                 .equ 		TWEA	= 6	;
                                 .equ 		TWINT	= 7	;
                                 
                                 ; TWSR - Two-Wire Status
                                 .equ 		TWPS0	= 0	;
                                 .equ 		TWPS1	= 1	;
                                 
                                 ; TWAR
                                 .equ 		TWGCE	= 0	;
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Oscillator options
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 .equ	HWBE	= 3	; Hardware Boot Enable
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 2560
                                 .equ	RAMEND	= 0x0aff
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x03ff
                                 .equ	EEPROMEND	= 0x03ff
                                 .equ	EEADRBITS	= 10
                                 #pragma AVRPART MEMORY PROG_FLASH 32768
                                 #pragma AVRPART MEMORY EEPROM 1024
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 2560
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x3800
                                 .equ	NRWW_STOP_ADDR	= 0x3fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x37ff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x3f00
                                 .equ	SECONDBOOTSTART	= 0x3e00
                                 .equ	THIRDBOOTSTART	= 0x3c00
                                 .equ	FOURTHBOOTSTART	= 0x3800
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	Reserved1addr	= 0x000a	; Reserved1
                                 .equ	Reserved2addr	= 0x000c	; Reserved2
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	Reserved3addr	= 0x0010	; Reserved3
                                 .equ	PCI0addr	= 0x0012	; Pin Change Interrupt Request 0
                                 .equ	USB_GENaddr	= 0x0014	; USB General Interrupt Request
                                 .equ	USB_COMaddr	= 0x0016	; USB Endpoint/Pipe Interrupt Communication Request
                                 .equ	WDTaddr	= 0x0018	; Watchdog Time-out Interrupt
                                 .equ	Reserved4addr	= 0x001a	; Reserved4
                                 .equ	Reserved5addr	= 0x001c	; Reserved5
                                 .equ	Reserved6addr	= 0x001e	; Reserved6
                                 .equ	ICP1addr	= 0x0020	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0022	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0024	; Timer/Counter1 Compare Match B
                                 .equ	OC1Caddr	= 0x0026	; Timer/Counter1 Compare Match C
                                 .equ	OVF1addr	= 0x0028	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x002a	; Timer/Counter0 Compare Match A
                                 .equ	OC0Baddr	= 0x002c	; Timer/Counter0 Compare Match B
                                 .equ	OVF0addr	= 0x002e	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0030	; SPI Serial Transfer Complete
                                 .equ	URXC1addr	= 0x0032	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x0034	; USART1 Data register Empty
                                 .equ	UTXC1addr	= 0x0036	; USART1, Tx Complete
                                 .equ	ACIaddr	= 0x0038	; Analog Comparator
                                 .equ	ADCCaddr	= 0x003a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x003c	; EEPROM Ready
                                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0044	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x0046	; Timer/Counter3 Overflow
                                 .equ	TWIaddr	= 0x0048	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x004a	; Store Program Memory Read
                                 .equ	OC4Aaddr	= 0x004c	; Timer/Counter4 Compare Match A
                                 .equ	OC4Baddr	= 0x004e	; Timer/Counter4 Compare Match B
                                 .equ	OC4Daddr	= 0x0050	; Timer/Counter4 Compare Match D
                                 .equ	OVF4addr	= 0x0052	; Timer/Counter4 Overflow
                                 .equ	TIMER4_FPFaddr	= 0x0054	; Timer/Counter4 Fault Protection Interrupt
                                 
                                 .equ	INT_VECTORS_SIZE	= 86	; size in words
                                 
                                 #endif  /* _M32U4DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;***********************************************************
                                 ;*
                                 ;*	This is the TRANSMIT skeleton file for Lab 7 of ECE 375
                                 ;*
                                 ;*  	Rock Paper Scissors
                                 ;* 	Requirement:
                                 ;* 	1. USART1 communication
                                 ;* 	2. Timer/counter1 Normal mode to create a 1.5-sec delay
                                 ;***********************************************************
                                 ;*
                                 ;*	 Author: Ian Kiser, Evan Shishido
                                 ;*	   Date: 12/6/2024
                                 ;*
                                 ;***********************************************************
                                 
                                 .include "m32U4def.inc"         ; Include definition file
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32U4.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32U4def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32U4
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32U4
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32U4DEF_INC_
                                 #endif  /* _M32U4DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;***********************************************************
                                 ;*  Internal Register Definitions and Constants
                                 ;***********************************************************
                                 .def    mpr = r16    ; Multi-Purpose Register		
                                 .def	choice_left = r17
                                 .def	choice_right = r18 ;makes sense to store choice values seperately from LCD because it will be easier to send between boards and interract with LCD
                                 .def	data = r19
                                 .def	interrupt_select = r23
                                 ;r20-r22 reserved by LCD driver
                                 
                                 ; Use this signal code between two boards for their game ready
                                 .equ    SendReady = 0b11111111
                                 
                                 ;***********************************************************
                                 ;*  Start of Code Segment
                                 ;***********************************************************
                                 .cseg                           ; Beginning of code segment
                                 
                                 ;***********************************************************
                                 ;*  Interrupt Vectors
                                 ;***********************************************************
                                 .org    $0000                   ; Beginning of IVs
000000 c055                      	    rjmp    INIT            	; Reset interrupt
                                 
                                 .org		$0002 ;int 0, will be tied to PD4, interrupts will need EIMSK, and EICRA/B registers set correctly
                                 		;select choice left
000002 d0ee                      		rcall interrupt_left
000003 9518                      		reti
                                 
                                 .org		$0004 ;int 1, might be tied to PD5, for extra credit
                                 		;select choice right
000004 d0dc                      		rcall interrupt_right
000005 9518                      		reti
                                 
                                 .org	$0028 ;timer counter 1 overflow interrupt
                                 
                                 .org	$0032 ; recieve flag interrupt
000032 d137                      rcall recieve
000033 9518                      reti
                                 
                                 ;.org read interrupt vector on usart 1
                                 
                                 .org    $0056                   ; End of Interrupt Vectors
                                 
                                 ;***********************************************************
                                 ;*  Program Initialization
                                 ;***********************************************************
                                 INIT:
                                 	;Stack Pointer (VERY IMPORTANT!!!!)
000056 ef0f                      	ldi mpr, low(RAMEND) ;retrieve ramend low from program memory
000057 bf0d                      	out SPL, mpr ;load ramend low into stack pointer low via mpr, out is needed as SP(stack pointer) is in io mem
000058 e00a                      	ldi mpr, high(RAMEND);retrieve ramend high from program memory
000059 bf0e                      	out SPH, mpr ;load ramend high into stack pointer low via mpr
                                 	
                                 
                                 
                                 	;I/O Ports
                                 	;port D -> input for button presses, 
00005a e000                      	ldi mpr, 0
00005b b90a                      	out DDRD, mpr ;set portD for input
00005c ef0f                      	ldi mpr, $FF
00005d b90b                      	out PORTD, mpr ;set pull up resistors
                                 
                                 	;port B -> PORTB[4:7] output for LED countdown/timer counter, PB[0:2] used by LCD driver
00005e ef0f                      	ldi mpr, $FF
00005f b904                      	out DDRB, mpr; set PORTB for output 
                                 
                                 	;configure external interrupts to trigger on falling edge ie button pressed, pin shorted to ground, for int0 and int1
                                 	;EICRA gets 0b00001010
000060 e00a                      	ldi mpr, 0b00001010
000061 9300 0069                 	sts EICRA, mpr
                                 
                                 	 
                                 
                                 
                                 
                                 	;USART1
                                 	;Set baudrate at 2400bps -> I believe system clock is 8MHz, therefore UBRR gets 207 by table 18-4 in data sheet
                                 	;Enable receiver and transmitter
                                 	;Set frame format: 8 data bits, 2 stop bits
                                 	;do not use SBI and CBI, and sbis sbic because of fifo 
                                 
                                 	;UCSR1A: bit 7 RXC1(recieve complete) -> 0, bit 6 TXC1 (transmit complete) -> 0, bit 5 UDRE1 (data reg empty) -> 1, error bits[4:2] -> 0
                                 	; bit 1 U2X1 (double transmit speed) -> 0 for normal speed, bit 0 MPCM1 (multi processor communication) -> 0 (do not want to send address info)
                                 
                                 	;UCSR1B: bit 7 RXCIE1 (RX complete interrupt enable) -> set for interrupt, bit 6 TXCIE1 (TX interrupt) -> set for interrupt, bit 5 UDRIE1 (interrupt for UDRE1 flag) -> set for interrupt
                                 	;bit 4 RXEN1 (reciever enable) -> 1, bit 3 TXEN1 (transmit enable) -> 1, bit 2 UCSZ12 (character size) -> 0 for 8 bit characters, bits[1:0] RX/TX 81 (recieve and transmit data bit 8) -> 0 I think since frams will be 8 bit  
                                 	
                                 	;UCSR1C: bits [7:6] UMSEL1 1/0 (usart mode select) -> 00 for asychronous, UPM1 1/0 (parit mode) -> 00 for disabled, bit 3 USBS1 (stop bit select) -> 1 for 2 bit, bits [2:1] UCSZ1 [1:0] (character size) -> 11 for 8 bit,
                                 	; bit 0 UCPOL1 (clock polarity) -> 0 for falling edge
                                 
                                 	;UCSR1D: might need to set bits 1:0 but probably not, they control something called transmission and reception flow control
                                 
                                 	;UCSR1A need not be loaded
                                 	;UCSR1B gets 0b10011000 -> enable read interrupt
                                 	;UCSR1C gets 0b00001110
                                 	;UBRRH1 gets 0b00000000
                                 	;UBRRL1 gets $CF -> 207
                                 
                                 
000063 e908                      	ldi mpr, 0b10011000 ; enable read interrupt
000064 9300 00c9                 	sts UCSR1B, mpr
000066 e00e                      	ldi mpr, 0b00001110
000067 9300 00ca                 	sts UCSR1C, mpr
                                 
000069 e000                      	ldi mpr, 0
00006a 9300 00cd                 	sts UBRR1H, mpr
00006c ec0f                      	ldi mpr, $CF
00006d 9300 00cc                 	sts UBRR1L, mpr
                                 
                                 
                                 	;TIMER/COUNTER1
                                 	;Set Normal mode
                                 	;No need for external pin interrupts -> all OC bits set low, Normal mode -> WGM bits low as well
                                 	;TCCR1A gets 0b00000000, This is initial value by default, no need to load
                                 	;no ICN stabilization, normal mode, and 1/256 prescaling -> TOV flag set about every 1.5 seconds when TCNT initially gets 48E4
                                 	;TCCR1B gets 0b00000010
00006f e000                      	ldi mpr, 0b00000000
000070 9300 0080                 	sts TCCR1A, mpr
000072 e004                      	ldi mpr, 0b00000100
000073 9300 0081                 	sts TCCR1B, mpr
                                 
                                 		;set TCNT1 so that an overflow is 1.5 seconds
000075 e408                      	ldi mpr, $48
000076 9300 0085                 	sts TCNT1H, mpr
000078 ee04                      	ldi mpr, $E4
000079 9300 0084                 	sts TCNT1L, mpr
                                 
                                 
                                 	
                                 
                                 	;Other
00007b d233                      	rcall LCDInit
00007c d254                      	rcall LCDBacklightOn 
00007d d270                      	rcall LCDClr
                                 	
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*  Main Program
                                 ;***********************************************************
                                 MAIN:
                                 
00007e e010                      ldi choice_left, 0
00007f e020                      ldi choice_right, 0
000080 e030                      ldi data, 0
000081 e070                      ldi interrupt_select, 0; interrupts now do choice select
                                 
000082 9478                      sei
                                 ;launch to welcome screen, poll for PD7
                                 ;loop until PD7 pressed
000083 d0f7                      rcall welcome
                                 
                                 ;PD7 pressed
                                 ;begin continuously transmitting ready signal
                                 ;enable recieve interrupt 
                                 ;display ready and waiting screen
                                 transmit_loop:
000084 ef0f                      ldi mpr, SendReady
000085 d0dd                      rcall transmit
000086 3f3f                      cpi data, SendReady
000087 f7e1                      brne transmit_loop
                                 
                                 ;display game start
000088 d265                      rcall LCDClr
                                 
                                 ;simulated button presses
                                 
                                 
000089 d0ca                      rcall game_start
00008a e003                      ldi mpr, 0b00000011
00008b bb0d                      out EIMSK, mpr ;make sure pd4 and pd5 on correct interrupts
                                 ;wait 1.5 seconds
                                 ;start LED timer
00008c d15b                      rcall LED_countdown
                                 
                                 
                                 
                                 ;timer ends
                                 ;disable int 0 (and possibly int 1 if extra credit) in interrupt mask
00008d e000                      ldi mpr, 0
00008e bb0d                      out EIMSK, mpr
00008f d25e                      rcall LCDClr
                                 
                                 
                                 ;choice_left and choice right now hold user choices 
                                 ;store on stack
000090 931f                      push choice_left
000091 932f                      push choice_right;user choices now saved
                                 
000092 d0b9                      rcall send_recieve_choice_left
                                 
000093 d0b0                      rcall send_recieve_choice_right
                                 
                                 
                                 
                                 ;display opponant choices
000094 d117                      rcall load_choice_left
000095 d173                      rcall print_zy_top
000096 d133                      rcall load_choice_right
000097 d187                      rcall print_yz_top
                                 
                                 
                                 ;swap stack values
000098 910f                      pop mpr ;mpr now has user choice right
000099 913f                      pop data ;data now has user choice left
00009a 931f                      push choice_left
00009b 932f                      push choice_right ;opponant choices now on stack
                                 
00009c 2f20                      mov choice_right, mpr 
00009d 2f13                      mov choice_left, data ;choice registers now have user choices
                                 
                                 
                                 
                                 ;display user choices
00009e d10d                      rcall load_choice_left
00009f d19f                      rcall print_zy_bottom
0000a0 d129                      rcall load_choice_right
0000a1 d1b3                      rcall print_yz_bottom
                                 
                                 
                                 
                                 ;start shoot
                                 ;enable EIMSk
0000a2 e001                      ldi mpr, 1 ;defualt shoot select
0000a3 e071                      ldi interrupt_select, 1 ;interrupts now do shoot
0000a4 e003                      ldi mpr, 0b00000011
0000a5 bb0d                      out EIMSK, mpr ;
                                 ;timer start again
                                 
                                 
0000a6 d141                      rcall LED_countdown
                                 
                                 ;timer ends
                                 ;disable EIMSK again
0000a7 e070                      ldi interrupt_select,0
0000a8 bb0d                      out EIMSK, mpr
0000a9 e071                      ldi interrupt_select,1
                                 
                                 ;mpr now holds user shoot value, data holds opponant shoot value
                                 ;do shoot func
0000aa 3001                      cpi mpr, 1
0000ab f011                      breq main_do_shoot_left
0000ac 3002                      cpi mpr, 2
0000ad f011                      breq main_do_shoot_right
                                 
                                 
                                 main_do_shoot_left:
0000ae d05c                      rcall do_shoot_left
0000af c001                      rjmp main_end_do_shoot
                                 
                                 main_do_shoot_right:
0000b0 d07c                      rcall do_shoot_right
                                 
                                 
                                 
                                 main_end_do_shoot:
                                 
                                 
0000b1 d23c                      rcall LCDClr
                                 ;display win/lose screen
0000b2 d003                      rcall calculate_results
                                 ;timer start again
0000b3 d134                      rcall LED_countdown
                                 
                                 ;timer ends
                                 ;restart code
0000b4 d239                      rcall LCDClr
                                 
0000b5 cfc8                      rjmp MAIN
                                 
                                 ;***********************************************************
                                 ;*	Functions and Subroutines
                                 ;***********************************************************
                                 
                                 
                                 ;***********************************************************
                                 ;*	func: calculate results
                                 ;*	desc: based on choice left and choice right displays the correct win or lose screen 
                                 ;***********************************************************
                                 calculate_results:
0000b6 930f                      push mpr
0000b7 931f                      push choice_left
0000b8 932f                      push choice_right
                                 
                                 
0000b9 d0f2                      rcall load_choice_left
0000ba d184                      rcall print_zy_bottom
0000bb d1f3                      rcall LCDInit ;werid LCD driver errors happen without this
                                 
                                 ;left - right
                                 ; 0-0 = 0 tie
                                 ; 0-1 = -1 lose
                                 ; 0-2 = -2 lose < 1
                                 ; 0-3 = -3 lose
                                 ; 1-0 = 1 win
                                 ; 1-1 = 0 tie
                                 ; 1-2 = -1 lose
                                 ; 1-3 = -2 win < 1
                                 ; 2-0 = 2 win < 2
                                 ; 2-1 = 1 win
                                 ; 2-2 = 0 tie
                                 ; 2-3 = -1 lose
                                 ; 3-0 = 3 win
                                 ; 3-1 = 2 lose < 2
                                 ; 3-2 = 1 win
                                 ; 3-3 = 0 tie
                                 
                                 
                                 ;0 is tie
                                 ;left is 0 is lose
                                 ;right is 0 is win 
                                 ; -1 is lose
                                 ; -2 is win (lose case is handled by left is 0 is lose)
                                 ; -3 is lose (redundant since left has to be zero here)
                                 ; 1 is win
                                 ; 2 is lose (win case is handled by right is 0 is win)
                                 ; 3 is win (redundant since right has to be zero here)
                                 
                                 
0000bc 2f01                      mov mpr, choice_left
0000bd 1b02                      sub mpr, choice_right
                                 
0000be 3000                      cpi mpr, 0
0000bf f061                      breq draw
                                 
0000c0 3010                      cpi choice_left, 0
0000c1 f0b1                      breq lose
                                 
0000c2 3020                      cpi choice_right, 0
0000c3 f071                      breq win
                                 
0000c4 3f0f                      cpi mpr, -1
0000c5 f091                      breq lose
                                 
0000c6 3f0e                      cpi mpr, -2
0000c7 f051                      breq win
                                 
0000c8 3001                      cpi mpr, 1
0000c9 f041                      breq win
                                 
0000ca 3002                      cpi mpr, 2
0000cb f061                      breq lose
                                 
                                 
                                 
                                 
                                 
                                 draw:
                                 
0000cc efe8                      ldi ZL, low(str_draw<<1)
0000cd e0f4                      ldi ZH, high(str_draw<<1)
0000ce e0c2                      ldi YL, low(str_draw_end<<1)
0000cf e0d5                      ldi YH, high(str_draw_end<<1)
                                 
0000d0 d138                      rcall print_zy_top
                                 
0000d1 c00b                      rjmp calculate_results_end
                                  
                                 win:
                                 
0000d2 e1e2                      ldi ZL, low(str_win<<1)
0000d3 e0f5                      ldi ZH, high(str_win<<1)
0000d4 e1ca                      ldi YL, low(str_win_end<<1)
0000d5 e0d5                      ldi YH, high(str_win_end<<1)
                                 
0000d6 d132                      rcall print_zy_top
                                 
0000d7 c005                      rjmp calculate_results_end
                                 
                                 lose:
0000d8 e0ea                      ldi ZL, low(str_lose<<1)
0000d9 e0f5                      ldi ZH, high(str_lose<<1)
0000da e1c2                      ldi YL, low(str_lose_end<<1)
0000db e0d5                      ldi YH, high(str_lose_end<<1)
                                 
0000dc d12c                      rcall print_zy_top
                                 
                                 calculate_results_end:
                                 
0000dd 912f                      pop choice_right
0000de 911f                      pop choice_left
0000df 910f                      pop mpr
0000e0 9508                      ret
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: interrupt_right
                                 ;*	desc: interrupt choice on PD4
                                 ;***********************************************************
                                 
                                 interrupt_right:
                                 
0000e1 930f                      push mpr
0000e2 b70f                      in mpr, SREG
0000e3 930f                      push mpr
                                 
0000e4 e000                      ldi mpr, 0
0000e5 bb0d                      out EIMSK, mpr; disable inerrupts while here
                                 
0000e6 ff70                      sbrs interrupt_select, 0 ;if 0 bit is set, we want shoot interrupt
0000e7 d0b5                      rcall select_choice_right
                                 
0000e8 fd70                      sbrc interrupt_select, 0; if 0 bit is clear, we want select choice interrupt
0000e9 d039                      rcall shoot_right
                                 
                                 ;clear external interrupt flag register
0000ea e003                      ldi mpr, 0b00000011 ;clear ints 1 and 2
0000eb bb0c                      out EIFR, mpr
0000ec bb0d                      out EIMSK, mpr
                                 
0000ed 910f                      pop mpr
0000ee bf0f                      out SREG, mpr
0000ef 910f                      pop mpr
0000f0 9508                      ret
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: interrupt_left
                                 ;*	desc: interrupt choice on PD5
                                 ;***********************************************************
                                 
                                 interrupt_left:
0000f1 930f                      push mpr
0000f2 b70f                      in mpr, SREG
0000f3 930f                      push mpr
                                 
0000f4 e000                      ldi mpr, 0
0000f5 bb0d                      out EIMSK, mpr; disable inerrupts while here
                                 
0000f6 ff70                      sbrs interrupt_select, 0 ;if 0 bit is set, we want shoot interrupt
0000f7 d096                      rcall select_choice_left
                                 
0000f8 fd70                      sbrc interrupt_select, 0; if 0 bit is clear, we want select choice interrupt
0000f9 d007                      rcall shoot_left
                                 
                                 ;clear external interrupt flag register
0000fa e003                      ldi mpr, 0b00000011 ;clear ints 1 and 2
0000fb bb0c                      out EIFR, mpr
                                 
0000fc bb0d                      out EIMSK, mpr; reenable interrupts
                                 
0000fd 910f                      pop mpr
0000fe bf0f                      out SREG, mpr
0000ff 910f                      pop mpr
                                 
000100 9508                      ret
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: shoot_left
                                 ;*	desc: loads mpr with correct shoot value then sends via usart, then disables interrupts, so only one shoot allowed
                                 ;***********************************************************
                                 shoot_left:
                                 
                                 
000101 e000                      ldi mpr, 0
000102 bb0d                      out EIMSK, mpr
                                 
                                 
000103 eeea                      ldi ZL, low(str_clear<<1)
000104 e0f4                      ldi ZH, high(str_clear<<1)
                                 
000105 efc2                      ldi YL, low(str_clear_end<<1)
000106 e0d4                      ldi YH, high(str_clear_end<<1)
                                 
000107 d101                      rcall print_zy_top
                                 
                                 
000108 e001                      ldi mpr, 1
000109 d059                      rcall transmit
                                 
00010a 9508                      ret ;save mpr shoot value
                                 
                                 
                                 
                                 ;**************************************************
                                 ;*	func: do_shoot_left
                                 ;*	desc: loads correct values into choice left and choice right, where respectively each is final user choice then final opponant choice
                                 ;**************************************************
                                 do_shoot_left:
                                 
                                 
                                 
                                 ;data now holds shoot value
                                 
                                 
                                 
00010b 3031                      cpi data, 1
00010c f011                      breq do_shoot_left_left
00010d 3032                      cpi data, 2
00010e f039                      breq do_shoot_left_right
                                 
                                 
                                 do_shoot_left_left:
00010f 2f12                      mov choice_left, choice_right
                                 
000110 eeea                      ldi ZL, low(str_clear<<1)
000111 e0f4                      ldi ZH, high(str_clear<<1)
                                 
000112 efc2                      ldi YL, low(str_clear_end<<1)
000113 e0d4                      ldi YH, high(str_clear_end<<1)
                                 
000114 d12a                      rcall print_zy_bottom
                                 
000115 c005                      rjmp do_shoot_left_end_shoot
                                 
                                 do_shoot_left_right:
                                 ;nothing needs to be done, left already holds user choice
                                 
000116 eeea                      ldi ZL, low(str_clear<<1)
000117 e0f4                      ldi ZH, high(str_clear<<1)
                                 
000118 efc2                      ldi YL, low(str_clear_end<<1)
000119 e0d4                      ldi YH, high(str_clear_end<<1)
                                 
00011a d13a                      rcall print_yz_bottom
                                 
                                 do_shoot_left_end_shoot:
                                 
                                 ;opponant choice now shot and final now in choice_left
                                 
                                 
                                 
                                 ;stack has 
                                 ;opponant left
                                 ;opponant right
                                 ;do shoot call low or high
                                 ;do shoot call high or low
                                 
                                 
                                 ;save stack
                                 
00011b 910f                      pop mpr
00011c 913f                      pop data ;return call now saved
00011d 912f                      pop choice_right ; -> this will be saved
00011e 917f                      pop interrupt_select ;-> discard opponant left
00011f e071                      ldi interrupt_select, 1; restore interrupt select
                                 
                                 ;restore stack
000120 933f                      push data
000121 930f                      push mpr
                                 
                                 ;stack now restored without opponant choices
                                 ;choice left has user choice, choice right has opponant choice
                                 
                                 
000122 9508                      ret
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: shoot_right
                                 ;*	desc: loads mpr with correct shoot value then sends via usart, then disables interrupts, so only one shoot allowed
                                 ;***********************************************************
                                 shoot_right:
                                 
                                 
000123 e000                      ldi mpr, 0
000124 bb0d                      out EIMSK, mpr
                                 
                                 
000125 eeea                      ldi ZL, low(str_clear<<1)
000126 e0f4                      ldi ZH, high(str_clear<<1)
                                 
000127 efc2                      ldi YL, low(str_clear_end<<1)
000128 e0d4                      ldi YH, high(str_clear_end<<1)
                                 
000129 d0f5                      rcall print_yz_top
                                 
00012a e002                      ldi mpr, 2
00012b d037                      rcall transmit
                                 
                                 
00012c 9508                      ret ;save mpr shoot value
                                 
                                 
                                 
                                 ;**************************************************
                                 ;*	func: do_shoot_right
                                 ;*	desc: loads correct values into choice left and choice right, where respectively each is final user choice then final opponant choice
                                 ;**************************************************
                                 do_shoot_right:
                                 
                                 ;data now holds shoot value
                                 
                                 
                                 
00012d 3031                      cpi data, 1
00012e f011                      breq do_shoot_right_left
00012f 3032                      cpi data, 2
000130 f039                      breq do_shoot_right_right
                                 
                                 
                                 do_shoot_right_left:
000131 2f12                      mov choice_left, choice_right
                                 
000132 eeea                      ldi ZL, low(str_clear<<1)
000133 e0f4                      ldi ZH, high(str_clear<<1)
                                 
000134 efc2                      ldi YL, low(str_clear_end<<1)
000135 e0d4                      ldi YH, high(str_clear_end<<1)
                                 
000136 d108                      rcall print_zy_bottom
                                 
000137 c005                      rjmp do_shoot_right_end_shoot
                                 
                                 do_shoot_right_right:
                                 ;nothing needs to be done, left already holds user choice
                                 
                                 
000138 eeea                      ldi ZL, low(str_clear<<1)
000139 e0f4                      ldi ZH, high(str_clear<<1)
                                 
00013a efc2                      ldi YL, low(str_clear_end<<1)
00013b e0d4                      ldi YH, high(str_clear_end<<1)
                                 
00013c d118                      rcall print_yz_bottom
                                 
                                 do_shoot_right_end_shoot:
                                 
                                 ;user choice now in choice_left
                                 
                                 
                                 ;stack has 
                                 ;opponant left
                                 ;opponant right
                                 ;do shoot call high or low
                                 ;do shoot call low or high
                                 ;saved mpr
                                 
                                 ;save stack
00013d 910f                      pop mpr
00013e 913f                      pop data ;ret call now saved
00013f 912f                      pop choice_right ; -> this will be discarded
000140 912f                      pop choice_right ; -> discard choice right, save choice left
                                 
                                 ;restore stack
000141 933f                      push data
000142 930f                      push mpr
                                 ;stack now restored without opponant choices
                                 ;choice left has user choice, choice right has opponant choice
                                 
                                 
000143 9508                      ret
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: send_recieve_choice_right
                                 ;*	desc: transmits choice left and waits for verfication of reception
                                 ;***********************************************************
                                 send_recieve_choice_right:
000144 930f                      push mpr
                                 
                                 ;load data with known value
                                 ;load mpr with choice_left
                                 ;call transmit
                                 ;compare data with value
                                 ;if data not value continue otherwise loop
                                 
                                 send_recieve_choice_right_loop:
000145 e830                      ldi data, 0b10000000
000146 2f01                      mov mpr, choice_left
000147 d01b                      rcall transmit
000148 3830                      cpi data, 0b10000000
000149 f3d9                      breq send_recieve_choice_right_loop
                                 
                                 
00014a 910f                      pop mpr
00014b 9508                      ret
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: send_recieve_choice_left
                                 ;*	desc: transmits choice left and waits for verfication of reception
                                 ;***********************************************************
                                 send_recieve_choice_left:
00014c 930f                      push mpr
                                 
                                 ;load data with known value
                                 ;load mpr with choice_left
                                 ;call transmit
                                 ;compare data with value
                                 ;if data not value continue otherwise loop
                                 
                                 send_recieve_choice_left_loop:
00014d e830                      ldi data, 0b10000000
00014e 2f01                      mov mpr, choice_left
00014f d013                      rcall transmit
000150 3830                      cpi data, 0b10000000
000151 f3d9                      breq send_recieve_choice_left_loop
                                 
                                 
000152 910f                      pop mpr
000153 9508                      ret
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: game_start
                                 ;*	desc: display game start and start countdown 
                                 ;***********************************************************
                                 game_start:
000154 93ef                      push ZL
000155 93ff                      push ZH
000156 93cf                      push YL
000157 93df                      push YH
                                 
000158 e5e0                      ldi ZL, low(str_game<<1)
000159 e0f5                      ldi ZH, high(str_game<<1)
00015a e5ca                      ldi YL, low(str_game_end<<1)
00015b e0d5                      ldi YH, high(str_game_end<<1)
00015c d0ac                      rcall print_zy_top
00015d d09f                      rcall timer_1_5
                                 
                                 
00015e 91df                      pop YH
00015f 91cf                      pop YL
000160 91ff                      pop ZH
000161 91ef                      pop ZL
000162 9508                      ret
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: transmit
                                 ;*	desc: transmits mpr to UDR1
                                 ;***********************************************************
                                 transmit:
000163 930f                      push mpr
                                 
000164 d00f                      rcall check_UDR1
000165 9300 00ce                 sts UDR1, mpr
000167 d00c                      rcall check_UDR1
                                 
000168 910f                      pop mpr
000169 9508                      ret
                                 
                                 ;***********************************************************
                                 ;*	Func: recieve
                                 ;*	desc: loads data register with usart reception value
                                 ;***********************************************************
                                 recieve:
00016a 930f                      push mpr
00016b b70f                      in mpr, SREG
00016c 930f                      push mpr
                                 
                                 
00016d 9130 00ce                 lds data, UDR1
00016f d004                      rcall check_UDR1
                                 
                                 
000170 910f                      pop mpr
000171 bf0f                      out SREG, mpr
000172 910f                      pop mpr
000173 9508                      ret
                                 
                                 ;***********************************************************
                                 ;*	Func: check_UDR1
                                 ;*	desc: returns once the UDR1 register has been cleared, uses 
                                 ;***********************************************************
                                 check_UDR1:
000174 930f                      push mpr
                                 
                                 check_UDR1_not_clear:
000175 9100 00c8                 lds mpr, UCSR1A
000177 ff05                      sbrs mpr, 5
000178 f7e1                      brne check_UDR1_not_clear ;if data reg not empty wait for it to be empty
                                 
                                 
                                 
000179 910f                      pop mpr
00017a 9508                      ret
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: welcome
                                 ;*	desc: display welcome screen and poll for PD7, exit when pressed and then released
                                 ;***********************************************************
                                 welcome:
00017b 930f                      push mpr
                                 
                                 
00017c e1ea                      ldi ZL, low(str_welcome1<<1)
00017d e0f5                      ldi ZH, high(str_welcome1<<1)
                                 
00017e e2c2                      ldi YL, low(str_welcome1_end<<1)
00017f e0d5                      ldi YH, high(str_welcome1_end<<1)
                                 
000180 d088                      rcall print_zy_top
                                 
000181 e2e2                      ldi ZL, low(str_welcome2<<1)
000182 e0f5                      ldi ZH, high(str_welcome2<<1)
                                 
000183 e3c2                      ldi YL, low(str_welcome2_end<<1)
000184 e0d5                      ldi YH, high(str_welcome2_end<<1)
                                 
000185 d0b9                      rcall print_zy_bottom
                                 
                                 
                                 welcome_not_pressed:
000186 994f                      sbic PIND, PD7
000187 cffe                      rjmp welcome_not_pressed
                                 ;PD7 is now pressed
000188 0000                      nop
000189 0000                      nop ;avoid some debouncing
                                 welcome_pressed:
00018a 9b4f                      sbis PIND, PD7
00018b cffe                      rjmp welcome_pressed
                                 ;PD7 is now released
                                 
                                 
                                 
00018c 910f                      pop mpr
00018d 9508                      ret
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: select_choice_left
                                 ;*	desc: cycles through choices for rock paper scissors and prints them to the LCD on the left hand side, preserves right hand side of LCD
                                 ;***********************************************************
                                 select_choice_left:
00018e 930f                      push mpr
                                 
                                 ;changes made to choice left will be saved globally
                                 
                                 ;valid choice values include 1,2,3, for rock paper and scissors respectively. 0 will be initialization value so when button is first pressed rock is shown 
                                 ;check if choice left is 10, load with 00 if so
                                 ;otherwise increment choice left
                                 
00018f 3013                      cpi choice_left, 3
000190 f011                      breq select_choice_left_rollover ;if at two do not increment
                                 
000191 9513                      inc choice_left
                                 
000192 c001                      rjmp select_choice_left_chosen ;do not roll over if unneeded 
                                 
                                 select_choice_left_rollover:
000193 e011                      ldi choice_left, 1
                                 
                                 select_choice_left_chosen:
                                 ;load z and y with labels for str clear
                                 ;call zy print function to write spaces to left hand side of LCD without clearing right hand side
                                 ;based on choice left value load Z and Y with appropriate labels for word
                                 ;call zy print function
                                 
000194 eeea                      ldi ZL, low(str_clear<<1)
000195 e0f4                      ldi ZH, high(str_clear<<1)
                                 
000196 efc2                      ldi YL, low(str_clear_end<<1)
000197 e0d4                      ldi YH, high(str_clear_end<<1)
                                 
000198 d0a6                      rcall print_zy_bottom ;write clear string to left side of LCD
000199 d012                      rcall load_choice_left ;load Z and Y registers with correct string lables
00019a d0a4                      rcall print_zy_bottom ;print correct choice of string to LCD
                                 
                                 
00019b 910f                      pop mpr
00019c 9508                      ret
                                 ;end select_choice_left
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: select_choice_right
                                 ;*	desc: cycles through choices for rock paper scissors and prints them to the LCD on the left hand side, preserves right hand side of LCD
                                 ;***********************************************************
                                 select_choice_right:
00019d 930f                      push mpr
                                 
                                 ;changes made to choice left will be saved globally
                                 
                                 ;valid choice values include 1,2,3, for rock paper and scissors respectively. 0 will be initialization value so when button is first pressed rock is shown 
                                 ;check if choice left is 10, load with 00 if so
                                 ;otherwise increment choice left
                                 
00019e 3023                      cpi choice_right, 3
00019f f011                      breq select_choice_right_rollover ;if at two do not increment
                                 
0001a0 9523                      inc choice_right
                                 
0001a1 c001                      rjmp select_choice_right_chosen ;do not roll over if unneeded 
                                 
                                 select_choice_right_rollover:
0001a2 e021                      ldi choice_right, 1
                                 
                                 select_choice_right_chosen:
                                 ;load z and y with labels for str clear
                                 ;call zy print function to write spaces to left hand side of LCD without clearing right hand side
                                 ;based on choice left value load Z and Y with appropriate labels for word
                                 ;call zy print function
                                 
0001a3 eeea                      ldi ZL, low(str_clear<<1)
0001a4 e0f4                      ldi ZH, high(str_clear<<1)
                                 
0001a5 efc2                      ldi YL, low(str_clear_end<<1)
0001a6 e0d4                      ldi YH, high(str_clear_end<<1)
                                 
0001a7 d0ad                      rcall print_yz_bottom ;write clear string to left side of LCD
0001a8 d021                      rcall load_choice_right ;load Z and Y registers with correct string lables
0001a9 d0ab                      rcall print_yz_bottom ;print correct choice of string to LCD
                                 
                                 
                                 
0001aa 910f                      pop mpr
0001ab 9508                      ret
                                 ;end select_choice_right
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: load_choice_left
                                 ;*	desc: loads correct string into Z and Y registers depending on choice left value
                                 ;***********************************************************
                                 load_choice_left:
0001ac 930f                      push mpr
                                 
                                 
0001ad 3010                      cpi choice_left, 0
0001ae f031                      breq load_choice_left_clear
                                 
0001af 3011                      cpi choice_left, 1
0001b0 f049                      breq load_choice_left_rock
                                 
0001b1 3012                      cpi choice_left, 2
0001b2 f061                      breq load_choice_left_paper		;find choice_left value
                                 
0001b3 3013                      cpi choice_left, 3
0001b4 f079                      breq load_choice_left_scissors
                                 
                                 load_choice_left_clear:
                                 
0001b5 eeea                      ldi ZL, low(str_clear<<1)
0001b6 e0f4                      ldi ZH, high(str_clear<<1)
                                 
0001b7 efc2                      ldi YL, low(str_clear_end<<1)
0001b8 e0d4                      ldi YH, high(str_clear_end<<1)
                                 
0001b9 c00e                      rjmp load_choice_left_end
                                 
                                 load_choice_left_rock:
0001ba e5ea                      ldi ZL, low(str_rock<<1)
0001bb e0f5                      ldi ZH, high(str_rock<<1)
                                 
0001bc e5ce                      ldi YL, low(str_rock_end<<1)
0001bd e0d5                      ldi YH, high(str_rock_end<<1)
                                 
0001be c009                      rjmp load_choice_left_end
                                 
                                 load_choice_left_paper:				;load correct string beginning into Z, and end into Y
0001bf efe2                      ldi ZL, low(str_paper<<1)
0001c0 e0f4                      ldi ZH, high(str_paper<<1)
                                 
0001c1 efc8                      ldi YL, low(str_paper_end<<1)
0001c2 e0d4                      ldi YH, high(str_paper_end<<1)
                                 
0001c3 c004                      rjmp load_choice_left_end
                                 
                                 load_choice_left_scissors:
0001c4 e0e2                      ldi ZL, low(str_scissors<<1)
0001c5 e0f5                      ldi ZH, high(str_scissors<<1)
                                 
0001c6 e0ca                      ldi YL, low(str_scissors_end<<1)
0001c7 e0d5                      ldi YH, high(str_scissors_end<<1)
                                 
                                 load_choice_left_end:
0001c8 910f                      pop mpr
0001c9 9508                      ret
                                 ;end load_choice_left
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: load_choice_right
                                 ;*	desc: loads correct string into Z and Y registers depending on choice right value
                                 ;***********************************************************
                                 load_choice_right:
0001ca 930f                      push mpr
                                 
0001cb 3020                      cpi choice_right, 0
0001cc f031                      breq load_choice_right_clear
                                 
0001cd 3021                      cpi choice_right, 1
0001ce f049                      breq load_choice_right_rock
                                 
0001cf 3022                      cpi choice_right, 2
0001d0 f061                      breq load_choice_right_paper		;find choice_left value
                                 
0001d1 3023                      cpi choice_right, 3
0001d2 f079                      breq load_choice_right_scissors
                                 
                                 load_choice_right_clear:
                                 
0001d3 eeea                      ldi ZL, low(str_clear<<1)
0001d4 e0f4                      ldi ZH, high(str_clear<<1)
                                 
0001d5 efc2                      ldi YL, low(str_clear_end<<1)
0001d6 e0d4                      ldi YH, high(str_clear_end<<1)
                                 
0001d7 c00e                      rjmp load_choice_right_end
                                 
                                 load_choice_right_rock:
0001d8 e5ea                      ldi ZL, low(str_rock<<1)
0001d9 e0f5                      ldi ZH, high(str_rock<<1)
                                 
0001da e5ce                      ldi YL, low(str_rock_end<<1)
0001db e0d5                      ldi YH, high(str_rock_end<<1)
                                 
0001dc c009                      rjmp load_choice_right_end
                                 
                                 load_choice_right_paper:				;load correct string beginning into Z, and end into Y
0001dd efe2                      ldi ZL, low(str_paper<<1)
0001de e0f4                      ldi ZH, high(str_paper<<1)
                                 
0001df efc8                      ldi YL, low(str_paper_end<<1)
0001e0 e0d4                      ldi YH, high(str_paper_end<<1)
                                 
0001e1 c004                      rjmp load_choice_right_end
                                 
                                 load_choice_right_scissors:
0001e2 e0e2                      ldi ZL, low(str_scissors<<1)
0001e3 e0f5                      ldi ZH, high(str_scissors<<1)
                                 
0001e4 e0ca                      ldi YL, low(str_scissors_end<<1)
0001e5 e0d5                      ldi YH, high(str_scissors_end<<1)
                                 
                                 load_choice_right_end:
0001e6 910f                      pop mpr
0001e7 9508                      ret
                                 
                                 ;end load_choice_right
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: led_countdown
                                 ;*	desc: enables the timer counter 1 interrupt so that a countdown via PORTB leds occure
                                 ;***********************************************************
                                 led_countdown:
0001e8 930f                      push mpr
                                 
0001e9 b105                      in mpr, PORTB
0001ea 6f00                      ori mpr, 0b11110000
0001eb b905                      out PORTB, mpr ;all led's are now set
                                 
0001ec d010                      rcall timer_1_5 ;wait
0001ed 982c                      cbi PORTB, 4
0001ee d00e                      rcall timer_1_5 ;repeat for other bits
0001ef 982d                      cbi PORTB, 5
0001f0 d00c                      rcall timer_1_5
0001f1 982e                      cbi PORTB, 6
0001f2 d00a                      rcall timer_1_5
0001f3 982f                      cbi PORTB, 7
                                 
0001f4 910f                      pop mpr
0001f5 9508                      ret
                                 ;end led_countdown
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: timer_interrupt
                                 ;*	desc: checks PORTB and tunrs of a light if need be
                                 ;***********************************************************
                                 timer_interrupt:
0001f6 930f                      push mpr
0001f7 b70f                      in mpr, SREG
0001f8 930f                      push mpr
                                 
                                 
                                 
                                 
0001f9 910f                      pop mpr
0001fa bf0f                      out SREG, mpr
0001fb 910f                      pop mpr
0001fc 9508                      ret
                                 
                                 ;***********************************************************
                                 ;*	Func: timer_1_5
                                 ;*	desc: uses timer counter 1 over flow to count 
                                 ;***********************************************************
                                 timer_1_5:
                                 ;push stuff to stack
0001fd 930f                      push mpr
                                 
                                 	;set TCNT1 so that an overflow is 1.5 seconds
0001fe e408                      	ldi mpr, $48
0001ff 9300 0085                 	sts TCNT1H, mpr
000201 ee04                      	ldi mpr, $E4
000202 9300 0084                 	sts TCNT1L, mpr
                                 
                                 	timer_1_5_NoFlag:
000204 9bb0                      sbis TIFR1, 0 ;skip loop if TOV1 is set
000205 cffe                      rjmp timer_1_5_NoFlag
                                 
000206 9ab0                      sbi TIFR1, 0 ;reset TOV1
                                 
000207 910f                      pop mpr
000208 9508                      ret
                                 ;end timer_1_5
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: print_zy_top
                                 ;*	desc: stores string stored in program memory and writes it to the top line of the LCD screen
                                 ;*	REMEMBER: the address stored in z and in y must be initially bit shifted by 1 due to least sig bit being low or high indicator.
                                 ;*	WARNING - assumes Z stores the address of the beginning of the string and Y stores the end of the string to print.
                                 ;***********************************************************
                                 print_zy_top:
000209 930f                      push mpr
00020a 93af                      push XL
00020b 93bf                      push XH
00020c 93ef                      push ZL
00020d 93ff                      push ZH
00020e 93cf                      push YL
00020f 93df                      push YH
                                 
                                 
000210 e0a0                      ldi XL, LOW(lcd_buffer_addr) ;point X to the top line of the LCD buffer address in data memory
000211 e0b1                      ldi XH, HIGH(lcd_buffer_addr)
                                 
                                 print_zy_top_loop:
000212 9105                      lpm mpr, Z+ ;load value stored at the address to the beginning of the string (stored in X) to mpr, then inc X to point to next char. ie. first character of string is loaded into mpr
000213 930d                      st X+, mpr ;Store that character to the beginning of the LCD buffer, then increment to next spot in LCD buffer
                                 
000214 17ec                      cp ZL, YL  ;compare where Z points (current address) to Y (end of string), we only need Low byte since start and end are definitely far enough away to cause roll over errors
000215 f7e1                      brne print_zy_top_loop ;if not at end keep loading LCD buffer
                                 
000216 d0c1                      rcall	LCDWrLn1 ;once done write to LCD
                                 
000217 91df                      pop YH
000218 91cf                      pop YL
000219 91ff                      pop ZH
00021a 91ef                      pop ZL
00021b 91bf                      pop XH
00021c 91af                      pop XL 
00021d 910f                      pop mpr
00021e 9508                      ret
                                 ;end print_zy_top
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: print_yz_top
                                 ;*	desc: stores string stored in program memory and writes it to the top line of the LCD screen on the right
                                 ;*	REMEMBER: the address stored in z and in y must be initially bit shifted by 1 due to least sig bit being low or high indicator. 
                                 ;*	REMEMBER: you must clear line outside of this function to prevent overwriting
                                 ;*	WARNING: assumes Z stores the address of the beginning of the string and Y stores the end of the string to print.
                                 ;***********************************************************
                                 print_yz_top:
00021f 930f                      push mpr
000220 93af                      push XL
000221 93bf                      push XH
000222 93ef                      push ZL
000223 93ff                      push ZH
000224 93cf                      push YL
000225 93df                      push YH
                                 
                                 ;must call lpm on Z, and need to call at end adress so shift Z->Y, and Y->Z for sake of function
000226 2fae                      mov XL, ZL
000227 2fbf                      mov XH, ZH ;X now temporarily holds old Z
                                 
000228 2fec                      mov ZL, YL
000229 2ffd                      mov ZH, YH ;Z now holds old Y 
                                 
00022a 2fca                      mov YL, XL
00022b 2fdb                      mov YH, XH ;Y now holds old Z via X
                                 
00022c e1a0                      ldi XL, LOW(lcd_buffer_addr+16) ;point x to the bottom line of the LCD buffer address in data memory
00022d e0b1                      ldi XH, HIGH(lcd_buffer_addr+16)
                                 
                                 print_yz_top_loop:
00022e 9104                      lpm mpr, Z ;load value stored at the address to the beginning of the string (stored in X) to mpr, then inc X to point to next char. ie. first character of string is loaded into mpr
00022f 930c                      st X, mpr ;Store that character to the beginning of the LCD buffer, then increment to next spot in LCD buffer
                                 
000230 9731                      sbiw ZH:ZL, 1
000231 9711                      sbiw XH:XL, 1
                                 
                                 
000232 17ec                      cp ZL, YL ;compare where Z points (beginning of string) to Y (Current address), we only need Low byte since start and end are definitely not far enough away to cause roll over errors
000233 f7d1                      brne print_yz_top_loop ;if not at end keep loading LCD buffer
                                 
000234 9104                      lpm mpr, Z; store last character (dec YL inside loop triggers reset interrupt for some reason)
000235 930c                      st X, mpr
                                 
000236 d0a1                      rcall	LCDWrLn1 ;once done write to LCD 
                                 
000237 91df                      pop YH
000238 91cf                      pop YL
000239 91ff                      pop ZH
00023a 91ef                      pop ZL
00023b 91bf                      pop XH
00023c 91af                      pop XL 
00023d 910f                      pop mpr
00023e 9508                      ret
                                 ;end print_yz_top
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: print_zy_bottom
                                 ;*	desc: stores string stored in program memory and writes it to the bottom line of the LCD screen on the left
                                 ;*	REMEMBER: the address stored in z and in y must be initially bit shifted by 1 due to least sig bit being low or high indicator. 
                                 ;*	REMEMBER: you must clear line outside of this function to prevent overwriting
                                 ;*	WARNING: assumes Z stores the address of the beginning of the string and Y stores the end of the string to print.
                                 ;***********************************************************
                                 print_zy_bottom:
00023f 930f                      push mpr
000240 93af                      push XL
000241 93bf                      push XH
000242 93ef                      push ZL
000243 93ff                      push ZH
000244 93cf                      push YL
000245 93df                      push YH
                                 
                                 
000246 e1a0                      ldi XL, LOW(lcd_buffer_addr+16) ;point x to the bottom line of the LCD buffer address in data memory
000247 e0b1                      ldi XH, HIGH(lcd_buffer_addr+16)
                                 
                                 print_zy_bottom_left_loop:
000248 9105                      lpm mpr, Z+ ;load value stored at the address to the beginning of the string (stored in X) to mpr, then inc X to point to next char. ie. first character of string is loaded into mpr
000249 930d                      st X+, mpr ;Store that character to the beginning of the LCD buffer, then increment to next spot in LCD buffer
                                 
00024a 17ec                      cp ZL, YL ;compare where Z points (current address) to Y (end of string), we only need Low byte since start and end are definitely not far enough away to cause roll over errors
00024b f7e1                      brne print_zy_bottom_left_loop ;if not at end keep loading LCD buffer
                                 
00024c d096                      rcall	LCDWrLn2 ;once done write to LCD 
                                 
00024d 91df                      pop YH
00024e 91cf                      pop YL
00024f 91ff                      pop ZH
000250 91ef                      pop ZL
000251 91bf                      pop XH
000252 91af                      pop XL 
000253 910f                      pop mpr
000254 9508                      ret
                                 ;end print_zy_bottom
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: print_yz_bottom
                                 ;*	desc: stores string stored in program memory and writes it to the bottom line of the LCD screen on the right
                                 ;*	REMEMBER: the address stored in z and in y must be initially bit shifted by 1 due to least sig bit being low or high indicator. 
                                 ;*	REMEMBER: you must clear line outside of this function to prevent overwriting
                                 ;*	WARNING: assumes Z stores the address of the beginning of the string and Y stores the end of the string to print.
                                 ;***********************************************************
                                 print_yz_bottom:
000255 930f                      push mpr
000256 93af                      push XL
000257 93bf                      push XH
000258 93ef                      push ZL
000259 93ff                      push ZH
00025a 93cf                      push YL
00025b 93df                      push YH
                                 
                                 ;must call lpm on Z, and need to call at end adress so shift Z->Y, and Y->Z for sake of function
00025c 2fae                      mov XL, ZL
00025d 2fbf                      mov XH, ZH ;X now temporarily holds old Z
                                 
00025e 2fec                      mov ZL, YL
00025f 2ffd                      mov ZH, YH ;Z now holds old Y 
                                 
000260 2fca                      mov YL, XL
000261 2fdb                      mov YH, XH ;Y now holds old Z via X
                                 
000262 e2a0                      ldi XL, LOW(lcd_buffer_addr+32) ;point x to the bottom line of the LCD buffer address in data memory
000263 e0b1                      ldi XH, HIGH(lcd_buffer_addr+32)
                                 
                                 print_yz_bottom_loop:
000264 9104                      lpm mpr, Z ;load value stored at the address to the beginning of the string (stored in X) to mpr, then inc X to point to next char. ie. first character of string is loaded into mpr
000265 930c                      st X, mpr ;Store that character to the beginning of the LCD buffer, then increment to next spot in LCD buffer
                                 
000266 9731                      sbiw ZH:ZL, 1
000267 9711                      sbiw XH:XL, 1
                                 
                                 
000268 17ec                      cp ZL, YL ;compare where Z points (beginning of string) to Y (Current address), we only need Low byte since start and end are definitely not far enough away to cause roll over errors
000269 f7d1                      brne print_yz_bottom_loop ;if not at end keep loading LCD buffer
                                 
00026a 9104                      lpm mpr, Z; store last character (dec YL inside loop triggers reset interrupt for some reason)
00026b 930c                      st X, mpr
                                 
00026c d076                      rcall	LCDWrLn2 ;once done write to LCD 
                                 
00026d 91df                      pop YH
00026e 91cf                      pop YL
00026f 91ff                      pop ZH
000270 91ef                      pop ZL
000271 91bf                      pop XH
000272 91af                      pop XL 
000273 910f                      pop mpr
000274 9508                      ret
                                 ;end print_yz_bottom
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Stored Program Data
                                 ;***********************************************************
                                 
                                 ;-----------------------------------------------------------
                                 ; An example of storing a string. Note the labels before and
                                 ; after the .DB directive; these can help to access the data
                                 ;-----------------------------------------------------------
                                 
                                 str_clear:
000275 2020
000276 2020
000277 2020
000278 2020                      .db "        "
                                 str_clear_end:
                                 
                                 str_paper:
000279 6170
00027a 6570
00027b 2072                      .db "paper "
                                 str_paper_end:
                                 
                                 
                                 str_draw:
00027c 6f59
00027d 2075
00027e 7244
00027f 7761
000280 2021                      .db "You Draw! "
                                 str_draw_end:
                                 
                                 
                                 str_scissors:
000281 6373
000282 7369
000283 6f73
000284 2072                      .db "scissor "
                                 str_scissors_end:
                                 
                                 str_lose:
000285 6f59
000286 2075
000287 6f4c
000288 6573                      .db "You Lose"
                                 str_lose_end:
                                 
                                 str_win:
000289 6f59
00028a 2075
00028b 6957
00028c 216e                      .db "You Win!"
                                 str_win_end:
                                 
                                 
                                 
                                 str_welcome1:
00028d 6577
00028e 636c
00028f 6d6f
000290 2065                      .db "welcome "
                                 str_welcome1_end:
                                 
                                 str_welcome2:
000291 6c50
000292 6165
000293 6573
000294 5020
000295 6572
000296 7373
000297 5020
000298 3744                      .db "Please Press PD7"
                                 str_welcome2_end:
                                 
                                 str_start1:
000299 6552
00029a 6461
00029b 2c79
00029c 5720
00029d 6961
00029e 6974
00029f 676e                      .db "Ready, Waiting"
                                 str_start1_end:
                                 
                                 str_start2:
0002a0 6f66
0002a1 2072
0002a2 6874
0002a3 2065
0002a4 706f
0002a5 6f70
0002a6 656e
0002a7 746e                      .db "for the opponent"
                                 str_start2_end:
                                 
                                 str_game:
0002a8 6147
0002a9 656d
0002aa 5320
0002ab 6174
0002ac 7472                      .db "Game Start"
                                 str_game_end:
                                 
                                 
                                 str_rock:
0002ad 6f52
0002ae 6b63                      .db	"Rock"		
                                 str_rock_end:
                                 
                                 ;***********************************************************
                                 ;*	Additional Program Includes
                                 ;***********************************************************
                                 .include "LCDDriver.asm"		; Include the LCD Driver
                                 
                                 ;*	Oregon State University
                                 ;*	ST7565R LCD Driver
                                 ;*	This code configures the graphical LCD and emulates
                                 ;*	the behavior of a 2x16 character display.
                                 ;*
                                 ;*	The LCD has room for 32 characters in total
                                 ;*	(16 on the top and 16 on the bottom).
                                 ;*	The upper 16 characters should be located in SRAM starting at 0x0100.
                                 ;*	The lower 16 characters should be located in SRAM starting at 0x0110.
                                 ;*
                                 ;*	NOTE: Register r16 MUST be named 'mpr' in the Main Code
                                 ;*	Something like this:
                                 ;*	.def	mpr = r16
                                 ;*
                                 ;*	WARNING: Register r20-r22 are reserved and cannot be
                                 ;*		renamed outside of the LCD Driver functions. Doing
                                 ;*		so will damage the functionality of the LCD Driver
                                 ;*
                                 ;*	Acknowledgements: the Bin2ASCII and div10 procedures were written by
                                 ;*	David Zier for a previous board. The code has been retained intact.
                                 ;*
                                 ;*********************************************************************
                                 ;*	Rev	Date		Name			Description
                                 ;*--------------------------------------------------------------------
                                 ;*	-	8/18/22	Justin Goins	Version 1.0
                                 ;*
                                 ;*
                                 ;*********************************************************************
                                 
                                 .include "m32U4def.inc"				; Include definition file
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32U4.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32U4def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32U4
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32U4
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32U4DEF_INC_
                                 #endif  /* _M32U4DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; Register definitions
                                 .def	count = r20			; Character Counter
                                 .def	q = r21			; Quotient for div10
                                 .def	r = r22			; Remander for div10
                                 
                                 ; The following constants are not intended to be modified.
                                 .equ 	lcd_buffer_addr = 0x0100 ; define the SRAM base address of the LCD buffer
                                 
                                 ; This information is gathered from the ST7565R datasheet.
                                 ; define some command patterns
                                 .equ	lcd_c_disp_en = 0b10101110 ; lsb indicates whether the LCD is on (1) or off (0)
                                 .equ	lcd_c_disp_set_start_ln = 0b01000000 ; lower 6 bits indicate the line index (0 - 63)
                                 .equ	lcd_c_disp_set_page_addr = 0b10110000 ; lower 4 bits indicate the page address (page 3 is at top and page 0 is at bottom)
                                 ; together, these commands allow you to specify a column index from (0 - 131):
                                 .equ	lcd_c_disp_set_col_addr_h = 0b00010000 ; lower 4 bits indicate the 4 high bits of the column address
                                 .equ	lcd_c_disp_set_col_addr_l = 0b00000000 ; lower 4 bits indicate the 4 low bits of the column address
                                 .equ	lcd_c_disp_set_invert = 0b10100110 ; lsb indicates whether the LCD is normal (0) or inverted (1)
                                 .equ	lcd_c_disp_fill = 0b10100100 ; lsb indicates whether the LCD is normal (0) or filled with dots (1)
                                 .equ	lcd_c_disp_reset = 0b11100010 ; resets the line/page addresses and other stuff, does not affect data RAM
                                 .equ	lcd_c_disp_set_bias = 0xA2 ; 1/6 bias (in 1/33 duty mode)
                                 .equ	lcd_c_disp_set_scandir = 0b11000000 ; select normal scan direction (most significant bit is placed at top of LCD)
                                 .equ	lcd_c_disp_set_contrast_1 = 0b10000001 ; first we send this command then we pass the value
                                 .equ	lcd_c_disp_set_contrast_2 = 15 ; can select a contrast value between 1 and 63
                                 .equ	lcd_c_disp_set_res_ratio = 0x22 ; see the datasheet
                                 .equ	lcd_c_disp_vreg_on = 0x2F ; enable voltage booster, voltage regulator, and voltage follower
                                 
                                 ; use this command to write into the LCD RAM:
                                 .equ	lcd_c_disp_write = 0b00000000 ; these 8 bits are the data to be placed in the target. 
                                 ; note that the column address is automatically incremented by 1 after each write to the LCD data
                                 
                                 ; everything in this driver file needs to go into the code segment
                                 .cseg
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDInit
                                 ;* Desc:	This function initializes the LCD control pins and
                                 ;*		sets reasonable values for the configuration registers.
                                 ;*****************************************************************
                                 LCDInit:
0002af 930f                      	push	mpr
                                 
                                 	; set MOSI, SCL, and SS as outputs
0002b0 9a22                      	sbi	DDRB, DDB2	; Port B 2
0002b1 9a21                      	sbi	DDRB, DDB1	; Port B 1
0002b2 9a20                      	sbi	DDRB, DDB0	; Port B 0
                                 	; ensure that SS is deactivated (active low)
0002b3 9a28                      	sbi	PORTB, 0
                                 	; set lcd_A0 as output
0002b4 9a81                      	sbi	DDRF, DDF1	; Port F 1
                                 	; enable LCD backlight control
0002b5 9a3f                      	sbi	DDRC, DDC7	; Port C 7
                                 	; set lcd_RST_N as output
0002b6 9a80                      	sbi	DDRF, DDF0	; Port F 0
                                 	; we pull lcd_RST_N low for 1 millisecond
0002b7 9888                      	cbi	PORTF, 0
0002b8 940e 039a                 	call	LCDDelay
0002ba 9a88                      	sbi	PORTF, 0
                                 	; Enable SPI mode 3, master configuration, set clock rate fck/2 using SPI2X
0002bb e50c                      	ldi	mpr, (1<<SPE)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)
0002bc bd0c                      	out	SPCR, mpr
0002bd e001                      	ldi	mpr, (1<<SPI2X)
0002be bd0d                      	out	SPSR, mpr
                                 	; Note: after transmitting a byte, the SPI interrupt flag will
                                 	; be automatically cleared next time we: 1) read SPSR and ALSO 2) access SPDR
                                 
0002bf 9828                      	cbi	PORTB, 0	; activate slave select
                                 	; send a string of initialization commands
0002c0 ea02                      	ldi	mpr, lcd_c_disp_set_bias
0002c1 d0d2                      	rcall	LCD_Internal_WriteCMD
0002c2 ec00                      	ldi	mpr, lcd_c_disp_set_scandir
0002c3 d0d0                      	rcall	LCD_Internal_WriteCMD
0002c4 e801                      	ldi	mpr, lcd_c_disp_set_contrast_1
0002c5 d0ce                      	rcall	LCD_Internal_WriteCMD
0002c6 e00f                      	ldi	mpr, lcd_c_disp_set_contrast_2
0002c7 d0cc                      	rcall	LCD_Internal_WriteCMD
0002c8 e202                      	ldi	mpr, lcd_c_disp_set_res_ratio
0002c9 d0ca                      	rcall	LCD_Internal_WriteCMD
0002ca e20f                      	ldi	mpr, lcd_c_disp_vreg_on
0002cb d0c8                      	rcall	LCD_Internal_WriteCMD
0002cc ea0f                      	ldi	mpr, (lcd_c_disp_en | 1 << 0)
0002cd d0c6                      	rcall	LCD_Internal_WriteCMD
0002ce 9a28                      	sbi	PORTB, 0	; deactivate slave select
                                 
0002cf 910f                      	pop	mpr
0002d0 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDBacklightOn
                                 ;* Desc:	Enables the backlight
                                 ;*****************************************************************
                                 LCDBacklightOn:
0002d1 9a47                      	sbi	PORTC, 7
0002d2 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDBacklightOff
                                 ;* Desc:	Disables the backlight
                                 ;*****************************************************************
                                 LCDBacklightOff:
0002d3 9847                      	cbi	PORTC, 7
0002d4 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDWrite
                                 ;* Desc:	This function writes 32 characters to the LCD screen...
                                 ;*		16 chars on the top line and 16 chars on the bottom line.
                                 ;*****************************************************************
                                 LCDWrite:
                                 	
0002d5 d002                      	rcall	LCDWrLn1
0002d6 d00c                      	rcall	LCDWrLn2
0002d7 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDWrLn1
                                 ;* Desc:	This function writes 16 characters to the top line.
                                 ;*****************************************************************
                                 LCDWrLn1:
0002d8 93bf                      	push	XH
0002d9 93af                      	push	XL
0002da 931f                      	push 	r17
                                 	; r17 specifies the destination bank in LCD RAM
0002db e013                      	ldi	r17, 3
                                 	; point X at the ASCII data
0002dc e0b1                      	ldi	XH, HIGH(lcd_buffer_addr)
0002dd e0a0                      	ldi	XL, LOW(lcd_buffer_addr)
0002de d05c                      	rcall	LCD_Internal_WriteLn
0002df 911f                      	pop	r17
0002e0 91af                      	pop	XL
0002e1 91bf                      	pop	XH
0002e2 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDWrLn2
                                 ;* Desc:	This function writes 16 characters to the bottom line.
                                 ;*****************************************************************
                                 LCDWrLn2:
0002e3 93bf                      	push	XH
0002e4 93af                      	push	XL
0002e5 931f                      	push	 r17
                                 	; r17 specifies the destination bank in LCD RAM
0002e6 e011                      	ldi	r17, 1
                                 	; point X at the ASCII data
0002e7 e0b1                      	ldi	XH, HIGH(lcd_buffer_addr+16)
0002e8 e1a0                      	ldi	XL, LOW(lcd_buffer_addr+16)
0002e9 d051                      	rcall	LCD_Internal_WriteLn
0002ea 911f                      	pop	r17
0002eb 91af                      	pop	XL
0002ec 91bf                      	pop	XH
0002ed 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDClr
                                 ;* Desc:	This function clears the entire LCD screen.
                                 ;*****************************************************************
                                 LCDClr:
0002ee d022                      	rcall	LCDClrLn1
0002ef d027                      	rcall	LCDClrLn2
                                 
0002f0 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	CLRDM1
                                 ;* Desc:	This function clears Data Memory by writing 16 
                                 ;*		consecutive ASCII spaces $20 to the memory at $0100.
                                 ;*****************************************************************
                                 CLRDM1:
                                     ; Set X register points to $0100
0002f1 93bf                      	   push	   XH
0002f2 93af                      	   PUSH	   XL
0002f3 930f                                 push    r16
0002f4 931f                                 push    r17
                                 
0002f5 e0b1                                 ldi     XH, HIGH(lcd_buffer_addr)
0002f6 e0a0                                 ldi     XL, LOW(lcd_buffer_addr)
0002f7 e110                                 ldi     r17, 16
0002f8 e200                                 ldi     r16, ' '
                                    CLRloop1:
0002f9 930d                                 st      X+, r16         ; load data to DM
0002fa 951a                                 dec     r17
0002fb f7e9                                 brne    CLRloop1
                                 
0002fc 911f                      	   pop	   r17
0002fd 910f                      	   pop	   r16
0002fe 91af                      	   pop	   XL
0002ff 91bf                      	   pop	   XH
                                 
000300 9508                                 ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	CLRDM2
                                 ;* Desc:	This function clears Data Memory by writing 16 
                                 ;*		consecutive ASCII spaces $20 to the memory at $0110.
                                 ;*****************************************************************
                                 CLRDM2:
                                     ; Set X register points to $0110
000301 93bf                      	   push	   XH
000302 93af                      	   PUSH	   XL
000303 930f                                 push    r16
000304 931f                                 push    r17
                                 
000305 e0b1                                 ldi     XH, HIGH(lcd_buffer_addr+16)
000306 e1a0                                 ldi     XL, LOW(lcd_buffer_addr+16)
000307 e110                                 ldi     r17, 16
000308 e200                                 ldi     r16, ' '
                                    CLRloop2:
000309 930d                                 st      X+, r16         ; load data to DM
00030a 951a                                 dec     r17
00030b f7e9                                 brne    CLRloop2
                                 
00030c 911f                      	   pop	   r17
00030d 910f                      	   pop	   r16
00030e 91af                      	   pop	   XL
00030f 91bf                      	   pop	   XH
                                 
000310 9508                                 ret
                                 ;*****************************************************************
                                 ;* Func:	LCDClrLn1
                                 ;* Desc:	This function clears the top line of the LCD screen.
                                 ;*****************************************************************
                                 LCDClrLn1:
000311 931f                      	push	 r17
                                 	; r17 specifies the target bank in LCD RAM
000312 e013                      	ldi	r17, 3
000313 d060                      	rcall	LCD_Internal_ClearLn
000314 dfdc                      	rcall	CLRDM1
000315 911f                      	pop	r17
000316 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDClrLn2
                                 ;* Desc:	This function clears the bottom line of the LCD screen.
                                 ;*****************************************************************
                                 LCDClrLn2:
000317 931f                      	push	 r17
                                 	; r17 specifies the target bank in LCD RAM
000318 e011                      	ldi	r17, 1
000319 d05a                      	rcall	LCD_Internal_ClearLn
00031a dfe6                      	rcall	CLRDM2
00031b 911f                      	pop	r17
00031c 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	Bin2ASCII
                                 ;* Desc:	Converts a binary number into an ASCII 
                                 ;*			text string equivalent. 
                                 ;*			- The binary number needs to be in the mpr
                                 ;*			- The Start Address of where the text will
                                 ;*			 	be placed needs to be in the X Register
                                 ;*			- The count of the characters created are 
                                 ;*				added to the count register
                                 ;*****************************************************************
                                 Bin2ASCII:
00031d 930f                      	push	 mpr			; save mpr
00031e 936f                      	push	 r			; save r
00031f 935f                      	push	 q			; save q
000320 93bf                      	push	 XH			; save X-pointer
000321 93af                      	push	 XL			;
                                 
                                 	; Determine the range of mpr
000322 3604                      	cpi	mpr, 100		; is mpr >= 100
000323 f018                      	brlo	 B2A_1			; goto next check
000324 e043                      	ldi	count, 3		; Three chars are written
000325 9613                      	adiw	 XL, 3			; Increment X 3 address spaces
000326 c007                      	rjmp	 B2A_3			; Continue with program
                                 B2A_1:
000327 300a                      	cpi	mpr, 10		; is mpr >= 10
000328 f018                      	brlo	 B2A_2			; Continue with program
000329 e042                      	ldi	count, 2		; Two chars are written
00032a 9612                      	adiw	 XL, 2			; Increment X 2 address spaces
00032b c002                      	rjmp	 B2A_3			; Continue with program
                                 B2A_2:
00032c 9611                      	adiw	 XL, 1			; Increment X 1 address space
00032d e041                      	ldi	count, 1		; One char is written
                                 
                                 B2A_3:
                                 	; Do-While statement that converts Binary to ASCII
00032e d076                      	rcall	div10			; Call the div10 function
00032f e300                      	ldi	mpr, '0'		; Set the base ASCII integer value
000330 0f06                      	add	mpr, r		; Create the ASCII integer value
000331 930e                      	st	-X, mpr		; Load ASCII value to memory
000332 2f05                      	mov	mpr, q		; Set mpr to quotient value
000333 3000                      	cpi	mpr, 0		; does mpr == 0
000334 f7c9                      	brne 	B2A_3			; do while (mpr != 0)
                                 
000335 91af                      	pop	XL			; restore X-pointer
000336 91bf                      	pop	XH			;
000337 915f                      	pop	q			; restore q
000338 916f                      	pop	r			; restore r
000339 910f                      	pop	mpr			; restore mpr
00033a 9508                      	ret				; return from function
                                 
                                 ;*****************************************************************
                                 ;*	The functions below here are intended for internal use only.
                                 ;*****************************************************************
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCD_Internal_WriteLn
                                 ;* Desc:	Sends 16 characters of information to the LCD panel
                                 ;*		This is slightly more complicated than it sounds because the
                                 ;*		characters straddle two banks of the LCD memory.
                                 ;*		X is pointing at the first ASCII character to be displayed.
                                 ;*		r17 holds the index of the destination bank in LCD RAM.
                                 ;*		
                                 ;*****************************************************************
                                 LCD_Internal_WriteLn:
00033b 920f                      	push	 r0
00033c 921f                      	push	 r1
00033d 930f                      	push	 mpr
00033e 932f                      	push	 r18
00033f 933f                      	push	 r19
000340 938f                      	push	 r24
000341 939f                      	push	 r25
000342 93ef                      	push	 ZL
000343 93ff                      	push	 ZH
                                 
                                 	; r25:24 holds a pointer to the base address of the bitmap array
000344 e097                      	ldi	r25, HIGH(FontBitmap << 1);
000345 e986                      	ldi	r24, LOW(FontBitmap << 1);
                                 
000346 9828                      	cbi	PORTB, 0	; activate slave select
                                 
                                 	; use a counter to track if we are on the top chunk or bottom chunk of each char
000347 e022                      	ldi	r18, 2
                                 
                                 LCD_WL_display_bank:
                                 	; set the column to 0
000348 e100                      	ldi	mpr, lcd_c_disp_set_col_addr_h
000349 d04a                      	rcall	LCD_Internal_WriteCMD
00034a e000                      	ldi	mpr, lcd_c_disp_set_col_addr_l
00034b d048                      	rcall	LCD_Internal_WriteCMD
                                 	; we need to select the appropriate page
00034c eb00                      	ldi	mpr, lcd_c_disp_set_page_addr
00034d 2b01                      	or	mpr, r17	; set the lower 4 bits
00034e d045                      	rcall	LCD_Internal_WriteCMD
                                 
00034f e130                      	ldi	r19, 16	; there are 16 characters per line
                                 
                                 LCD_WL_next_char:
                                 	; get ascii code point & determine location of corresponding character bitmap
000350 900d                      	ld	r0, X+	; this should be a value from 0 to 255
000351 e100                      	ldi	mpr, 16	; there are 16 bytes per character
000352 9e00                      	mul	r0, mpr	; determine the byte offset for the desired char
000353 01fc                      	movw	 ZH:ZL, r25:r24	; copy the base address to Z
000354 0de0                      	add	ZL, r0	; finally, compute a pointer to the char bitmap
000355 1df1                      	adc	ZH, r1
                                 
000356 e008                      	ldi	mpr, 8	; there are 8 columns for each character
                                 
                                 	; this is where we display the chunk of character (either a top chunk or bottom chunk)
000357 9004                      	lpm	r0, Z
                                 LCD_WL_next_col:
000358 bc0e                      	out	SPDR, r0
000359 9a89                      	sbi	PORTF, 1	; set lcd_A0 to specify data mode
00035a 9632                      	adiw	 ZH:ZL, 2	; point Z at the next column for this bank
00035b 9004                      	lpm	r0, Z		; this is a sneaky way to save a few clock cycles (since we are waiting for the SPI communication)
                                 LCD_WL_wait_spi:
00035c b41d                      	in	r1, SPSR
00035d fe17                      	sbrs	 r1, SPIF	; wait for SPI to finish
00035e cffd                      	rjmp	 LCD_WL_wait_spi
                                 
                                 	; keep going until we have displayed all the columns for this character
00035f 950a                      	dec	mpr
000360 f7b9                      	brne	 LCD_WL_next_col
                                 
                                 	; move to the next character
000361 953a                      	dec	r19
000362 f769                      	brne	 LCD_WL_next_char
                                 
                                 	; if we are at the end of the line, configure the bank and starting array offset for the bottom half of each char
000363 952a                      	dec	r18		; did we display both banks yet?
000364 f021                      	breq	 LCD_WL_all_done
                                 	; if not, then prepare to display the bottom chunk of each character
000365 951a                      	dec	r17		; decrement the bank number
000366 9750                      	sbiw	 XH:XL, 16	; X needs to point back at the beginning character of the line
000367 9601                      	adiw	 r25:r24, 1	; increment the base address pointer (now it will point to the second chunk of each char)
000368 cfdf                      	rjmp	 LCD_WL_display_bank
                                 
                                 LCD_WL_all_done:
000369 9a28                      	sbi	PORTB, 0	; deactivate slave select
                                 
00036a 91ff                      	pop	ZH
00036b 91ef                      	pop	ZL
00036c 919f                      	pop	r25
00036d 918f                      	pop	r24
00036e 913f                      	pop	r19
00036f 912f                      	pop	r18
000370 910f                      	pop	mpr
000371 901f                      	pop	r1
000372 900f                      	pop	r0
000373 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCD_Internal_ClearLn
                                 ;* Desc:	This function clears two of the LCD memory banks.
                                 ;*		r17 specifies the starting bank to wipe.
                                 ;*****************************************************************
                                 LCD_Internal_ClearLn:
000374 930f                      	push 	mpr
000375 921f                      	push 	r1
000376 932f                      	push	 r18
000377 933f                      	push	 r19
                                 
000378 9828                      	cbi	PORTB, 0	; activate slave select
000379 e032                      	ldi	r19, 2	; we are going to clear two banks
                                 
                                 LCD_CLRLN_clear_bank:
                                 	; set the column to 0
00037a e100                      	ldi	mpr, lcd_c_disp_set_col_addr_h
00037b d018                      	rcall	LCD_Internal_WriteCMD
00037c e000                      	ldi	mpr, lcd_c_disp_set_col_addr_l
00037d d016                      	rcall	LCD_Internal_WriteCMD
                                 	; we need to select the appropriate page
00037e eb00                      	ldi	mpr, lcd_c_disp_set_page_addr
00037f 2b01                      	or	mpr, r17	; configure the lower 4 bits
000380 d013                      	rcall	LCD_Internal_WriteCMD
                                 
000381 e820                      	ldi	r18, 128	; there are 128 columns on the LCD
000382 2700                      	clr	mpr		; we will fill each column with empty dots (i.e. blank space)
000383 9a89                      	sbi	PORTF, 1	; set lcd_A0 to specify data mode
                                 
                                 LCD_CLRLN_write_col:
000384 bd0e                      	out	SPDR, mpr	; send an empty column to the LCD via SPI
                                 LCD_CLRLN_wait_spi:
000385 b41d                      	in	r1, SPSR
000386 fe17                      	sbrs	 r1, SPIF	; wait for SPI to finish
000387 cffd                      	rjmp 	LCD_CLRLN_wait_spi
                                 
000388 952a                      	dec	r18
000389 f7d1                      	brne	LCD_CLRLN_write_col	; cycle through all 128 columns
                                 
                                 	; clear the remaining bank if we haven't done so already
00038a 953a                      	dec	r19
00038b f011                      	breq	LCD_CLRLN_all_done
00038c 951a                      	dec	r17		; decrement the bank index
00038d cfec                      	rjmp	LCD_CLRLN_clear_bank
                                 
                                 LCD_CLRLN_all_done:
00038e 9a28                      	sbi	PORTB, 0	; deactivate slave select	
                                 	
                                 	; pop registers...
00038f 913f                      	pop	r19
000390 912f                      	pop	r18
000391 901f                      	pop	r1
000392 910f                      	pop	mpr
000393 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCD_Internal_WriteCMD
                                 ;* Desc:	Sends the byte in mpr
                                 ;*		If you use this function directly,
                                 ;*		YOU ARE RESPONSIBLE for handling the slave select line!
                                 ;*****************************************************************
                                 LCD_Internal_WriteCMD:
000394 bd0e                      	out	SPDR, mpr	; initiate transmission
000395 9889                      	cbi	PORTF, 1	; clear lcd_A0 to put the lcd into command mode
                                 				; (this just has to be done before the 8th bit
                                 				; is transmitted via SPI)
                                 LCD_IWC_L1:
000396 b50d                      	in	mpr, SPSR
000397 ff07                      	sbrs	 mpr, SPIF	; wait for SPI to finish
000398 cffd                      	rjmp LCD_IWC_L1
000399 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDDelay
                                 ;* Desc:	A wait loop that will consume roughly 1ms
                                 ;*		Note that a CALL takes 4 cycles on top of this delay.
                                 ;*****************************************************************
                                 LCDDelay:
00039a 930f                      	push 	mpr		; 2 cycles
00039b 931f                      	push	 r17		; 2 cycles
00039c e01b                      	ldi	r17, 11	; 1 cycle
                                 LCDDelay_L1:
00039d ef02                      	ldi	mpr, 242	; 1 cycle
                                 LCDDelay_L2:
00039e 950a                      	dec	mpr		; 1 cycle
00039f f7f1                      	brne	LCDDelay_L2	; 2 cycles on branch, 1 if no branch
0003a0 951a                      	dec	r17		; 1 cycle
0003a1 f7d9                      	brne	LCDDelay_L1	; 2 cycles on branch, 1 if no branch
0003a2 911f                      	pop	r17		; 2 cycles
0003a3 910f                      	pop	mpr		; 2 cycles
0003a4 9508                      	ret			; 4 cycles
                                 
                                 ;*****************************************************************
                                 ;* Func:	div10
                                 ;* Desc:	Divides the value in the mpr by 10 and 
                                 ;*			puts the remainder in the 'r' register
                                 ;*			and the quotient in the 'q' register.
                                 ;*	DO NOT modify this function, trust me, it does
                                 ;*	divide by 10 :)  ~DZ		
                                 ;*****************************************************************
                                 div10:
0003a5 920f                      	push	r0		; Save register
                                 
                                 	; q = mpr / 10 = mpr * 0.000110011001101b
0003a6 2f50                      	mov	q, mpr	; q = mpr * 1.0b
0003a7 9556                      	lsr	q		; q >> 2
0003a8 9556                      	lsr	q		; q = mpr * 0.01b
0003a9 0f50                      	add	q, mpr	; q = (q + mpr) >> 1
0003aa 9556                      	lsr	q		; q = mpr * 0.101b
0003ab 0f50                      	add	q, mpr	; q = (q + mpr) >> 3
0003ac 9556                      	lsr	q
0003ad 9556                      	lsr	q
0003ae 9556                      	lsr	q		; q = mpr * 0.001101b
0003af 0f50                      	add	q, mpr	; q = (q + mpr) >> 1
0003b0 9556                      	lsr	q		; q = mpr * 0.1001101b
0003b1 0f50                      	add	q, mpr	; q = (q + mpr) >> 3
0003b2 9556                      	lsr	q				
0003b3 9556                      	lsr	q
0003b4 9556                      	lsr	q		; q = mpr * 0.0011001101b
0003b5 0f50                      	add	q, mpr	; q = (q + mpr) >> 1
0003b6 9556                      	lsr	q		; q = mpr * 0.10011001101b
0003b7 0f50                      	add	q, mpr	; q = (q + mpr) >> 4
0003b8 9556                      	lsr	q
0003b9 9556                      	lsr	q
0003ba 9556                      	lsr	q
0003bb 9556                      	lsr	q		; q = mpr * 0.000110011001101b
                                 
                                 	; compute the remainder as r = i - 10 * q
                                 	; calculate r = q * 10 = q * 1010b
0003bc 2f65                      	mov	r, q		; r = q * 1
0003bd 0f66                      	lsl	r		; r << 2
0003be 0f66                      	lsl	r		; r = q * 100b
0003bf 0f65                      	add	r, q		; r = (r + q) << 1
0003c0 0f66                      	lsl	r		; r = q * 1010b
0003c1 2e06                      	mov	r0, r		; r0 = 10 * q
0003c2 2f60                      	mov	r, mpr	; r = mpr
0003c3 1960                      	sub	r, r0		; r = mpr - 10 * q
                                 
                                 	; Fix any errors that occur
                                 div10_1:
0003c4 306a                      	cpi	r, 10		; Compare with 10
0003c5 f018                      	brlo	 div10_2	; do nothing if r < 10
0003c6 9553                      	inc	q		; fix quotient
0003c7 506a                      	subi	r, 10		; fix remainder
0003c8 cffb                      	rjmp	 div10_1	; Continue until error is corrected
                                 
                                 div10_2:
0003c9 900f                      	pop	r0		; Restore registers
0003ca 9508                      	ret			; Return from function
                                 
                                 ;*********************************************************************
                                 ;*	Bitmap Font Information
                                 ;*	Adapted into assembly code by Justin Goins.
                                 ;*	You can edit characters or add symbols if you choose (by modifying the data below)
                                 ;*	Each character is represented as a 8 x 16 pattern of dots (8 dots wide and 16 dots high).
                                 ;*	This implies that 16 bytes are allocated to represent each character.
                                 ;*
                                 ;*	The character information is arranged so that each line below equates to a single character.
                                 ;*	The first line is ASCII character 0, the next line is ASCII character 1,
                                 ;*	the next line is ASCII character 2, and so on.
                                 ;*	You can assign characters to any index within the extended ASCII range (0 to 255).
                                 ;*	With a bit of experimentation it's possible to define and display emojis (or any other graphical output).
                                 ;*	Be creative and have fun!
                                 ;*
                                 ;*	From original license file:
                                 ;*	Copyright 2011 Suraj N. Kurapati <https://github.com/sunaku/tamzen-font>
                                 ;*	Tamzen font is free.  You are hereby granted permission to use, copy, modify, and distribute it as you see fit.
                                 ;*	Tamzen font is provided "as is" without any express or implied warranty.
                                 ;*********************************************************************
                                 FontBitmap:
0003cb 0000
0003cc f00f
0003cd 1008
0003ce 1008
0003cf 1008
0003d0 1008
0003d1 f00f
0003d2 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x0F, 0xF0, 0x00, 0x00	; U+0000
0003d3 fe03
0003d4 fa7f
0003d5 f683
0003d6 ea83
0003d7 d683
0003d8 aa83
0003d9 567f
0003da fe03                      .DB	0x03, 0xFE, 0x7F, 0xFA, 0x83, 0xF6, 0x83, 0xEA, 0x83, 0xD6, 0x83, 0xAA, 0x7F, 0x56, 0x03, 0xFE	; U+E0A2
0003db 5455
0003dc aaaa
0003dd 5455
0003de aaaa
0003df 5455
0003e0 aaaa
0003e1 5455
0003e2 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; U+2592
0003e3 5455
0003e4 aaaa
0003e5 5455
0003e6 aaaa
0003e7 5455
0003e8 aaaa
0003e9 5455
0003ea aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0003eb 5455
0003ec aaaa
0003ed 5455
0003ee aaaa
0003ef 5455
0003f0 aaaa
0003f1 5455
0003f2 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0003f3 5455
0003f4 aaaa
0003f5 5455
0003f6 aaaa
0003f7 5455
0003f8 aaaa
0003f9 5455
0003fa aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0003fb 5455
0003fc aaaa
0003fd 5455
0003fe aaaa
0003ff 5455
000400 aaaa
000401 5455
000402 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000403 0000
000404 0007
000405 8008
000406 8008
000407 8008
000408 0007
000409 0000
00040a 0000                      .DB	0x00, 0x00, 0x07, 0x00, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00B0
00040b 5455
00040c aaaa
00040d 5455
00040e aaaa
00040f 5455
000410 aaaa
000411 5455
000412 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000413 5455
000414 aaaa
000415 5455
000416 aaaa
000417 5455
000418 aaaa
000419 5455
00041a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00041b 5455
00041c aaaa
00041d 5455
00041e aaaa
00041f 5455
000420 aaaa
000421 5455
000422 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000423 8000
000424 8000
000425 8000
000426 8000
000427 80ff
000428 0000
000429 0000
00042a 0000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2518
00042b 8000
00042c 8000
00042d 8000
00042e 8000
00042f fe00
000430 0000
000431 0000
000432 0000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2510
000433 0000
000434 0000
000435 0000
000436 0000
000437 fe00
000438 8000
000439 8000
00043a 8000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+250C
00043b 0000
00043c 0000
00043d 0000
00043e 0000
00043f 80ff
000440 8000
000441 8000
000442 8000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+2514
000443 8000
000444 8000
000445 8000
000446 8000
000447 feff
000448 8000
000449 8000
00044a 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+253C
00044b 5455
00044c aaaa
00044d 5455
00044e aaaa
00044f 5455
000450 aaaa
000451 5455
000452 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000453 5455
000454 aaaa
000455 5455
000456 aaaa
000457 5455
000458 aaaa
000459 5455
00045a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00045b 8000
00045c 8000
00045d 8000
00045e 8000
00045f 8000
000460 8000
000461 8000
000462 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+2500
000463 5455
000464 aaaa
000465 5455
000466 aaaa
000467 5455
000468 aaaa
000469 5455
00046a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00046b 5455
00046c aaaa
00046d 5455
00046e aaaa
00046f 5455
000470 aaaa
000471 5455
000472 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000473 0000
000474 0000
000475 0000
000476 0000
000477 feff
000478 8000
000479 8000
00047a 8000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+251C
00047b 8000
00047c 8000
00047d 8000
00047e 8000
00047f feff
000480 0000
000481 0000
000482 0000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2524
000483 8000
000484 8000
000485 8000
000486 8000
000487 80ff
000488 8000
000489 8000
00048a 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+2534
00048b 8000
00048c 8000
00048d 8000
00048e 8000
00048f fe00
000490 8000
000491 8000
000492 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+252C
000493 0000
000494 0000
000495 0000
000496 0000
000497 feff
000498 0000
000499 0000
00049a 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2502
00049b 5455
00049c aaaa
00049d 5455
00049e aaaa
00049f 5455
0004a0 aaaa
0004a1 5455
0004a2 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004a3 5455
0004a4 aaaa
0004a5 5455
0004a6 aaaa
0004a7 5455
0004a8 aaaa
0004a9 5455
0004aa aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004ab 5455
0004ac aaaa
0004ad 5455
0004ae aaaa
0004af 5455
0004b0 aaaa
0004b1 5455
0004b2 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004b3 5455
0004b4 aaaa
0004b5 5455
0004b6 aaaa
0004b7 5455
0004b8 aaaa
0004b9 5455
0004ba aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004bb 0000
0004bc 1001
0004bd 2001
0004be e007
0004bf 2009
0004c0 1009
0004c1 1008
0004c2 2004                      .DB	0x00, 0x00, 0x01, 0x10, 0x01, 0x20, 0x07, 0xE0, 0x09, 0x20, 0x09, 0x10, 0x08, 0x10, 0x04, 0x20	; U+00A3
0004c3 5455
0004c4 aaaa
0004c5 5455
0004c6 aaaa
0004c7 5455
0004c8 aaaa
0004c9 5455
0004ca aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004cb 0000
0004cc 0000
0004cd 0000
0004ce 0000
0004cf 0000
0004d0 0000
0004d1 0000
0004d2 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0020
0004d3 0000
0004d4 0000
0004d5 0000
0004d6 301f
0004d7 0000
0004d8 0000
0004d9 0000
0004da 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0021
0004db 0000
0004dc 0000
0004dd 001e
0004de 0000
0004df 0000
0004e0 001e
0004e1 0000
0004e2 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0022
0004e3 0000
0004e4 4002
0004e5 f00f
0004e6 4002
0004e7 4002
0004e8 f00f
0004e9 4002
0004ea 0000                      .DB	0x00, 0x00, 0x02, 0x40, 0x0F, 0xF0, 0x02, 0x40, 0x02, 0x40, 0x0F, 0xF0, 0x02, 0x40, 0x00, 0x00	; U+0023
0004eb 0000
0004ec 0000
0004ed 2006
0004ee 2009
0004ef 3839
0004f0 2009
0004f1 c008
0004f2 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x06, 0x20, 0x09, 0x20, 0x39, 0x38, 0x09, 0x20, 0x08, 0xC0, 0x00, 0x00	; U+0024
0004f3 0000
0004f4 200c
0004f5 4012
0004f6 8012
0004f7 600d
0004f8 9002
0004f9 9004
0004fa 6008                      .DB	0x00, 0x00, 0x0C, 0x20, 0x12, 0x40, 0x12, 0x80, 0x0D, 0x60, 0x02, 0x90, 0x04, 0x90, 0x08, 0x60	; U+0025
0004fb 0000
0004fc e00c
0004fd 1013
0004fe 1013
0004ff 900c
000500 6000
000501 6000
000502 9001                      .DB	0x00, 0x00, 0x0C, 0xE0, 0x13, 0x10, 0x13, 0x10, 0x0C, 0x90, 0x00, 0x60, 0x00, 0x60, 0x01, 0x90	; U+0026
000503 0000
000504 0000
000505 0000
000506 001e
000507 0000
000508 0000
000509 0000
00050a 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0027
00050b 0000
00050c 0000
00050d 0000
00050e e003
00050f 180c
000510 0410
000511 0000
000512 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x0C, 0x18, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00	; U+0028
000513 0000
000514 0000
000515 0410
000516 180c
000517 e003
000518 0000
000519 0000
00051a 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0x0C, 0x18, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0029
00051b 0000
00051c 8000
00051d a002
00051e c001
00051f c001
000520 a002
000521 8000
000522 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x02, 0xA0, 0x01, 0xC0, 0x01, 0xC0, 0x02, 0xA0, 0x00, 0x80, 0x00, 0x00	; U+002A
000523 0000
000524 8000
000525 8000
000526 8000
000527 f007
000528 8000
000529 8000
00052a 8000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x07, 0xF0, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+002B
00052b 0000
00052c 0000
00052d 0000
00052e 3200
00052f 3c00
000530 0000
000531 0000
000532 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+002C
000533 0000
000534 8000
000535 8000
000536 8000
000537 8000
000538 8000
000539 8000
00053a 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00	; U+002D
00053b 0000
00053c 0000
00053d 0000
00053e 3000
00053f 3000
000540 0000
000541 0000
000542 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+002E
000543 0000
000544 0c00
000545 3000
000546 c000
000547 0003
000548 000c
000549 0000
00054a 0000                      .DB	0x00, 0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x03, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00	; U+002F
00054b 0000
00054c e007
00054d 5008
00054e 9008
00054f 1009
000550 100a
000551 e007
000552 0000                      .DB	0x00, 0x00, 0x07, 0xE0, 0x08, 0x50, 0x08, 0x90, 0x09, 0x10, 0x0A, 0x10, 0x07, 0xE0, 0x00, 0x00	; U+0030
000553 0000
000554 0000
000555 1002
000556 1004
000557 f00f
000558 1000
000559 1000
00055a 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x04, 0x10, 0x0F, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+0031
00055b 0000
00055c 1004
00055d 3008
00055e 5008
00055f 9008
000560 1009
000561 1006
000562 0000                      .DB	0x00, 0x00, 0x04, 0x10, 0x08, 0x30, 0x08, 0x50, 0x08, 0x90, 0x09, 0x10, 0x06, 0x10, 0x00, 0x00	; U+0032
000563 0000
000564 2008
000565 1008
000566 1009
000567 100b
000568 100d
000569 e008
00056a 0000                      .DB	0x00, 0x00, 0x08, 0x20, 0x08, 0x10, 0x09, 0x10, 0x0B, 0x10, 0x0D, 0x10, 0x08, 0xE0, 0x00, 0x00	; U+0033
00056b 0000
00056c c000
00056d 4001
00056e 4002
00056f 4004
000570 f00f
000571 4000
000572 0000                      .DB	0x00, 0x00, 0x00, 0xC0, 0x01, 0x40, 0x02, 0x40, 0x04, 0x40, 0x0F, 0xF0, 0x00, 0x40, 0x00, 0x00	; U+0034
000573 0000
000574 200f
000575 1009
000576 1009
000577 1009
000578 1009
000579 e008
00057a 0000                      .DB	0x00, 0x00, 0x0F, 0x20, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0xE0, 0x00, 0x00	; U+0035
00057b 0000
00057c e003
00057d 1005
00057e 1009
00057f 1009
000580 1001
000581 e000
000582 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x05, 0x10, 0x09, 0x10, 0x09, 0x10, 0x01, 0x10, 0x00, 0xE0, 0x00, 0x00	; U+0036
000583 0000
000584 0008
000585 0008
000586 3008
000587 c008
000588 000b
000589 000c
00058a 0000                      .DB	0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x30, 0x08, 0xC0, 0x0B, 0x00, 0x0C, 0x00, 0x00, 0x00	; U+0037
00058b 0000
00058c e006
00058d 1009
00058e 1009
00058f 1009
000590 1009
000591 e006
000592 0000                      .DB	0x00, 0x00, 0x06, 0xE0, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x06, 0xE0, 0x00, 0x00	; U+0038
000593 0000
000594 0007
000595 8008
000596 9008
000597 9008
000598 a008
000599 c007
00059a 0000                      .DB	0x00, 0x00, 0x07, 0x00, 0x08, 0x80, 0x08, 0x90, 0x08, 0x90, 0x08, 0xA0, 0x07, 0xC0, 0x00, 0x00	; U+0039
00059b 0000
00059c 0000
00059d 0000
00059e 3006
00059f 3006
0005a0 0000
0005a1 0000
0005a2 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x30, 0x06, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+003A
0005a3 0000
0005a4 0000
0005a5 0000
0005a6 3206
0005a7 3c06
0005a8 0000
0005a9 0000
0005aa 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x06, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+003B
0005ab 0000
0005ac 0000
0005ad 8000
0005ae 4001
0005af 2002
0005b0 1004
0005b1 0000
0005b2 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00	; U+003C
0005b3 0000
0005b4 4002
0005b5 4002
0005b6 4002
0005b7 4002
0005b8 4002
0005b9 4002
0005ba 0000                      .DB	0x00, 0x00, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x00, 0x00	; U+003D
0005bb 0000
0005bc 0000
0005bd 1004
0005be 2002
0005bf 4001
0005c0 8000
0005c1 0000
0005c2 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00	; U+003E
0005c3 0000
0005c4 0008
0005c5 0010
0005c6 3011
0005c7 0012
0005c8 0014
0005c9 0008
0005ca 0000                      .DB	0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x11, 0x30, 0x12, 0x00, 0x14, 0x00, 0x08, 0x00, 0x00, 0x00	; U+003F
0005cb 0000
0005cc f007
0005cd 0808
0005ce c411
0005cf 2412
0005d0 2412
0005d1 440a
0005d2 e407                      .DB	0x00, 0x00, 0x07, 0xF0, 0x08, 0x08, 0x11, 0xC4, 0x12, 0x24, 0x12, 0x24, 0x0A, 0x44, 0x07, 0xE4	; U+0040
0005d3 0000
0005d4 f003
0005d5 8004
0005d6 8008
0005d7 8008
0005d8 8004
0005d9 f003
0005da 0000                      .DB	0x00, 0x00, 0x03, 0xF0, 0x04, 0x80, 0x08, 0x80, 0x08, 0x80, 0x04, 0x80, 0x03, 0xF0, 0x00, 0x00	; U+0041
0005db 0000
0005dc f00f
0005dd 1009
0005de 1009
0005df 1009
0005e0 1009
0005e1 e006
0005e2 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x06, 0xE0, 0x00, 0x00	; U+0042
0005e3 0000
0005e4 c003
0005e5 2004
0005e6 1008
0005e7 1008
0005e8 1008
0005e9 1008
0005ea 0000                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+0043
0005eb 0000
0005ec f00f
0005ed 1008
0005ee 1008
0005ef 1008
0005f0 2004
0005f1 c003
0005f2 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x04, 0x20, 0x03, 0xC0, 0x00, 0x00	; U+0044
0005f3 0000
0005f4 f00f
0005f5 1009
0005f6 1009
0005f7 1009
0005f8 1009
0005f9 1008
0005fa 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10, 0x00, 0x00	; U+0045
0005fb 0000
0005fc f00f
0005fd 0009
0005fe 0009
0005ff 0009
000600 0009
000601 0008
000602 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00	; U+0046
000603 0000
000604 c003
000605 2004
000606 1008
000607 1008
000608 9008
000609 f008
00060a 0000                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x08, 0x10, 0x08, 0x10, 0x08, 0x90, 0x08, 0xF0, 0x00, 0x00	; U+0047
00060b 0000
00060c f00f
00060d 0001
00060e 0001
00060f 0001
000610 0001
000611 f00f
000612 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x0F, 0xF0, 0x00, 0x00	; U+0048
000613 0000
000614 0000
000615 1008
000616 1008
000617 f00f
000618 1008
000619 1008
00061a 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x08, 0x10, 0x0F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+0049
00061b 0000
00061c 6000
00061d 1000
00061e 1000
00061f 1000
000620 1000
000621 e00f
000622 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+004A
000623 0000
000624 f00f
000625 8001
000626 8001
000627 4002
000628 2004
000629 1008
00062a 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x01, 0x80, 0x01, 0x80, 0x02, 0x40, 0x04, 0x20, 0x08, 0x10, 0x00, 0x00	; U+004B
00062b 0000
00062c f00f
00062d 1000
00062e 1000
00062f 1000
000630 1000
000631 1000
000632 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+004C
000633 0000
000634 f00f
000635 0004
000636 0002
000637 8001
000638 0002
000639 0004
00063a f00f                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x04, 0x00, 0x02, 0x00, 0x01, 0x80, 0x02, 0x00, 0x04, 0x00, 0x0F, 0xF0	; U+004D
00063b 0000
00063c f00f
00063d 0004
00063e 0002
00063f 0001
000640 8000
000641 f00f
000642 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x0F, 0xF0, 0x00, 0x00	; U+004E
000643 0000
000644 e007
000645 1008
000646 1008
000647 1008
000648 1008
000649 e007
00064a 0000                      .DB	0x00, 0x00, 0x07, 0xE0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x07, 0xE0, 0x00, 0x00	; U+004F
00064b 0000
00064c f00f
00064d 8008
00064e 8008
00064f 8008
000650 8008
000651 0007
000652 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x07, 0x00, 0x00, 0x00	; U+0050
000653 0000
000654 e007
000655 1008
000656 1008
000657 1008
000658 1808
000659 e407
00065a 0000                      .DB	0x00, 0x00, 0x07, 0xE0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x18, 0x07, 0xE4, 0x00, 0x00	; U+0051
00065b 0000
00065c f00f
00065d 8008
00065e 8008
00065f c008
000660 a008
000661 1007
000662 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x80, 0x08, 0x80, 0x08, 0xC0, 0x08, 0xA0, 0x07, 0x10, 0x00, 0x00	; U+0052
000663 0000
000664 1006
000665 1009
000666 1009
000667 9008
000668 9008
000669 6008
00066a 0000                      .DB	0x00, 0x00, 0x06, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0x90, 0x08, 0x90, 0x08, 0x60, 0x00, 0x00	; U+0053
00066b 0000
00066c 0008
00066d 0008
00066e 0008
00066f f00f
000670 0008
000671 0008
000672 0008                      .DB	0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x0F, 0xF0, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00	; U+0054
000673 0000
000674 e00f
000675 1000
000676 1000
000677 1000
000678 1000
000679 e00f
00067a 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+0055
00067b 0000
00067c 000f
00067d c000
00067e 3000
00067f 3000
000680 c000
000681 000f
000682 0000                      .DB	0x00, 0x00, 0x0F, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x30, 0x00, 0xC0, 0x0F, 0x00, 0x00, 0x00	; U+0056
000683 0000
000684 f00f
000685 1000
000686 2000
000687 c000
000688 2000
000689 1000
00068a f00f                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x00, 0x10, 0x00, 0x20, 0x00, 0xC0, 0x00, 0x20, 0x00, 0x10, 0x0F, 0xF0	; U+0057
00068b 0000
00068c 300c
00068d 4002
00068e 8001
00068f 8001
000690 4002
000691 300c
000692 0000                      .DB	0x00, 0x00, 0x0C, 0x30, 0x02, 0x40, 0x01, 0x80, 0x01, 0x80, 0x02, 0x40, 0x0C, 0x30, 0x00, 0x00	; U+0058
000693 0000
000694 000c
000695 0002
000696 0001
000697 f000
000698 0001
000699 0002
00069a 000c                      .DB	0x00, 0x00, 0x0C, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x0C, 0x00	; U+0059
00069b 0000
00069c 3008
00069d 5008
00069e 9008
00069f 1009
0006a0 100a
0006a1 100c
0006a2 1008                      .DB	0x00, 0x00, 0x08, 0x30, 0x08, 0x50, 0x08, 0x90, 0x09, 0x10, 0x0A, 0x10, 0x0C, 0x10, 0x08, 0x10	; U+005A
0006a3 0000
0006a4 0000
0006a5 0000
0006a6 fc1f
0006a7 0410
0006a8 0410
0006a9 0410
0006aa 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFC, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x00, 0x00	; U+005B
0006ab 0000
0006ac 000c
0006ad 0003
0006ae c000
0006af 3000
0006b0 0c00
0006b1 0000
0006b2 0000                      .DB	0x00, 0x00, 0x0C, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00	; U+005C
0006b3 0000
0006b4 0410
0006b5 0410
0006b6 0410
0006b7 fc1f
0006b8 0000
0006b9 0000
0006ba 0000                      .DB	0x00, 0x00, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+005D
0006bb 0000
0006bc 0002
0006bd 0004
0006be 0008
0006bf 0004
0006c0 0002
0006c1 0000
0006c2 0000                      .DB	0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00	; U+005E
0006c3 0400
0006c4 0400
0006c5 0400
0006c6 0400
0006c7 0400
0006c8 0400
0006c9 0400
0006ca 0400                      .DB	0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04	; U+005F
0006cb 0000
0006cc 0000
0006cd 0000
0006ce 0010
0006cf 0008
0006d0 0004
0006d1 0000
0006d2 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0060
0006d3 0000
0006d4 6000
0006d5 9002
0006d6 9002
0006d7 9002
0006d8 9002
0006d9 f001
0006da 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+0061
0006db 0000
0006dc f01f
0006dd 1001
0006de 1002
0006df 1002
0006e0 1002
0006e1 e001
0006e2 0000                      .DB	0x00, 0x00, 0x1F, 0xF0, 0x01, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+0062
0006e3 0000
0006e4 e001
0006e5 1002
0006e6 1002
0006e7 1002
0006e8 1002
0006e9 2001
0006ea 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0x20, 0x00, 0x00	; U+0063
0006eb 0000
0006ec e001
0006ed 1002
0006ee 1002
0006ef 1002
0006f0 2002
0006f1 f01f
0006f2 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x20, 0x1F, 0xF0, 0x00, 0x00	; U+0064
0006f3 0000
0006f4 e001
0006f5 9002
0006f6 9002
0006f7 9002
0006f8 9002
0006f9 9001
0006fa 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0x90, 0x00, 0x00	; U+0065
0006fb 0000
0006fc 0002
0006fd 0002
0006fe f00f
0006ff 0012
000700 0012
000701 0012
000702 0000                      .DB	0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0F, 0xF0, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x00, 0x00	; U+0066
000703 0000
000704 e001
000705 1202
000706 1202
000707 1202
000708 1202
000709 fc03
00070a 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x03, 0xFC, 0x00, 0x00	; U+0067
00070b 0000
00070c f01f
00070d 0001
00070e 0002
00070f 0002
000710 0002
000711 f001
000712 0000                      .DB	0x00, 0x00, 0x1F, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0, 0x00, 0x00	; U+0068
000713 0000
000714 0000
000715 1002
000716 1002
000717 f01b
000718 1000
000719 1000
00071a 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x02, 0x10, 0x1B, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+0069
00071b 0000
00071c 0000
00071d 0200
00071e 0202
00071f 0202
000720 fc1b
000721 0000
000722 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x1B, 0xFC, 0x00, 0x00, 0x00, 0x00	; U+006A
000723 0000
000724 f01f
000725 4000
000726 8000
000727 4001
000728 2002
000729 1000
00072a 0000                      .DB	0x00, 0x00, 0x1F, 0xF0, 0x00, 0x40, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x00, 0x10, 0x00, 0x00	; U+006B
00072b 0000
00072c 0010
00072d 0010
00072e e01f
00072f 1000
000730 1000
000731 1000
000732 0000                      .DB	0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x1F, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+006c
000733 0000
000734 f003
000735 0002
000736 0002
000737 f001
000738 0002
000739 0002
00073a f001                      .DB	0x00, 0x00, 0x03, 0xF0, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0	; U+006d
00073b 0000
00073c f003
00073d 0001
00073e 0002
00073f 0002
000740 0002
000741 f001
000742 0000                      .DB	0x00, 0x00, 0x03, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0, 0x00, 0x00	; U+006e
000743 0000
000744 e001
000745 1002
000746 1002
000747 1002
000748 1002
000749 e001
00074a 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+006F
00074b 0000
00074c fe03
00074d 1001
00074e 1002
00074f 1002
000750 1002
000751 e001
000752 0000                      .DB	0x00, 0x00, 0x03, 0xFE, 0x01, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+0070
000753 0000
000754 e001
000755 1002
000756 1002
000757 1002
000758 2002
000759 fe03
00075a 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x20, 0x03, 0xFE, 0x00, 0x00	; U+0071
00075b 0000
00075c f003
00075d 0001
00075e 0002
00075f 0002
000760 0002
000761 0001
000762 0000                      .DB	0x00, 0x00, 0x03, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00	; U+0072
000763 0000
000764 1001
000765 9002
000766 9002
000767 5002
000768 5002
000769 2002
00076a 0000                      .DB	0x00, 0x00, 0x01, 0x10, 0x02, 0x90, 0x02, 0x90, 0x02, 0x50, 0x02, 0x50, 0x02, 0x20, 0x00, 0x00	; U+0073
00076b 0000
00076c 0002
00076d 0002
00076e e00f
00076f 1002
000770 1002
000771 1002
000772 0000                      .DB	0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0F, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x00, 0x00	; U+0074
000773 0000
000774 e003
000775 1000
000776 1000
000777 1000
000778 2000
000779 f003
00077a 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x20, 0x03, 0xF0, 0x00, 0x00	; U+0075
00077b 0000
00077c 0003
00077d c000
00077e 3000
00077f 3000
000780 c000
000781 0003
000782 0000                      .DB	0x00, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x30, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00	; U+0076
000783 0000
000784 e003
000785 1000
000786 1000
000787 e001
000788 1000
000789 1000
00078a e003                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x01, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x03, 0xE0	; U+0077
00078b 0000
00078c 1002
00078d 2001
00078e c000
00078f c000
000790 2001
000791 1002
000792 0000                      .DB	0x00, 0x00, 0x02, 0x10, 0x01, 0x20, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0x20, 0x02, 0x10, 0x00, 0x00	; U+0078
000793 0000
000794 e003
000795 1200
000796 1200
000797 1200
000798 2200
000799 fc03
00079a 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x22, 0x03, 0xFC, 0x00, 0x00	; U+0079
00079b 0000
00079c 1002
00079d 3002
00079e 5002
00079f 9002
0007a0 1003
0007a1 1002
0007a2 0000                      .DB	0x00, 0x00, 0x02, 0x10, 0x02, 0x30, 0x02, 0x50, 0x02, 0x90, 0x03, 0x10, 0x02, 0x10, 0x00, 0x00	; U+007A
0007a3 0000
0007a4 0000
0007a5 8000
0007a6 8000
0007a7 780f
0007a8 0410
0007a9 0410
0007aa 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x0F, 0x78, 0x10, 0x04, 0x10, 0x04, 0x00, 0x00	; U+007B
0007ab 0000
0007ac 0000
0007ad 0000
0007ae 0000
0007af fc3f
0007b0 0000
0007b1 0000
0007b2 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+007C
0007b3 0000
0007b4 0410
0007b5 0410
0007b6 780f
0007b7 8000
0007b8 8000
0007b9 0000
0007ba 0000                      .DB	0x00, 0x00, 0x10, 0x04, 0x10, 0x04, 0x0F, 0x78, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00	; U+007D
0007bb 0000
0007bc 0006
0007bd 0008
0007be 0008
0007bf 0004
0007c0 0002
0007c1 0002
0007c2 000c                      .DB	0x00, 0x00, 0x06, 0x00, 0x08, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0C, 0x00	; U+007E
0007c3 5455
0007c4 aaaa
0007c5 5455
0007c6 aaaa
0007c7 5455
0007c8 aaaa
0007c9 5455
0007ca aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007cb 5455
0007cc aaaa
0007cd 5455
0007ce aaaa
0007cf 5455
0007d0 aaaa
0007d1 5455
0007d2 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007d3 5455
0007d4 aaaa
0007d5 5455
0007d6 aaaa
0007d7 5455
0007d8 aaaa
0007d9 5455
0007da aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007db 5455
0007dc aaaa
0007dd 5455
0007de aaaa
0007df 5455
0007e0 aaaa
0007e1 5455
0007e2 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007e3 5455
0007e4 aaaa
0007e5 5455
0007e6 aaaa
0007e7 5455
0007e8 aaaa
0007e9 5455
0007ea aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007eb 5455
0007ec aaaa
0007ed 5455
0007ee aaaa
0007ef 5455
0007f0 aaaa
0007f1 5455
0007f2 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007f3 5455
0007f4 aaaa
0007f5 5455
0007f6 aaaa
0007f7 5455
0007f8 aaaa
0007f9 5455
0007fa aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007fb 5455
0007fc aaaa
0007fd 5455
0007fe aaaa
0007ff 5455
000800 aaaa
000801 5455
000802 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000803 5455
000804 aaaa
000805 5455
000806 aaaa
000807 5455
000808 aaaa
000809 5455
00080a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00080b 5455
00080c aaaa
00080d 5455
00080e aaaa
00080f 5455
000810 aaaa
000811 5455
000812 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000813 5455
000814 aaaa
000815 5455
000816 aaaa
000817 5455
000818 aaaa
000819 5455
00081a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00081b 5455
00081c aaaa
00081d 5455
00081e aaaa
00081f 5455
000820 aaaa
000821 5455
000822 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000823 5455
000824 aaaa
000825 5455
000826 aaaa
000827 5455
000828 aaaa
000829 5455
00082a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00082b 5455
00082c aaaa
00082d 5455
00082e aaaa
00082f 5455
000830 aaaa
000831 5455
000832 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000833 5455
000834 aaaa
000835 5455
000836 aaaa
000837 5455
000838 aaaa
000839 5455
00083a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00083b 5455
00083c aaaa
00083d 5455
00083e aaaa
00083f 5455
000840 aaaa
000841 5455
000842 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000843 5455
000844 aaaa
000845 5455
000846 aaaa
000847 5455
000848 aaaa
000849 5455
00084a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00084b 5455
00084c aaaa
00084d 5455
00084e aaaa
00084f 5455
000850 aaaa
000851 5455
000852 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000853 5455
000854 aaaa
000855 5455
000856 aaaa
000857 5455
000858 aaaa
000859 5455
00085a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00085b 5455
00085c aaaa
00085d 5455
00085e aaaa
00085f 5455
000860 aaaa
000861 5455
000862 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000863 5455
000864 aaaa
000865 5455
000866 aaaa
000867 5455
000868 aaaa
000869 5455
00086a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00086b 5455
00086c aaaa
00086d 5455
00086e aaaa
00086f 5455
000870 aaaa
000871 5455
000872 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000873 5455
000874 aaaa
000875 5455
000876 aaaa
000877 5455
000878 aaaa
000879 5455
00087a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00087b 5455
00087c aaaa
00087d 5455
00087e aaaa
00087f 5455
000880 aaaa
000881 5455
000882 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000883 5455
000884 aaaa
000885 5455
000886 aaaa
000887 5455
000888 aaaa
000889 5455
00088a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00088b 5455
00088c aaaa
00088d 5455
00088e aaaa
00088f 5455
000890 aaaa
000891 5455
000892 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000893 5455
000894 aaaa
000895 5455
000896 aaaa
000897 5455
000898 aaaa
000899 5455
00089a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00089b 5455
00089c aaaa
00089d 5455
00089e aaaa
00089f 5455
0008a0 aaaa
0008a1 5455
0008a2 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008a3 5455
0008a4 aaaa
0008a5 5455
0008a6 aaaa
0008a7 5455
0008a8 aaaa
0008a9 5455
0008aa aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008ab 5455
0008ac aaaa
0008ad 5455
0008ae aaaa
0008af 5455
0008b0 aaaa
0008b1 5455
0008b2 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008b3 5455
0008b4 aaaa
0008b5 5455
0008b6 aaaa
0008b7 5455
0008b8 aaaa
0008b9 5455
0008ba aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008bb 5455
0008bc aaaa
0008bd 5455
0008be aaaa
0008bf 5455
0008c0 aaaa
0008c1 5455
0008c2 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008c3 5455
0008c4 aaaa
0008c5 5455
0008c6 aaaa
0008c7 5455
0008c8 aaaa
0008c9 5455
0008ca aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008cb 0000
0008cc 0000
0008cd 0000
0008ce 0000
0008cf 0000
0008d0 0000
0008d1 0000
0008d2 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A0
0008d3 0000
0008d4 0000
0008d5 0000
0008d6 3e03
0008d7 0000
0008d8 0000
0008d9 0000
0008da 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A1
0008db 0000
0008dc c003
0008dd 2004
0008de 2004
0008df f81f
0008e0 2004
0008e1 2004
0008e2 4002                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x04, 0x20, 0x1F, 0xF8, 0x04, 0x20, 0x04, 0x20, 0x02, 0x40	; U+00A2
0008e3 0000
0008e4 1001
0008e5 2001
0008e6 e007
0008e7 2009
0008e8 1009
0008e9 1008
0008ea 2004                      .DB	0x00, 0x00, 0x01, 0x10, 0x01, 0x20, 0x07, 0xE0, 0x09, 0x20, 0x09, 0x10, 0x08, 0x10, 0x04, 0x20	; U+00A3
0008eb 0000
0008ec 2004
0008ed c003
0008ee 4002
0008ef 4002
0008f0 c003
0008f1 2004
0008f2 0000                      .DB	0x00, 0x00, 0x04, 0x20, 0x03, 0xC0, 0x02, 0x40, 0x02, 0x40, 0x03, 0xC0, 0x04, 0x20, 0x00, 0x00	; U+00A4
0008f3 0000
0008f4 0008
0008f5 4005
0008f6 4003
0008f7 f001
0008f8 4003
0008f9 4005
0008fa 0008                      .DB	0x00, 0x00, 0x08, 0x00, 0x05, 0x40, 0x03, 0x40, 0x01, 0xF0, 0x03, 0x40, 0x05, 0x40, 0x08, 0x00	; U+00A5
0008fb 0000
0008fc 0000
0008fd 0000
0008fe 0000
0008ff 3c0f
000900 0000
000901 0000
000902 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A6
000903 5455
000904 aaaa
000905 5455
000906 aaaa
000907 5455
000908 aaaa
000909 5455
00090a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00090b 0000
00090c 0000
00090d 0060
00090e 0000
00090f 0000
000910 0060
000911 0000
000912 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A8
000913 0000
000914 c003
000915 2004
000916 9009
000917 500a
000918 500a
000919 2004
00091a c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x09, 0x90, 0x0A, 0x50, 0x0A, 0x50, 0x04, 0x20, 0x03, 0xC0	; U+00A9
00091b 5455
00091c aaaa
00091d 5455
00091e aaaa
00091f 5455
000920 aaaa
000921 5455
000922 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000923 0000
000924 8000
000925 4001
000926 2002
000927 9004
000928 4001
000929 2002
00092a 1004                      .DB	0x00, 0x00, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x90, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10	; U+00AB
00092b 5455
00092c aaaa
00092d 5455
00092e aaaa
00092f 5455
000930 aaaa
000931 5455
000932 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000933 0000
000934 8000
000935 8000
000936 8000
000937 8000
000938 8000
000939 8000
00093a 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00	; U+00AD
00093b 5455
00093c aaaa
00093d 5455
00093e aaaa
00093f 5455
000940 aaaa
000941 5455
000942 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000943 5455
000944 aaaa
000945 5455
000946 aaaa
000947 5455
000948 aaaa
000949 5455
00094a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00094b 0000
00094c 0007
00094d 8008
00094e 8008
00094f 8008
000950 0007
000951 0000
000952 0000                      .DB	0x00, 0x00, 0x07, 0x00, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00B0
000953 5455
000954 aaaa
000955 5455
000956 aaaa
000957 5455
000958 aaaa
000959 5455
00095a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00095b 5455
00095c aaaa
00095d 5455
00095e aaaa
00095f 5455
000960 aaaa
000961 5455
000962 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000963 5455
000964 aaaa
000965 5455
000966 aaaa
000967 5455
000968 aaaa
000969 5455
00096a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00096b 5455
00096c aaaa
00096d 5455
00096e aaaa
00096f 5455
000970 aaaa
000971 5455
000972 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000973 5455
000974 aaaa
000975 5455
000976 aaaa
000977 5455
000978 aaaa
000979 5455
00097a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00097b 5455
00097c aaaa
00097d 5455
00097e aaaa
00097f 5455
000980 aaaa
000981 5455
000982 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000983 5455
000984 aaaa
000985 5455
000986 aaaa
000987 5455
000988 aaaa
000989 5455
00098a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00098b 0000
00098c 0000
00098d 0200
00098e 0200
00098f 0c00
000990 0000
000991 0000
000992 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00B8
000993 5455
000994 aaaa
000995 5455
000996 aaaa
000997 5455
000998 aaaa
000999 5455
00099a aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
00099b 5455
00099c aaaa
00099d 5455
00099e aaaa
00099f 5455
0009a0 aaaa
0009a1 5455
0009a2 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009a3 0000
0009a4 1004
0009a5 2002
0009a6 4001
0009a7 9004
0009a8 2002
0009a9 4001
0009aa 8000                      .DB	0x00, 0x00, 0x04, 0x10, 0x02, 0x20, 0x01, 0x40, 0x04, 0x90, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80	; U+00BB
0009ab 5455
0009ac aaaa
0009ad 5455
0009ae aaaa
0009af 5455
0009b0 aaaa
0009b1 5455
0009b2 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009b3 5455
0009b4 aaaa
0009b5 5455
0009b6 aaaa
0009b7 5455
0009b8 aaaa
0009b9 5455
0009ba aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009bb 5455
0009bc aaaa
0009bd 5455
0009be aaaa
0009bf 5455
0009c0 aaaa
0009c1 5455
0009c2 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009c3 0000
0009c4 0000
0009c5 0c00
0009c6 1200
0009c7 2203
0009c8 0200
0009c9 0400
0009ca 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x12, 0x03, 0x22, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00	; U+00BF
0009cb 0000
0009cc 7000
0009cd c043
0009ce 402c
0009cf 400c
0009d0 c003
0009d1 7000
0009d2 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x43, 0xC0, 0x2C, 0x40, 0x0C, 0x40, 0x03, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C0
0009d3 0000
0009d4 7000
0009d5 c003
0009d6 400c
0009d7 402c
0009d8 c043
0009d9 7000
0009da 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x03, 0xC0, 0x0C, 0x40, 0x2C, 0x40, 0x43, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C1
0009db 0000
0009dc 7000
0009dd c023
0009de 404c
0009df 404c
0009e0 c023
0009e1 7000
0009e2 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x23, 0xC0, 0x4C, 0x40, 0x4C, 0x40, 0x23, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C2
0009e3 0000
0009e4 7020
0009e5 c043
0009e6 404c
0009e7 402c
0009e8 c023
0009e9 7040
0009ea 0000                      .DB	0x00, 0x00, 0x20, 0x70, 0x43, 0xC0, 0x4C, 0x40, 0x2C, 0x40, 0x23, 0xC0, 0x40, 0x70, 0x00, 0x00	; U+00C3
0009eb 0000
0009ec 7000
0009ed c063
0009ee 400c
0009ef 400c
0009f0 c063
0009f1 7000
0009f2 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x63, 0xC0, 0x0C, 0x40, 0x0C, 0x40, 0x63, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C4
0009f3 0000
0009f4 7000
0009f5 c033
0009f6 404c
0009f7 404c
0009f8 c033
0009f9 7000
0009fa 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x33, 0xC0, 0x4C, 0x40, 0x4C, 0x40, 0x33, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C5
0009fb 0000
0009fc 7000
0009fd c003
0009fe 400c
0009ff f00f
000a00 1009
000a01 1009
000a02 1008                      .DB	0x00, 0x00, 0x00, 0x70, 0x03, 0xC0, 0x0C, 0x40, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10	; U+00C6
000a03 0000
000a04 c003
000a05 2204
000a06 1208
000a07 1c08
000a08 1008
000a09 1008
000a0a 0000                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x22, 0x08, 0x12, 0x08, 0x1C, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00C7
000a0b 0000
000a0c f00f
000a0d 1049
000a0e 1029
000a0f 1009
000a10 1009
000a11 1008
000a12 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x49, 0x10, 0x29, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00C8
000a13 0000
000a14 f00f
000a15 1009
000a16 1009
000a17 1029
000a18 1049
000a19 1008
000a1a 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x29, 0x10, 0x49, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00C9
000a1b 0000
000a1c f00f
000a1d 1029
000a1e 1049
000a1f 1049
000a20 1029
000a21 1008
000a22 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x29, 0x10, 0x49, 0x10, 0x49, 0x10, 0x29, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CA
000a23 0000
000a24 f00f
000a25 1069
000a26 1009
000a27 1009
000a28 1069
000a29 1008
000a2a 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x69, 0x10, 0x09, 0x10, 0x09, 0x10, 0x69, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CB
000a2b 0000
000a2c 0000
000a2d 1008
000a2e 1048
000a2f f02f
000a30 1008
000a31 1008
000a32 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x48, 0x10, 0x2F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CC
000a33 0000
000a34 0000
000a35 1008
000a36 1008
000a37 f02f
000a38 1048
000a39 1008
000a3a 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x08, 0x10, 0x2F, 0xF0, 0x48, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CD
000a3b 0000
000a3c 0000
000a3d 1008
000a3e 1028
000a3f f04f
000a40 1028
000a41 1008
000a42 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x28, 0x10, 0x4F, 0xF0, 0x28, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CE
000a43 0000
000a44 0000
000a45 1008
000a46 1068
000a47 f00f
000a48 1068
000a49 1008
000a4a 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x68, 0x10, 0x0F, 0xF0, 0x68, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CF
000a4b 0000
000a4c 0001
000a4d f00f
000a4e 1009
000a4f 1009
000a50 1008
000a51 2004
000a52 c003                      .DB	0x00, 0x00, 0x01, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D0
000a53 0000
000a54 f02f
000a55 0044
000a56 0042
000a57 0021
000a58 8020
000a59 f04f
000a5a 0000                      .DB	0x00, 0x00, 0x2F, 0xF0, 0x44, 0x00, 0x42, 0x00, 0x21, 0x00, 0x20, 0x80, 0x4F, 0xF0, 0x00, 0x00	; U+00D1
000a5b 0000
000a5c c003
000a5d 2004
000a5e 1048
000a5f 1028
000a60 1008
000a61 2004
000a62 c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x48, 0x10, 0x28, 0x10, 0x08, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D2
000a63 0000
000a64 c003
000a65 2004
000a66 1008
000a67 1028
000a68 1048
000a69 2004
000a6a c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x08, 0x10, 0x28, 0x10, 0x48, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D3
000a6b 0000
000a6c c003
000a6d 2004
000a6e 1028
000a6f 1048
000a70 1028
000a71 2004
000a72 c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x28, 0x10, 0x48, 0x10, 0x28, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D4
000a73 0000
000a74 c003
000a75 2024
000a76 1048
000a77 1048
000a78 1028
000a79 2024
000a7a c043                      .DB	0x00, 0x00, 0x03, 0xC0, 0x24, 0x20, 0x48, 0x10, 0x48, 0x10, 0x28, 0x10, 0x24, 0x20, 0x43, 0xC0	; U+00D5
000a7b 0000
000a7c c003
000a7d 2064
000a7e 1008
000a7f 1008
000a80 1008
000a81 2064
000a82 c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x64, 0x20, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x64, 0x20, 0x03, 0xC0	; U+00D6
000a83 0000
000a84 0000
000a85 2002
000a86 4001
000a87 8000
000a88 4001
000a89 2002
000a8a 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x00, 0x00	; U+00D7
000a8b 0000
000a8c c803
000a8d 3004
000a8e 5008
000a8f 9009
000a90 100a
000a91 200c
000a92 c013                      .DB	0x00, 0x00, 0x03, 0xC8, 0x04, 0x30, 0x08, 0x50, 0x09, 0x90, 0x0A, 0x10, 0x0C, 0x20, 0x13, 0xC0	; U+00D8
000a93 0000
000a94 e00f
000a95 1040
000a96 1020
000a97 1000
000a98 1000
000a99 e00f
000a9a 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x40, 0x10, 0x20, 0x10, 0x00, 0x10, 0x00, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00D9
000a9b 0000
000a9c e00f
000a9d 1000
000a9e 1000
000a9f 1020
000aa0 1040
000aa1 e00f
000aa2 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x20, 0x10, 0x40, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00DA
000aa3 0000
000aa4 e00f
000aa5 1020
000aa6 1040
000aa7 1040
000aa8 1020
000aa9 e00f
000aaa 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x20, 0x10, 0x40, 0x10, 0x40, 0x10, 0x20, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00DB
000aab 0000
000aac e00f
000aad 1060
000aae 1000
000aaf 1000
000ab0 1060
000ab1 e00f
000ab2 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x60, 0x10, 0x00, 0x10, 0x00, 0x10, 0x60, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00DC
000ab3 0000
000ab4 000c
000ab5 0062
000ab6 0001
000ab7 f000
000ab8 0001
000ab9 0062
000aba 000c                      .DB	0x00, 0x00, 0x0C, 0x00, 0x62, 0x00, 0x01, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x62, 0x00, 0x0C, 0x00	; U+00DD
000abb 0000
000abc f00f
000abd 2004
000abe 2004
000abf 2004
000ac0 2004
000ac1 c003
000ac2 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x03, 0xC0, 0x00, 0x00	; U+00DE
000ac3 0000
000ac4 f007
000ac5 0008
000ac6 0008
000ac7 1009
000ac8 100b
000ac9 e004
000aca 0000                      .DB	0x00, 0x00, 0x07, 0xF0, 0x08, 0x00, 0x08, 0x00, 0x09, 0x10, 0x0B, 0x10, 0x04, 0xE0, 0x00, 0x00	; U+00DF
000acb 0000
000acc 6000
000acd 9012
000ace 900a
000acf 9002
000ad0 9002
000ad1 f001
000ad2 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x12, 0x90, 0x0A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E0
000ad3 0000
000ad4 6000
000ad5 9002
000ad6 9002
000ad7 900a
000ad8 9012
000ad9 f001
000ada 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x02, 0x90, 0x02, 0x90, 0x0A, 0x90, 0x12, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E1
000adb 0000
000adc 6000
000add 900a
000ade 9012
000adf 9012
000ae0 900a
000ae1 f001
000ae2 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x0A, 0x90, 0x12, 0x90, 0x12, 0x90, 0x0A, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E2
000ae3 0000
000ae4 6008
000ae5 9012
000ae6 9012
000ae7 900a
000ae8 900a
000ae9 f011
000aea 0000                      .DB	0x00, 0x00, 0x08, 0x60, 0x12, 0x90, 0x12, 0x90, 0x0A, 0x90, 0x0A, 0x90, 0x11, 0xF0, 0x00, 0x00	; U+00E3
000aeb 0000
000aec 6000
000aed 901a
000aee 9002
000aef 9002
000af0 901a
000af1 f001
000af2 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x1A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x1A, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E4
000af3 0000
000af4 6000
000af5 9032
000af6 904a
000af7 904a
000af8 9032
000af9 f001
000afa 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x32, 0x90, 0x4A, 0x90, 0x4A, 0x90, 0x32, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E5
000afb 0000
000afc 6000
000afd 9002
000afe 9002
000aff e001
000b00 9002
000b01 9002
000b02 9001                      .DB	0x00, 0x00, 0x00, 0x60, 0x02, 0x90, 0x02, 0x90, 0x01, 0xE0, 0x02, 0x90, 0x02, 0x90, 0x01, 0x90	; U+00E6
000b03 0000
000b04 e001
000b05 1202
000b06 1202
000b07 1c02
000b08 1002
000b09 2001
000b0a 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x12, 0x02, 0x12, 0x02, 0x1C, 0x02, 0x10, 0x01, 0x20, 0x00, 0x00	; U+00E7
000b0b 0000
000b0c e001
000b0d 9012
000b0e 900a
000b0f 9002
000b10 9002
000b11 9001
000b12 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x12, 0x90, 0x0A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00E8
000b13 0000
000b14 e001
000b15 9002
000b16 9002
000b17 900a
000b18 9012
000b19 9001
000b1a 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x90, 0x02, 0x90, 0x0A, 0x90, 0x12, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00E9
000b1b 0000
000b1c e001
000b1d 900a
000b1e 9012
000b1f 9012
000b20 900a
000b21 9001
000b22 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x0A, 0x90, 0x12, 0x90, 0x12, 0x90, 0x0A, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00EA
000b23 0000
000b24 e001
000b25 901a
000b26 9002
000b27 9002
000b28 901a
000b29 9001
000b2a 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x1A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x1A, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00EB
000b2b 0000
000b2c 0000
000b2d 1012
000b2e 100a
000b2f f003
000b30 1000
000b31 1000
000b32 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x12, 0x10, 0x0A, 0x10, 0x03, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00EC
000b33 0000
000b34 0000
000b35 1002
000b36 1002
000b37 f00b
000b38 1010
000b39 1000
000b3a 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x02, 0x10, 0x0B, 0xF0, 0x10, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00ED
000b3b 0000
000b3c 0000
000b3d 100a
000b3e 1012
000b3f f013
000b40 1008
000b41 1000
000b42 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x0A, 0x10, 0x12, 0x10, 0x13, 0xF0, 0x08, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00EE
000b43 0000
000b44 0000
000b45 101a
000b46 1002
000b47 f003
000b48 1018
000b49 1000
000b4a 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x1A, 0x10, 0x02, 0x10, 0x03, 0xF0, 0x18, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00EF
000b4b 0000
000b4c e001
000b4d 100a
000b4e 102a
000b4f 101a
000b50 1016
000b51 e021
000b52 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x0A, 0x10, 0x2A, 0x10, 0x1A, 0x10, 0x16, 0x10, 0x21, 0xE0, 0x00, 0x00	; U+00F0
000b53 0000
000b54 f00b
000b55 0012
000b56 0012
000b57 000a
000b58 000a
000b59 f011
000b5a 0000                      .DB	0x00, 0x00, 0x0B, 0xF0, 0x12, 0x00, 0x12, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x11, 0xF0, 0x00, 0x00	; U+00F1
000b5b 0000
000b5c e001
000b5d 1012
000b5e 100a
000b5f 1002
000b60 1002
000b61 e001
000b62 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x12, 0x10, 0x0A, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F2
000b63 0000
000b64 e001
000b65 1002
000b66 1002
000b67 100a
000b68 1012
000b69 e001
000b6a 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x0A, 0x10, 0x12, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F3
000b6b 0000
000b6c e001
000b6d 100a
000b6e 1012
000b6f 1012
000b70 100a
000b71 e001
000b72 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x0A, 0x10, 0x12, 0x10, 0x12, 0x10, 0x0A, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F4
000b73 0000
000b74 e009
000b75 1012
000b76 1012
000b77 100a
000b78 100a
000b79 e011
000b7a 0000                      .DB	0x00, 0x00, 0x09, 0xE0, 0x12, 0x10, 0x12, 0x10, 0x0A, 0x10, 0x0A, 0x10, 0x11, 0xE0, 0x00, 0x00	; U+00F5
000b7b 0000
000b7c e001
000b7d 101a
000b7e 1002
000b7f 1002
000b80 101a
000b81 e001
000b82 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x1A, 0x10, 0x02, 0x10, 0x02, 0x10, 0x1A, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F6
000b83 0000
000b84 8000
000b85 8000
000b86 b006
000b87 b006
000b88 8000
000b89 8000
000b8a 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x06, 0xB0, 0x06, 0xB0, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00	; U+00F7
000b8b 0000
000b8c e801
000b8d 3002
000b8e 5002
000b8f 9002
000b90 1003
000b91 e005
000b92 0000                      .DB	0x00, 0x00, 0x01, 0xE8, 0x02, 0x30, 0x02, 0x50, 0x02, 0x90, 0x03, 0x10, 0x05, 0xE0, 0x00, 0x00	; U+00F8
000b93 0000
000b94 e003
000b95 1010
000b96 1008
000b97 1000
000b98 1000
000b99 f003
000b9a 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x10, 0x10, 0x08, 0x10, 0x00, 0x10, 0x00, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00F9
000b9b 0000
000b9c e003
000b9d 1000
000b9e 1000
000b9f 1008
000ba0 1010
000ba1 f003
000ba2 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x08, 0x10, 0x10, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00FA
000ba3 0000
000ba4 e003
000ba5 1008
000ba6 1010
000ba7 1010
000ba8 1008
000ba9 f003
000baa 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x08, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00FB
000bab 0000
000bac e003
000bad 1018
000bae 1000
000baf 1000
000bb0 1018
000bb1 f003
000bb2 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x18, 0x10, 0x00, 0x10, 0x00, 0x10, 0x18, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00FC
000bb3 0000
000bb4 e003
000bb5 1200
000bb6 1200
000bb7 1208
000bb8 1210
000bb9 fc03
000bba 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x12, 0x00, 0x12, 0x08, 0x12, 0x10, 0x12, 0x03, 0xFC, 0x00, 0x00	; U+00FD
000bbb 0000
000bbc fe1f
000bbd 1002
000bbe 1002
000bbf 1002
000bc0 1002
000bc1 e001
000bc2 0000                      .DB	0x00, 0x00, 0x1F, 0xFE, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00FE
000bc3 0000
000bc4 e003
000bc5 1218
000bc6 1200
000bc7 1200
000bc8 1218
000bc9 fc03
000bca 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x18, 0x12, 0x00, 0x12, 0x00, 0x12, 0x18, 0x12, 0x03, 0xFC, 0x00, 0x00	; U+00FF
                                 
                                 
                                 
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega32U4" register use summary:
x  :  10 y  :   0 z  :   8 r0 :  12 r1 :   9 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 211 r17:  47 r18:  28 r19:  25 r20:   3 
r21:  28 r22:  13 r23:  10 r24:   5 r25:   5 r26:  36 r27:  33 r28:  40 
r29:  36 r30:  47 r31:  43 
Registers used: 20 out of 35 (57.1%)

"ATmega32U4" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   1 add   :   9 adiw  :   5 and   :   0 
andi  :   0 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  27 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   3 brlt  :   0 brmi  :   0 
brne  :  14 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   1 cbi   :  10 cbr   :   0 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :   1 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   4 cpc   :   0 
cpi   :  30 cpse  :   0 dec   :  11 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :   8 inc   :   3 jmp   :   0 
ld    :   1 ldd   :   0 ldi   : 182 lds   :   2 lpm   :  14 lsl   :   3 
lsr   :  15 mov   :  24 movw  :   1 mul   :   1 muls  :   0 mulsu :   0 
neg   :   0 nop   :   2 or    :   2 ori   :   1 out   :  27 pop   : 102 
push  : 100 rcall :  94 ret   :  42 reti  :   3 rjmp  :  26 rol   :   0 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :  15 sbic  :   1 sbis  :   2 
sbiw  :   5 sbr   :   0 sbrc  :   2 sbrs  :   6 sec   :   0 seh   :   0 
sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :   9 std   :   0 sts   :  12 
sub   :   2 subi  :   1 swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 44 out of 113 (38.9%)

"ATmega32U4" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x001796   1668   4212   5880   32768  17.9%
[.dseg] 0x000100 0x000100      0      0      0    2560   0.0%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 0 warnings
