
AVRASM ver. 2.2.8  C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm Fri Dec 06 13:04:29 2024

[builtin](2): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm(17): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm(1553): Including file 'C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\LCDDriver.asm'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\LCDDriver.asm(31): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
[builtin](2): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm(17): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\Ian_Kiser_Evan_Shishido_Lab7_SourceCode.asm(1553): Including file 'C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\LCDDriver.asm'
C:\Users\Ian\Documents\GitHub\ECE-375-Lab7\Ian Version\AssemblerApplication6\LCDDriver.asm(31): Including file 'C:/microchip studio\7.0\Packs\Atmel\ATmega_DFP\2.2.509\avrasm\inc\m32U4def.inc'
                                 
                                 
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32U4.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32U4def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32U4
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32U4
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32U4DEF_INC_
                                 #define _M32U4DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATmega32U4
                                 #pragma AVRPART ADMIN PART_NAME ATmega32U4
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x95
                                 .equ	SIGNATURE_002	= 0x87
                                 
                                 #pragma AVRPART CORE CORE_VERSION V3
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	PLLCSR	= 0x29
                                 .equ	PLLFRQ	= 0x32
                                 .equ	UEINT	= 0xf4	; MEMORY MAPPED
                                 .equ	UEBCHX	= 0xf3	; MEMORY MAPPED
                                 .equ	UEBCLX	= 0xf2	; MEMORY MAPPED
                                 .equ	UEDATX	= 0xf1	; MEMORY MAPPED
                                 .equ	UEIENX	= 0xf0	; MEMORY MAPPED
                                 .equ	UESTA1X	= 0xef	; MEMORY MAPPED
                                 .equ	UESTA0X	= 0xee	; MEMORY MAPPED
                                 .equ	UECFG1X	= 0xed	; MEMORY MAPPED
                                 .equ	UECFG0X	= 0xec	; MEMORY MAPPED
                                 .equ	UECONX	= 0xeb	; MEMORY MAPPED
                                 .equ	UERST	= 0xea	; MEMORY MAPPED
                                 .equ	UENUM	= 0xe9	; MEMORY MAPPED
                                 .equ	UEINTX	= 0xe8	; MEMORY MAPPED
                                 .equ	UDMFN	= 0xe6	; MEMORY MAPPED
                                 .equ	UDFNUMH	= 0xe5	; MEMORY MAPPED
                                 .equ	UDFNUML	= 0xe4	; MEMORY MAPPED
                                 .equ	UDADDR	= 0xe3	; MEMORY MAPPED
                                 .equ	UDIEN	= 0xe2	; MEMORY MAPPED
                                 .equ	UDINT	= 0xe1	; MEMORY MAPPED
                                 .equ	UDCON	= 0xe0	; MEMORY MAPPED
                                 .equ	USBINT	= 0xda	; MEMORY MAPPED
                                 .equ	USBSTA	= 0xd9	; MEMORY MAPPED
                                 .equ	USBCON	= 0xd8	; MEMORY MAPPED
                                 .equ	UHWCON	= 0xd7	; MEMORY MAPPED
                                 .equ	UDR1	= 0xce	; MEMORY MAPPED
                                 .equ	UBRR1L	= 0xcc	; MEMORY MAPPED
                                 .equ	UBRR1H	= 0xcd	; MEMORY MAPPED
                                 .equ	UCSR1C	= 0xca	; MEMORY MAPPED
                                 .equ	UCSR1B	= 0xc9	; MEMORY MAPPED
                                 .equ	UCSR1A	= 0xc8	; MEMORY MAPPED
                                 .equ 	TWAMR		= 0xbd	;
                                 .equ  TWCR		= 0xbc	;
                                 .equ 	TWDR		= 0xbb	;
                                 .equ 	TWAR		= 0xba 	;
                                 .equ 	TWSR		= 0xb9	;
                                 .equ 	TWBR		= 0xb8	;
                                 .equ	OCR3CL	= 0x9c	; MEMORY MAPPED
                                 .equ	OCR3CH	= 0x9d	; MEMORY MAPPED
                                 .equ	OCR3BL	= 0x9a	; MEMORY MAPPED
                                 .equ	OCR3BH	= 0x9b	; MEMORY MAPPED
                                 .equ	OCR3AL	= 0x98	; MEMORY MAPPED
                                 .equ	OCR3AH	= 0x99	; MEMORY MAPPED
                                 .equ	ICR3L	= 0x96	; MEMORY MAPPED
                                 .equ	ICR3H	= 0x97	; MEMORY MAPPED
                                 .equ	TCNT3L	= 0x94	; MEMORY MAPPED
                                 .equ	TCNT3H	= 0x95	; MEMORY MAPPED
                                 .equ	TCCR3C	= 0x92	; MEMORY MAPPED
                                 .equ	TCCR3B	= 0x91	; MEMORY MAPPED
                                 .equ	TCCR3A	= 0x90	; MEMORY MAPPED
                                 .equ	OCR1CL	= 0x8c	; MEMORY MAPPED
                                 .equ	OCR1CH	= 0x8d	; MEMORY MAPPED
                                 .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
                                 .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
                                 .equ	OCR1AL	= 0x88	; MEMORY MAPPED
                                 .equ	OCR1AH	= 0x89	; MEMORY MAPPED
                                 .equ	ICR1L	= 0x86	; MEMORY MAPPED
                                 .equ	ICR1H	= 0x87	; MEMORY MAPPED
                                 .equ	TCNT1L	= 0x84	; MEMORY MAPPED
                                 .equ	TCNT1H	= 0x85	; MEMORY MAPPED
                                 .equ	TCCR1C	= 0x82	; MEMORY MAPPED
                                 .equ	TCCR1B	= 0x81	; MEMORY MAPPED
                                 .equ	TCCR1A	= 0x80	; MEMORY MAPPED
                                 .equ	DIDR1	= 0x7f	; MEMORY MAPPED
                                 .equ	DIDR0	= 0x7e	; MEMORY MAPPED
                                 .equ	DIDR2	= 0x7d	; MEMORY MAPPED
                                 .equ	ADMUX	= 0x7c	; MEMORY MAPPED
                                 .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
                                 .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
                                 .equ	ADCH	= 0x79	; MEMORY MAPPED
                                 .equ	ADCL	= 0x78	; MEMORY MAPPED
                                 .equ	TIMSK4	= 0x72	; MEMORY MAPPED
                                 .equ	TIMSK3	= 0x71	; MEMORY MAPPED
                                 .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
                                 .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
                                 .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
                                 .equ	EICRB	= 0x6a	; MEMORY MAPPED
                                 .equ	EICRA	= 0x69	; MEMORY MAPPED
                                 .equ	PCICR	= 0x68	; MEMORY MAPPED
                                 .equ	OSCCAL	= 0x66	; MEMORY MAPPED
                                 .equ	RCCTRL	= 0x67	; MEMORY MAPPED
                                 .equ	PRR1	= 0x65	; MEMORY MAPPED
                                 .equ	PRR0	= 0x64	; MEMORY MAPPED
                                 .equ	CLKPR	= 0x61	; MEMORY MAPPED
                                 .equ	WDTCSR	= 0x60	; MEMORY MAPPED
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	EIND	= 0x3c
                                 .equ	SPMCSR	= 0x37
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	SMCR	= 0x33
                                 .equ	OCDR	= 0x31
                                 .equ	ACSR	= 0x30
                                 .equ	SPDR	= 0x2e
                                 .equ	SPSR	= 0x2d
                                 .equ	SPCR	= 0x2c
                                 .equ	GPIOR2	= 0x2b
                                 .equ	GPIOR1	= 0x2a
                                 .equ	OCR0B	= 0x28
                                 .equ	OCR0A	= 0x27
                                 .equ	TCNT0	= 0x26
                                 .equ	TCCR0B	= 0x25
                                 .equ	TCCR0A	= 0x24
                                 .equ	GTCCR	= 0x23
                                 .equ	EEARH	= 0x22
                                 .equ	EEARL	= 0x21
                                 .equ	EEDR	= 0x20
                                 .equ	EECR	= 0x1f
                                 .equ	GPIOR0	= 0x1e
                                 .equ	EIMSK	= 0x1d
                                 .equ	EIFR	= 0x1c
                                 .equ	PCIFR	= 0x1b
                                 .equ	TIFR4	= 0x19
                                 .equ	TIFR3	= 0x18
                                 .equ	TIFR2	= 0x17
                                 .equ	TIFR1	= 0x16
                                 .equ	TIFR0	= 0x15
                                 .equ	PORTF	= 0x11
                                 .equ	DDRF	= 0x10
                                 .equ	PINF	= 0x0f
                                 .equ	PORTE	= 0x0e
                                 .equ	DDRE	= 0x0d
                                 .equ	PINE	= 0x0c
                                 .equ	PORTD	= 0x0b
                                 .equ	DDRD	= 0x0a
                                 .equ	PIND	= 0x09
                                 .equ	PORTC	= 0x08
                                 .equ	DDRC	= 0x07
                                 .equ	PINC	= 0x06
                                 .equ	PORTB	= 0x05
                                 .equ	DDRB	= 0x04
                                 .equ	PINB	= 0x03
                                 .equ	DT4	= 0xd4	; MEMORY MAPPED
                                 .equ	OCR4D	= 0xd2	; MEMORY MAPPED
                                 .equ	OCR4C	= 0xd1	; MEMORY MAPPED
                                 .equ	OCR4B	= 0xd0	; MEMORY MAPPED
                                 .equ	OCR4A	= 0xcf	; MEMORY MAPPED
                                 .equ	TCCR4E	= 0xc4	; MEMORY MAPPED
                                 .equ	TCCR4D	= 0xc3	; MEMORY MAPPED
                                 .equ	TCCR4C	= 0xc2	; MEMORY MAPPED
                                 .equ	TCCR4B	= 0xc1	; MEMORY MAPPED
                                 .equ	TCCR4A	= 0xc0	; MEMORY MAPPED
                                 .equ	TC4H	= 0xbf	; MEMORY MAPPED
                                 .equ	TCNT4	= 0xbe	; MEMORY MAPPED
                                 .equ	CLKSEL1	= 0xc6	; MEMORY MAPPED
                                 .equ	CLKSEL0	= 0xc5	; MEMORY MAPPED
                                 .equ	CLKSTA	= 0xc7	; MEMORY MAPPED
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** PORTD ************************
                                 ; PORTD - Port D Data Register
                                 .equ	PORTD0	= 0	; Port D Data Register bit 0
                                 .equ	PD0	= 0	; For compatibility
                                 .equ	PORTD1	= 1	; Port D Data Register bit 1
                                 .equ	PD1	= 1	; For compatibility
                                 .equ	PORTD2	= 2	; Port D Data Register bit 2
                                 .equ	PD2	= 2	; For compatibility
                                 .equ	PORTD3	= 3	; Port D Data Register bit 3
                                 .equ	PD3	= 3	; For compatibility
                                 .equ	PORTD4	= 4	; Port D Data Register bit 4
                                 .equ	PD4	= 4	; For compatibility
                                 .equ	PORTD5	= 5	; Port D Data Register bit 5
                                 .equ	PD5	= 5	; For compatibility
                                 .equ	PORTD6	= 6	; Port D Data Register bit 6
                                 .equ	PD6	= 6	; For compatibility
                                 .equ	PORTD7	= 7	; Port D Data Register bit 7
                                 .equ	PD7	= 7	; For compatibility
                                 
                                 ; DDRD - Port D Data Direction Register
                                 .equ	DDD0	= 0	; Port D Data Direction Register bit 0
                                 .equ	DDD1	= 1	; Port D Data Direction Register bit 1
                                 .equ	DDD2	= 2	; Port D Data Direction Register bit 2
                                 .equ	DDD3	= 3	; Port D Data Direction Register bit 3
                                 .equ	DDD4	= 4	; Port D Data Direction Register bit 4
                                 .equ	DDD5	= 5	; Port D Data Direction Register bit 5
                                 .equ	DDD6	= 6	; Port D Data Direction Register bit 6
                                 .equ	DDD7	= 7	; Port D Data Direction Register bit 7
                                 
                                 ; PIND - Port D Input Pins
                                 .equ	PIND0	= 0	; Port D Input Pins bit 0
                                 .equ	PIND1	= 1	; Port D Input Pins bit 1
                                 .equ	PIND2	= 2	; Port D Input Pins bit 2
                                 .equ	PIND3	= 3	; Port D Input Pins bit 3
                                 .equ	PIND4	= 4	; Port D Input Pins bit 4
                                 .equ	PIND5	= 5	; Port D Input Pins bit 5
                                 .equ	PIND6	= 6	; Port D Input Pins bit 6
                                 .equ	PIND7	= 7	; Port D Input Pins bit 7
                                 
                                 
                                 ; ***** SPI **************************
                                 ; SPDR - SPI Data Register
                                 .equ	SPDR0	= 0	; SPI Data Register bit 0
                                 .equ	SPDR1	= 1	; SPI Data Register bit 1
                                 .equ	SPDR2	= 2	; SPI Data Register bit 2
                                 .equ	SPDR3	= 3	; SPI Data Register bit 3
                                 .equ	SPDR4	= 4	; SPI Data Register bit 4
                                 .equ	SPDR5	= 5	; SPI Data Register bit 5
                                 .equ	SPDR6	= 6	; SPI Data Register bit 6
                                 .equ	SPDR7	= 7	; SPI Data Register bit 7
                                 
                                 ; SPSR - SPI Status Register
                                 .equ	SPI2X	= 0	; Double SPI Speed Bit
                                 .equ	WCOL	= 6	; Write Collision Flag
                                 .equ	SPIF	= 7	; SPI Interrupt Flag
                                 
                                 ; SPCR - SPI Control Register
                                 .equ	SPR0	= 0	; SPI Clock Rate Select 0
                                 .equ	SPR1	= 1	; SPI Clock Rate Select 1
                                 .equ	CPHA	= 2	; Clock Phase
                                 .equ	CPOL	= 3	; Clock polarity
                                 .equ	MSTR	= 4	; Master/Slave Select
                                 .equ	DORD	= 5	; Data Order
                                 .equ	SPE	= 6	; SPI Enable
                                 .equ	SPIE	= 7	; SPI Interrupt Enable
                                 
                                 
                                 ; ***** USART1 ***********************
                                 ; UDR1 - USART I/O Data Register
                                 .equ	UDR1_0	= 0	; USART I/O Data Register bit 0
                                 .equ	UDR1_1	= 1	; USART I/O Data Register bit 1
                                 .equ	UDR1_2	= 2	; USART I/O Data Register bit 2
                                 .equ	UDR1_3	= 3	; USART I/O Data Register bit 3
                                 .equ	UDR1_4	= 4	; USART I/O Data Register bit 4
                                 .equ	UDR1_5	= 5	; USART I/O Data Register bit 5
                                 .equ	UDR1_6	= 6	; USART I/O Data Register bit 6
                                 .equ	UDR1_7	= 7	; USART I/O Data Register bit 7
                                 
                                 ; UCSR1A - USART Control and Status Register A
                                 .equ	MPCM1	= 0	; Multi-processor Communication Mode
                                 .equ	U2X1	= 1	; Double the USART transmission speed
                                 .equ	UPE1	= 2	; Parity Error
                                 .equ	DOR1	= 3	; Data overRun
                                 .equ	FE1	= 4	; Framing Error
                                 .equ	UDRE1	= 5	; USART Data Register Empty
                                 .equ	TXC1	= 6	; USART Transmitt Complete
                                 .equ	RXC1	= 7	; USART Receive Complete
                                 
                                 ; UCSR1B - USART Control and Status Register B
                                 .equ	TXB81	= 0	; Transmit Data Bit 8
                                 .equ	RXB81	= 1	; Receive Data Bit 8
                                 .equ	UCSZ12	= 2	; Character Size
                                 .equ	TXEN1	= 3	; Transmitter Enable
                                 .equ	RXEN1	= 4	; Receiver Enable
                                 .equ	UDRIE1	= 5	; USART Data register Empty Interrupt Enable
                                 .equ	TXCIE1	= 6	; TX Complete Interrupt Enable
                                 .equ	RXCIE1	= 7	; RX Complete Interrupt Enable
                                 
                                 ; UCSR1C - USART Control and Status Register C
                                 .equ	UCPOL1	= 0	; Clock Polarity
                                 .equ	UCSZ10	= 1	; Character Size
                                 .equ	UCPHA1	= UCSZ10	; For compatibility
                                 .equ	UCSZ11	= 2	; Character Size
                                 .equ	UDORD1	= UCSZ11	; For compatibility
                                 .equ	USBS1	= 3	; Stop Bit Select
                                 .equ	UPM10	= 4	; Parity Mode Bit 0
                                 .equ	UPM11	= 5	; Parity Mode Bit 1
                                 .equ	UMSEL10	= 6	; USART Mode Select
                                 .equ	UMSEL11	= 7	; USART Mode Select
                                 
                                 ; UBRR1H - USART Baud Rate Register High Byte
                                 .equ	UBRR_8	= 0	; USART Baud Rate Register bit 8
                                 .equ	UBRR_9	= 1	; USART Baud Rate Register bit 9
                                 .equ	UBRR_10	= 2	; USART Baud Rate Register bit 10
                                 .equ	UBRR_11	= 3	; USART Baud Rate Register bit 11
                                 
                                 ; UBRR1L - USART Baud Rate Register Low Byte
                                 .equ	UBRR_0	= 0	; USART Baud Rate Register bit 0
                                 .equ	UBRR_1	= 1	; USART Baud Rate Register bit 1
                                 .equ	UBRR_2	= 2	; USART Baud Rate Register bit 2
                                 .equ	UBRR_3	= 3	; USART Baud Rate Register bit 3
                                 .equ	UBRR_4	= 4	; USART Baud Rate Register bit 4
                                 .equ	UBRR_5	= 5	; USART Baud Rate Register bit 5
                                 .equ	UBRR_6	= 6	; USART Baud Rate Register bit 6
                                 .equ	UBRR_7	= 7	; USART Baud Rate Register bit 7
                                 
                                 
                                 ; ***** BOOT_LOAD ********************
                                 ; SPMCSR - Store Program Memory Control Register
                                 .equ	SPMEN	= 0	; Store Program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	BLBSET	= 3	; Boot Lock Bit Set
                                 .equ	RWWSRE	= 4	; Read While Write section read enable
                                 .equ	SIGRD	= 5	; Signature Row Read
                                 .equ	RWWSB	= 6	; Read While Write Section Busy
                                 .equ	SPMIE	= 7	; SPM Interrupt Enable
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEARH - EEPROM Address Register Low Byte
                                 .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
                                 .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
                                 .equ	EEAR10	= 2	; EEPROM Read/Write Access Bit 10
                                 .equ	EEAR11	= 3	; EEPROM Read/Write Access Bit 11
                                 
                                 ; EEARL - EEPROM Address Register Low Byte
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
                                 .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
                                 .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEPE	= 1	; EEPROM Write Enable
                                 .equ	EEMPE	= 2	; EEPROM Master Write Enable
                                 .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
                                 .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
                                 .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
                                 .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
                                 .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; 
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
                                 .equ	PSR10	= PSRSYNC	; For compatibility
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** TIMER_COUNTER_3 **************
                                 ; TIMSK3 - Timer/Counter3 Interrupt Mask Register
                                 .equ	TOIE3	= 0	; Timer/Counter3 Overflow Interrupt Enable
                                 .equ	OCIE3A	= 1	; Timer/Counter3 Output Compare A Match Interrupt Enable
                                 .equ	OCIE3B	= 2	; Timer/Counter3 Output Compare B Match Interrupt Enable
                                 .equ	OCIE3C	= 3	; Timer/Counter3 Output Compare C Match Interrupt Enable
                                 .equ	ICIE3	= 5	; Timer/Counter3 Input Capture Interrupt Enable
                                 
                                 ; TIFR3 - Timer/Counter3 Interrupt Flag register
                                 .equ	TOV3	= 0	; Timer/Counter3 Overflow Flag
                                 .equ	OCF3A	= 1	; Output Compare Flag 3A
                                 .equ	OCF3B	= 2	; Output Compare Flag 3B
                                 .equ	OCF3C	= 3	; Output Compare Flag 3C
                                 .equ	ICF3	= 5	; Input Capture Flag 3
                                 
                                 ; TCCR3A - Timer/Counter3 Control Register A
                                 .equ	WGM30	= 0	; Waveform Generation Mode
                                 .equ	WGM31	= 1	; Waveform Generation Mode
                                 .equ	COM3C0	= 2	; Compare Output Mode 3C, bit 0
                                 .equ	COM3C1	= 3	; Compare Output Mode 3C, bit 1
                                 .equ	COM3B0	= 4	; Compare Output Mode 3B, bit 0
                                 .equ	COM3B1	= 5	; Compare Output Mode 3B, bit 1
                                 .equ	COM3A0	= 6	; Compare Output Mode 3A, bit 0
                                 .equ	COM3A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR3B - Timer/Counter3 Control Register B
                                 .equ	CS30	= 0	; Prescaler source of Timer/Counter 3
                                 .equ	CS31	= 1	; Prescaler source of Timer/Counter 3
                                 .equ	CS32	= 2	; Prescaler source of Timer/Counter 3
                                 .equ	WGM32	= 3	; Waveform Generation Mode
                                 .equ	WGM33	= 4	; Waveform Generation Mode
                                 .equ	ICES3	= 6	; Input Capture 3 Edge Select
                                 .equ	ICNC3	= 7	; Input Capture 3 Noise Canceler
                                 
                                 ; TCCR3C - Timer/Counter 3 Control Register C
                                 .equ	FOC3C	= 5	; Force Output Compare 3C
                                 .equ	FOC3B	= 6	; Force Output Compare 3B
                                 .equ	FOC3A	= 7	; Force Output Compare 3A
                                 
                                 
                                 ; ***** TIMER_COUNTER_1 **************
                                 ; TIMSK1 - Timer/Counter1 Interrupt Mask Register
                                 .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
                                 .equ	OCIE1A	= 1	; Timer/Counter1 Output Compare A Match Interrupt Enable
                                 .equ	OCIE1B	= 2	; Timer/Counter1 Output Compare B Match Interrupt Enable
                                 .equ	OCIE1C	= 3	; Timer/Counter1 Output Compare C Match Interrupt Enable
                                 .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
                                 
                                 ; TIFR1 - Timer/Counter1 Interrupt Flag register
                                 .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
                                 .equ	OCF1A	= 1	; Output Compare Flag 1A
                                 .equ	OCF1B	= 2	; Output Compare Flag 1B
                                 .equ	OCF1C	= 3	; Output Compare Flag 1C
                                 .equ	ICF1	= 5	; Input Capture Flag 1
                                 
                                 ; TCCR1A - Timer/Counter1 Control Register A
                                 .equ	WGM10	= 0	; Waveform Generation Mode
                                 .equ	WGM11	= 1	; Waveform Generation Mode
                                 .equ	COM1C0	= 2	; Compare Output Mode 1C, bit 0
                                 .equ	COM1C1	= 3	; Compare Output Mode 1C, bit 1
                                 .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
                                 .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
                                 .equ	COM1A0	= 6	; Compare Output Mode 1A, bit 0
                                 .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 ; TCCR1B - Timer/Counter1 Control Register B
                                 .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
                                 .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
                                 .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
                                 .equ	WGM12	= 3	; Waveform Generation Mode
                                 .equ	WGM13	= 4	; Waveform Generation Mode
                                 .equ	ICES1	= 6	; Input Capture 1 Edge Select
                                 .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
                                 
                                 ; TCCR1C - Timer/Counter 1 Control Register C
                                 .equ	FOC1C	= 5	; Force Output Compare 1C
                                 .equ	FOC1B	= 6	; Force Output Compare 1B
                                 .equ	FOC1A	= 7	; Force Output Compare 1A
                                 
                                 
                                 ; ***** JTAG *************************
                                 ; OCDR - On-Chip Debug Related Register in I/O Memory
                                 .equ	OCDR0	= 0	; On-Chip Debug Register Bit 0
                                 .equ	OCDR1	= 1	; On-Chip Debug Register Bit 1
                                 .equ	OCDR2	= 2	; On-Chip Debug Register Bit 2
                                 .equ	OCDR3	= 3	; On-Chip Debug Register Bit 3
                                 .equ	OCDR4	= 4	; On-Chip Debug Register Bit 4
                                 .equ	OCDR5	= 5	; On-Chip Debug Register Bit 5
                                 .equ	OCDR6	= 6	; On-Chip Debug Register Bit 6
                                 .equ	OCDR7	= 7	; On-Chip Debug Register Bit 7
                                 .equ	IDRD	= OCDR7	; For compatibility
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; External Interrupt Sense Control Bit
                                 .equ	ISC01	= 1	; External Interrupt Sense Control Bit
                                 .equ	ISC10	= 2	; External Interrupt Sense Control Bit
                                 .equ	ISC11	= 3	; External Interrupt Sense Control Bit
                                 .equ	ISC20	= 4	; External Interrupt Sense Control Bit
                                 .equ	ISC21	= 5	; External Interrupt Sense Control Bit
                                 .equ	ISC30	= 6	; External Interrupt Sense Control Bit
                                 .equ	ISC31	= 7	; External Interrupt Sense Control Bit
                                 
                                 ; EICRB - External Interrupt Control Register B
                                 .equ	ISC40	= 0	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC41	= 1	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC50	= 2	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC51	= 3	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC60	= 4	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC61	= 5	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC70	= 6	; External Interrupt 7-4 Sense Control Bit
                                 .equ	ISC71	= 7	; External Interrupt 7-4 Sense Control Bit
                                 
                                 ; EIMSK - External Interrupt Mask Register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 .equ	INT1	= 1	; External Interrupt Request 1 Enable
                                 .equ	INT2	= 2	; External Interrupt Request 2 Enable
                                 .equ	INT3	= 3	; External Interrupt Request 3 Enable
                                 .equ	INT4	= 4	; External Interrupt Request 4 Enable
                                 .equ	INT5	= 5	; External Interrupt Request 5 Enable
                                 .equ	INT6	= 6	; External Interrupt Request 6 Enable
                                 .equ	INT7	= 7	; External Interrupt Request 7 Enable
                                 
                                 ; EIFR - External Interrupt Flag Register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 .equ	INTF1	= 1	; External Interrupt Flag 1
                                 .equ	INTF2	= 2	; External Interrupt Flag 2
                                 .equ	INTF3	= 3	; External Interrupt Flag 3
                                 .equ	INTF4	= 4	; External Interrupt Flag 4
                                 .equ	INTF5	= 5	; External Interrupt Flag 5
                                 .equ	INTF6	= 6	; External Interrupt Flag 6
                                 .equ	INTF7	= 7	; External Interrupt Flag 7
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 
                                 ; PCMSK0 - Pin Change Mask Register 0
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask 5
                                 .equ	PCINT6	= 6	; Pin Change Enable Mask 6
                                 .equ	PCINT7	= 7	; Pin Change Enable Mask 7
                                 
                                 
                                 ; ***** TIMER_COUNTER_4 **************
                                 ; DT4 - Timer/Counter 4 Dead Time Value
                                 .equ	DT4L0	= 0	; Timer/Counter 4 Dead Time Value Bit 0
                                 .equ	DT4L1	= 1	; Timer/Counter 4 Dead Time Value Bit 1
                                 .equ	DT4L2	= 2	; Timer/Counter 4 Dead Time Value Bit 2
                                 .equ	DT4L3	= 3	; Timer/Counter 4 Dead Time Value Bit 3
                                 .equ	DT4L4	= 4	; Timer/Counter 4 Dead Time Value Bit 4
                                 .equ	DT4L5	= 5	; Timer/Counter 4 Dead Time Value Bit 5
                                 .equ	DT4L6	= 6	; Timer/Counter 4 Dead Time Value Bit 6
                                 .equ	DT4L7	= 7	; Timer/Counter 4 Dead Time Value Bit 7
                                 
                                 ; TIFR4 - Timer/Counter4 Interrupt Flag register
                                 .equ	TOV4	= 2	; Timer/Counter4 Overflow Flag
                                 .equ	OCF4B	= 5	; Output Compare Flag 4B
                                 .equ	OCF4A	= 6	; Output Compare Flag 4A
                                 .equ	OCF4D	= 7	; Output Compare Flag 4D
                                 
                                 ; TIMSK4 - Timer/Counter4 Interrupt Mask Register
                                 .equ	TOIE4	= 2	; Timer/Counter4 Overflow Interrupt Enable
                                 .equ	OCIE4B	= 5	; Timer/Counter4 Output Compare B Match Interrupt Enable
                                 .equ	OCIE4A	= 6	; Timer/Counter4 Output Compare A Match Interrupt Enable
                                 .equ	OCIE4D	= 7	; Timer/Counter4 Output Compare D Match Interrupt Enable
                                 
                                 ; OCR4D - Timer/Counter4 Output Compare Register D
                                 .equ	OCR4D0	= 0	; Timer/Counter4 Output Compare Register Low Byte bit 0
                                 .equ	OCR4D1	= 1	; Timer/Counter4 Output Compare Register Low Byte bit 1
                                 .equ	OCR4D2	= 2	; Timer/Counter4 Output Compare Register Low Byte bit 2
                                 .equ	OCR4D3	= 3	; Timer/Counter4 Output Compare Register Low Byte bit 3
                                 .equ	OCR4D4	= 4	; Timer/Counter4 Output Compare Register Low Byte bit 4
                                 .equ	OCR4D5	= 5	; Timer/Counter4 Output Compare Register Low Byte bit 5
                                 .equ	OCR4D6	= 6	; Timer/Counter4 Output Compare Register Low Byte bit 6
                                 .equ	OCR4D7	= 7	; Timer/Counter4 Output Compare Register Low Byte bit 7
                                 
                                 ; OCR4C - Timer/Counter4 Output Compare Register C
                                 .equ	OCR4C0	= 0	; Timer/Counter4 Output Compare Register bit 0
                                 .equ	OCR4C1	= 1	; Timer/Counter4 Output Compare Register bit 1
                                 .equ	OCR4C2	= 2	; Timer/Counter4 Output Compare Register bit 2
                                 .equ	OCR4C3	= 3	; Timer/Counter4 Output Compare Register bit 3
                                 .equ	OCR4C4	= 4	; Timer/Counter4 Output Compare Register bit 4
                                 .equ	OCR4C5	= 5	; Timer/Counter4 Output Compare Register bit 5
                                 .equ	OCR4C6	= 6	; Timer/Counter4 Output Compare Register 6
                                 .equ	OCR4C7	= 7	; Timer/Counter4 Output Compare Register bit 7
                                 
                                 ; OCR4B - Timer/Counter4 Output Compare Register B
                                 .equ	OCR4B0	= 0	; Timer/Counter4 Output Compare Register bit 0
                                 .equ	OCR4B1	= 1	; Timer/Counter4 Output Compare Register bit 1
                                 .equ	OCR4B2	= 2	; Timer/Counter4 Output Compare Register bit 2
                                 .equ	OCR4B3	= 3	; Timer/Counter4 Output Compare Register bit 3
                                 .equ	OCR4B4	= 4	; Timer/Counter4 Output Compare Register bit 4
                                 .equ	OCR4B5	= 5	; Timer/Counter4 Output Compare Register bit 5
                                 .equ	OCR4B6	= 6	; Timer/Counter4 Output Compare Register bit 6
                                 .equ	OCR4B7	= 7	; Timer/Counter4 Output Compare Register bit 7
                                 
                                 ; OCR4A - Timer/Counter4 Output Compare Register A
                                 .equ	OCR4A0	= 0	; Timer/Counter4 Output Compare Register Bit 0
                                 .equ	OCR4A1	= 1	; Timer/Counter4 Output Compare Register Bit 1
                                 .equ	OCR4A2	= 2	; Timer/Counter4 Output Compare Register Low Byte Bit 2
                                 .equ	OCR4A3	= 3	; Timer/Counter4 Output Compare Register Low Byte Bit 3
                                 .equ	OCR4A4	= 4	; Timer/Counter4 Output Compare Register Bit 4
                                 .equ	OCR4A5	= 5	; Timer/Counter4 Output Compare Register Bit 5
                                 .equ	OCR4A6	= 6	; Timer/Counter4 Output Compare Register Bit 6
                                 .equ	OCR4A7	= 7	; Timer/Counter4 Output Compare Register Bit 7
                                 
                                 ; TC4H - Timer/Counter4
                                 .equ	TC48	= 0	; Timer/Counter4 bit 8
                                 .equ	TC49	= 1	; Timer/Counter4 bit 9
                                 .equ	TC410	= 2	; Timer/Counter4 bit 10
                                 
                                 ; TCNT4 - Timer/Counter4 Low Bytes
                                 .equ	TC40	= 0	; Timer/Counter4 bit 0
                                 .equ	TC41	= 1	; Timer/Counter4 bit 1
                                 .equ	TC42	= 2	; Timer/Counter4 bit 2
                                 .equ	TC43	= 3	; Timer/Counter4  bit 3
                                 .equ	TC44	= 4	; Timer/Counter4 bit 4
                                 .equ	TC45	= 5	; Timer/Counter4 bit 5
                                 .equ	TC46	= 6	; Timer/Counter4 bit 6
                                 .equ	TC47	= 7	; Timer/Counter4 bit 7
                                 
                                 ; TCCR4E - Timer/Counter 4 Control Register E
                                 .equ	OC4OE0	= 0	; Output Compare Override Enable bit
                                 .equ	OC4OE1	= 1	; Output Compare Override Enable bit
                                 .equ	OC4OE2	= 2	; Output Compare Override Enable bit
                                 .equ	OC4OE3	= 3	; Output Compare Override Enable bit
                                 .equ	OC4OE4	= 4	; Output Compare Override Enable bit
                                 .equ	OC4OE5	= 5	; Output Compare Override Enable bit
                                 .equ	ENHC4	= 6	; Enhanced Compare/PWM Mode
                                 .equ	TLOCK4	= 7	; Register Update Lock
                                 
                                 ; TCCR4D - Timer/Counter 4 Control Register D
                                 .equ	WGM40	= 0	; Waveform Generation Mode bits
                                 .equ	WGM41	= 1	; Waveform Generation Mode bits
                                 .equ	FPF4	= 2	; Fault Protection Interrupt Flag
                                 .equ	FPAC4	= 3	; Fault Protection Analog Comparator Enable
                                 .equ	FPES4	= 4	; Fault Protection Edge Select
                                 .equ	FPNC4	= 5	; Fault Protection Noise Canceler
                                 .equ	FPEN4	= 6	; Fault Protection Mode Enable
                                 .equ	FPIE4	= 7	; Fault Protection Interrupt Enable
                                 
                                 ; TCCR4C - Timer/Counter 4 Control Register C
                                 .equ	PWM4D	= 0	; Pulse Width Modulator D Enable
                                 .equ	FOC4D	= 1	; Force Output Compare Match 4D
                                 .equ	COM4D0	= 2	; Comparator D Output Mode
                                 .equ	COM4D1	= 3	; Comparator D Output Mode
                                 .equ	COM4B0S	= 4	; Comparator B Output Mode
                                 .equ	COM4B1S	= 5	; Comparator B Output Mode
                                 .equ	COM4A0S	= 6	; Comparator A Output Mode
                                 .equ	COM4A1S	= 7	; Comparator A Output Mode
                                 
                                 ; TCCR4B - Timer/Counter4 Control Register B
                                 .equ	CS40	= 0	; Clock Select Bit 0
                                 .equ	CS41	= 1	; Clock Select Bit 1
                                 .equ	CS42	= 2	; Clock Select Bit 2
                                 .equ	CS43	= 3	; Clock Select Bit 3
                                 .equ	DTPS40	= 4	; Dead Time Prescaler Bit 0
                                 .equ	DTPS41	= 5	; Dead Time Prescaler Bit 1
                                 .equ	PSR4	= 6	; Prescaler Reset Timer/Counter 4
                                 .equ	PWM4X	= 7	; PWM Inversion Mode
                                 
                                 ; TCCR4A - Timer/Counter4 Control Register A
                                 .equ	PWM4B	= 0	; 
                                 .equ	PWM4A	= 1	; 
                                 .equ	FOC4B	= 2	; Force Output Compare Match 4B
                                 .equ	FOC4A	= 3	; Force Output Compare Match 4A
                                 .equ	COM4B0	= 4	; Compare Output Mode 4B, bit 0
                                 .equ	COM4B1	= 5	; Compare Output Mode 4B, bit 1
                                 .equ	COM4A0	= 6	; Compare Output Mode 4A, bit 0
                                 .equ	COM4A1	= 7	; Compare Output Mode 1A, bit 1
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Port B Data Register
                                 .equ	PORTB0	= 0	; Port B Data Register bit 0
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; Port B Data Register bit 1
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; Port B Data Register bit 2
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; Port B Data Register bit 3
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; Port B Data Register bit 4
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; Port B Data Register bit 5
                                 .equ	PB5	= 5	; For compatibility
                                 .equ	PORTB6	= 6	; Port B Data Register bit 6
                                 .equ	PB6	= 6	; For compatibility
                                 .equ	PORTB7	= 7	; Port B Data Register bit 7
                                 .equ	PB7	= 7	; For compatibility
                                 
                                 ; DDRB - Port B Data Direction Register
                                 .equ	DDB0	= 0	; Port B Data Direction Register bit 0
                                 .equ	DDB1	= 1	; Port B Data Direction Register bit 1
                                 .equ	DDB2	= 2	; Port B Data Direction Register bit 2
                                 .equ	DDB3	= 3	; Port B Data Direction Register bit 3
                                 .equ	DDB4	= 4	; Port B Data Direction Register bit 4
                                 .equ	DDB5	= 5	; Port B Data Direction Register bit 5
                                 .equ	DDB6	= 6	; Port B Data Direction Register bit 6
                                 .equ	DDB7	= 7	; Port B Data Direction Register bit 7
                                 
                                 ; PINB - Port B Input Pins
                                 .equ	PINB0	= 0	; Port B Input Pins bit 0
                                 .equ	PINB1	= 1	; Port B Input Pins bit 1
                                 .equ	PINB2	= 2	; Port B Input Pins bit 2
                                 .equ	PINB3	= 3	; Port B Input Pins bit 3
                                 .equ	PINB4	= 4	; Port B Input Pins bit 4
                                 .equ	PINB5	= 5	; Port B Input Pins bit 5
                                 .equ	PINB6	= 6	; Port B Input Pins bit 6
                                 .equ	PINB7	= 7	; Port B Input Pins bit 7
                                 
                                 
                                 ; ***** PORTC ************************
                                 ; PORTC - Port C Data Register
                                 .equ	PORTC6	= 6	; Port C Data Register bit 6
                                 .equ	PC6	= 6	; For compatibility
                                 .equ	PORTC7	= 7	; Port C Data Register bit 7
                                 .equ	PC7	= 7	; For compatibility
                                 
                                 ; DDRC - Port C Data Direction Register
                                 .equ	DDC6	= 6	; Port C Data Direction Register bit 6
                                 .equ	DDC7	= 7	; Port C Data Direction Register bit 7
                                 
                                 ; PINC - Port C Input Pins
                                 .equ	PINC6	= 6	; Port C Input Pins bit 6
                                 .equ	PINC7	= 7	; Port C Input Pins bit 7
                                 
                                 
                                 ; ***** PORTE ************************
                                 ; PORTE - Data Register, Port E
                                 .equ	PORTE2	= 2	; 
                                 .equ	PE2	= 2	; For compatibility
                                 .equ	PORTE6	= 6	; 
                                 .equ	PE6	= 6	; For compatibility
                                 
                                 ; DDRE - Data Direction Register, Port E
                                 .equ	DDE2	= 2	; 
                                 .equ	DDE6	= 6	; 
                                 
                                 ; PINE - Input Pins, Port E
                                 .equ	PINE2	= 2	; 
                                 .equ	PINE6	= 6	; 
                                 
                                 
                                 ; ***** PORTF ************************
                                 ; PORTF - Data Register, Port F
                                 .equ	PORTF0	= 0	; 
                                 .equ	PF0	= 0	; For compatibility
                                 .equ	PORTF1	= 1	; 
                                 .equ	PF1	= 1	; For compatibility
                                 .equ	PORTF4	= 4	; 
                                 .equ	PF4	= 4	; For compatibility
                                 .equ	PORTF5	= 5	; 
                                 .equ	PF5	= 5	; For compatibility
                                 .equ	PORTF6	= 6	; 
                                 .equ	PF6	= 6	; For compatibility
                                 .equ	PORTF7	= 7	; 
                                 .equ	PF7	= 7	; For compatibility
                                 
                                 ; DDRF - Data Direction Register, Port F
                                 .equ	DDF0	= 0	; 
                                 .equ	DDF1	= 1	; 
                                 .equ	DDF4	= 4	; 
                                 .equ	DDF5	= 5	; 
                                 .equ	DDF6	= 6	; 
                                 .equ	DDF7	= 7	; 
                                 
                                 ; PINF - Input Pins, Port F
                                 .equ	PINF0	= 0	; 
                                 .equ	PINF1	= 1	; 
                                 .equ	PINF4	= 4	; 
                                 .equ	PINF5	= 5	; 
                                 .equ	PINF6	= 6	; 
                                 .equ	PINF7	= 7	; 
                                 
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
                                 .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
                                 .equ	MUX4	= 4	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 .equ	REFS1	= 7	; Reference Selection Bit 1
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                                 .equ	ADTS3	= 4	; ADC Auto Trigger Source 3
                                 .equ	MUX5	= 5	; Analog Channel and Gain Selection Bits
                                 .equ	ADHSM	= 7	; ADC High Speed Mode
                                 
                                 ; DIDR0 - Digital Input Disable Register 1
                                 .equ	ADC0D	= 0	; ADC0 Digital input Disable
                                 .equ	ADC1D	= 1	; ADC1 Digital input Disable
                                 .equ	ADC2D	= 2	; ADC2 Digital input Disable
                                 .equ	ADC3D	= 3	; ADC3 Digital input Disable
                                 .equ	ADC4D	= 4	; ADC4 Digital input Disable
                                 .equ	ADC5D	= 5	; ADC5 Digital input Disable
                                 .equ	ADC6D	= 6	; ADC6 Digital input Disable
                                 .equ	ADC7D	= 7	; ADC7 Digital input Disable
                                 
                                 ; DIDR2 - Digital Input Disable Register 1
                                 .equ	ADC8D	= 0	; ADC8 Digital input Disable
                                 .equ	ADC9D	= 1	; ADC9 Digital input Disable
                                 .equ	ADC10D	= 2	; ADC10 Digital input Disable
                                 .equ	ADC11D	= 3	; ADC11 Digital input Disable
                                 .equ	ADC12D	= 4	; ADC12 Digital input Disable
                                 .equ	ADC13D	= 5	; ADC13 Digital input Disable
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR1 - 
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; MCUCR - MCU Control Register
                                 .equ	IVCE	= 0	; Interrupt Vector Change Enable
                                 .equ	IVSEL	= 1	; Interrupt Vector Select
                                 .equ	PUD	= 4	; Pull-up disable
                                 ;.equ	JTD	= 7	; JTAG Interface Disable
                                 
                                 ; MCUSR - MCU Status Register
                                 .equ	PORF	= 0	; Power-on reset flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 ;.equ	JTRF	= 4	; JTAG Reset Flag
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; RCCTRL - Oscillator Control Register
                                 .equ	RCFREQ	= 0	; 
                                 
                                 ; CLKPR - 
                                 .equ	CLKPS0	= 0	; 
                                 .equ	CLKPS1	= 1	; 
                                 .equ	CLKPS2	= 2	; 
                                 .equ	CLKPS3	= 3	; 
                                 .equ	CLKPCE	= 7	; 
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select bit 2
                                 
                                 ; EIND - Extended Indirect Register
                                 .equ	EIND0	= 0	; Bit 0
                                 
                                 ; GPIOR2 - General Purpose IO Register 2
                                 .equ	GPIOR20	= 0	; General Purpose IO Register 2 bit 0
                                 .equ	GPIOR21	= 1	; General Purpose IO Register 2 bit 1
                                 .equ	GPIOR22	= 2	; General Purpose IO Register 2 bit 2
                                 .equ	GPIOR23	= 3	; General Purpose IO Register 2 bit 3
                                 .equ	GPIOR24	= 4	; General Purpose IO Register 2 bit 4
                                 .equ	GPIOR25	= 5	; General Purpose IO Register 2 bit 5
                                 .equ	GPIOR26	= 6	; General Purpose IO Register 2 bit 6
                                 .equ	GPIOR27	= 7	; General Purpose IO Register 2 bit 7
                                 
                                 ; GPIOR1 - General Purpose IO Register 1
                                 .equ	GPIOR10	= 0	; General Purpose IO Register 1 bit 0
                                 .equ	GPIOR11	= 1	; General Purpose IO Register 1 bit 1
                                 .equ	GPIOR12	= 2	; General Purpose IO Register 1 bit 2
                                 .equ	GPIOR13	= 3	; General Purpose IO Register 1 bit 3
                                 .equ	GPIOR14	= 4	; General Purpose IO Register 1 bit 4
                                 .equ	GPIOR15	= 5	; General Purpose IO Register 1 bit 5
                                 .equ	GPIOR16	= 6	; General Purpose IO Register 1 bit 6
                                 .equ	GPIOR17	= 7	; General Purpose IO Register 1 bit 7
                                 
                                 ; GPIOR0 - General Purpose IO Register 0
                                 .equ	GPIOR00	= 0	; General Purpose IO Register 0 bit 0
                                 .equ	GPIOR01	= 1	; General Purpose IO Register 0 bit 1
                                 .equ	GPIOR02	= 2	; General Purpose IO Register 0 bit 2
                                 .equ	GPIOR03	= 3	; General Purpose IO Register 0 bit 3
                                 .equ	GPIOR04	= 4	; General Purpose IO Register 0 bit 4
                                 .equ	GPIOR05	= 5	; General Purpose IO Register 0 bit 5
                                 .equ	GPIOR06	= 6	; General Purpose IO Register 0 bit 6
                                 .equ	GPIOR07	= 7	; General Purpose IO Register 0 bit 7
                                 
                                 ; PRR1 - Power Reduction Register1
                                 .equ	PRUSART1	= 0	; Power Reduction USART1
                                 .equ	PRTIM3	= 3	; Power Reduction Timer/Counter3
                                 .equ	PRUSB	= 7	; Power Reduction USB
                                 
                                 ; PRR0 - Power Reduction Register0
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRUSART0	= 1	; Power Reduction USART
                                 .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
                                 .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
                                 .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
                                 .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
                                 .equ	PRTWI	= 7	; Power Reduction TWI
                                 
                                 ; CLKSTA - 
                                 .equ	EXTON	= 0	; 
                                 .equ	RCON	= 1	; 
                                 
                                 ; CLKSEL0 - 
                                 .equ	CLKS	= 0	; 
                                 .equ	EXTE	= 2	; 
                                 .equ	RCE	= 3	; 
                                 .equ	EXSUT0	= 4	; 
                                 .equ	EXSUT1	= 5	; 
                                 .equ	RCSUT0	= 6	; 
                                 .equ	RCSUT1	= 7	; 
                                 
                                 ; CLKSEL1 - 
                                 .equ	EXCKSEL0	= 0	; 
                                 .equ	EXCKSEL1	= 1	; 
                                 .equ	EXCKSEL2	= 2	; 
                                 .equ	EXCKSEL3	= 3	; 
                                 .equ	RCCKSEL0	= 4	; 
                                 .equ	RCCKSEL1	= 5	; 
                                 .equ	RCCKSEL2	= 6	; 
                                 .equ	RCCKSEL3	= 7	; 
                                 
                                 
                                 ; ***** PLL **************************
                                 ; PLLCSR - PLL Status and Control register
                                 .equ	PLOCK	= 0	; PLL Lock Status Bit
                                 .equ	PLLE	= 1	; PLL Enable Bit
                                 .equ	PINDIV	= 4	; PLL prescaler Bit 2
                                 
                                 ; PLLFRQ - PLL Frequency Control Register
                                 .equ	PDIV0	= 0	; 
                                 .equ	PDIV1	= 1	; 
                                 .equ	PDIV2	= 2	; 
                                 .equ	PDIV3	= 3	; 
                                 .equ	PLLTM0	= 4	; 
                                 .equ	PLLTM1	= 5	; 
                                 .equ	PLLUSB	= 6	; 
                                 .equ	PINMUX	= 7	; 
                                 
                                 
                                 ; ***** USB_DEVICE *******************
                                 ; USBCON - USB General Control Register
                                 .equ	VBUSTE	= 0	; 
                                 .equ	OTGPADE	= 4	; 
                                 .equ	FRZCLK	= 5	; 
                                 .equ	USBE	= 7	; 
                                 
                                 ; UDCON - 
                                 .equ	DETACH	= 0	; 
                                 .equ	RMWKUP	= 1	; 
                                 .equ	LSM	= 2	; USB low speed mode
                                 .equ	RSTCPU	= 3	; 
                                 
                                 ; UDINT - 
                                 .equ	SUSPI	= 0	; 
                                 .equ	SOFI	= 2	; 
                                 .equ	EORSTI	= 3	; 
                                 .equ	WAKEUPI	= 4	; 
                                 .equ	EORSMI	= 5	; 
                                 .equ	UPRSMI	= 6	; 
                                 
                                 ; UDIEN - 
                                 .equ	SUSPE	= 0	; 
                                 .equ	SOFE	= 2	; 
                                 .equ	EORSTE	= 3	; 
                                 .equ	WAKEUPE	= 4	; 
                                 .equ	EORSME	= 5	; 
                                 .equ	UPRSME	= 6	; 
                                 
                                 ; UDADDR - 
                                 .equ	UADD0	= 0	; 
                                 .equ	UADD1	= 1	; 
                                 .equ	UADD2	= 2	; 
                                 .equ	UADD3	= 3	; 
                                 .equ	UADD4	= 4	; 
                                 .equ	UADD5	= 5	; 
                                 .equ	UADD6	= 6	; 
                                 .equ	ADDEN	= 7	; 
                                 
                                 ; UDFNUML - 
                                 .equ	FNUM0	= 0	; 
                                 .equ	FNUM1	= 1	; 
                                 .equ	FNUM2	= 2	; 
                                 .equ	FNUM3	= 3	; 
                                 .equ	FNUM4	= 4	; 
                                 .equ	FNUM5	= 5	; 
                                 .equ	FNUM6	= 6	; 
                                 .equ	FNUM7	= 7	; 
                                 
                                 ; UDFNUMH - 
                                 .equ	FNUM8	= 0	; 
                                 .equ	FNUM9	= 1	; 
                                 .equ	FNUM10	= 2	; 
                                 
                                 ; UDMFN - 
                                 .equ	FNCERR	= 4	; 
                                 
                                 ; UEINTX - 
                                 .equ	TXINI	= 0	; 
                                 .equ	STALLEDI	= 1	; 
                                 .equ	RXOUTI	= 2	; 
                                 .equ	RXSTPI	= 3	; 
                                 .equ	NAKOUTI	= 4	; 
                                 .equ	RWAL	= 5	; 
                                 .equ	NAKINI	= 6	; 
                                 .equ	FIFOCON	= 7	; 
                                 
                                 ; UENUM - 
                                 .equ	UENUM_0	= 0	; 
                                 .equ	UENUM_1	= 1	; 
                                 .equ	UENUM_2	= 2	; 
                                 
                                 ; UERST - 
                                 .equ	EPRST0	= 0	; 
                                 .equ	EPRST1	= 1	; 
                                 .equ	EPRST2	= 2	; 
                                 .equ	EPRST3	= 3	; 
                                 .equ	EPRST4	= 4	; 
                                 .equ	EPRST5	= 5	; 
                                 .equ	EPRST6	= 6	; 
                                 
                                 ; UECONX - 
                                 .equ	EPEN	= 0	; 
                                 .equ	RSTDT	= 3	; 
                                 .equ	STALLRQC	= 4	; 
                                 .equ	STALLRQ	= 5	; 
                                 
                                 ; UECFG0X - 
                                 .equ	EPDIR	= 0	; 
                                 .equ	EPTYPE0	= 6	; 
                                 .equ	EPTYPE1	= 7	; 
                                 
                                 ; UECFG1X - 
                                 .equ	ALLOC	= 1	; 
                                 .equ	EPBK0	= 2	; 
                                 .equ	EPBK1	= 3	; 
                                 .equ	EPSIZE0	= 4	; 
                                 .equ	EPSIZE1	= 5	; 
                                 .equ	EPSIZE2	= 6	; 
                                 
                                 ; UESTA0X - 
                                 .equ	NBUSYBK0	= 0	; 
                                 .equ	NBUSYBK1	= 1	; 
                                 .equ	DTSEQ0	= 2	; 
                                 .equ	DTSEQ1	= 3	; 
                                 .equ	UNDERFI	= 5	; 
                                 .equ	OVERFI	= 6	; 
                                 .equ	CFGOK	= 7	; 
                                 
                                 ; UESTA1X - 
                                 .equ	CURRBK0	= 0	; 
                                 .equ	CURRBK1	= 1	; 
                                 .equ	CTRLDIR	= 2	; 
                                 
                                 ; UEIENX - 
                                 .equ	TXINE	= 0	; 
                                 .equ	STALLEDE	= 1	; 
                                 .equ	RXOUTE	= 2	; 
                                 .equ	RXSTPE	= 3	; 
                                 .equ	NAKOUTE	= 4	; 
                                 .equ	NAKINE	= 6	; 
                                 .equ	FLERRE	= 7	; 
                                 
                                 ; UEDATX - 
                                 .equ	DAT0	= 0	; 
                                 .equ	DAT1	= 1	; 
                                 .equ	DAT2	= 2	; 
                                 .equ	DAT3	= 3	; 
                                 .equ	DAT4	= 4	; 
                                 .equ	DAT5	= 5	; 
                                 .equ	DAT6	= 6	; 
                                 .equ	DAT7	= 7	; 
                                 
                                 ; UEBCLX - 
                                 .equ	BYCT0	= 0	; 
                                 .equ	BYCT1	= 1	; 
                                 .equ	BYCT2	= 2	; 
                                 .equ	BYCT3	= 3	; 
                                 .equ	BYCT4	= 4	; 
                                 .equ	BYCT5	= 5	; 
                                 .equ	BYCT6	= 6	; 
                                 .equ	BYCT7	= 7	; 
                                 
                                 ; UEINT - 
                                 .equ	EPINT0	= 0	; 
                                 .equ	EPINT1	= 1	; 
                                 .equ	EPINT2	= 2	; 
                                 .equ	EPINT3	= 3	; 
                                 .equ	EPINT4	= 4	; 
                                 .equ	EPINT5	= 5	; 
                                 .equ	EPINT6	= 6	; 
                                 
                                 ; USBINT - 
                                 .equ	VBUSTI	= 0	; 
                                 
                                 ; USBSTA - 
                                 .equ	VBUS	= 0	; 
                                 .equ	SPEED	= 3	; 
                                 
                                 ; USBCON - USB General Control Register
                                 ;.equ	VBUSTE	= 0	; 
                                 ;.equ	OTGPADE	= 4	; 
                                 ;.equ	FRZCLK	= 5	; 
                                 ;.equ	USBE	= 7	; 
                                 
                                 ; UHWCON - 
                                 .equ	UVREGE	= 0	; 
                                 
                                 ; TWCR - Two-Wire Interface Control
                                 .equ		TWIE	= 0	;
                                 .equ 		TWEN	= 2	;
                                 .equ 		TWWC	= 3	;
                                 .equ 		TWSTO	= 4	;
                                 .equ 		TWSTA	= 5	;
                                 .equ 		TWEA	= 6	;
                                 .equ 		TWINT	= 7	;
                                 
                                 ; TWSR - Two-Wire Status
                                 .equ 		TWPS0	= 0	;
                                 .equ 		TWPS1	= 1	;
                                 
                                 ; TWAR
                                 .equ 		TWGCE	= 0	;
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lock bit
                                 .equ	LB2	= 1	; Lock bit
                                 .equ	BLB01	= 2	; Boot Lock bit
                                 .equ	BLB02	= 3	; Boot Lock bit
                                 .equ	BLB11	= 4	; Boot lock bit
                                 .equ	BLB12	= 5	; Boot lock bit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	CKSEL2	= 2	; Select Clock Source
                                 .equ	CKSEL3	= 3	; Select Clock Source
                                 .equ	SUT0	= 4	; Select start-up time
                                 .equ	SUT1	= 5	; Select start-up time
                                 .equ	CKOUT	= 6	; Oscillator options
                                 .equ	CKDIV8	= 7	; Divide clock by 8
                                 
                                 ; HIGH fuse bits
                                 .equ	BOOTRST	= 0	; Select Reset Vector
                                 .equ	BOOTSZ0	= 1	; Select Boot Size
                                 .equ	BOOTSZ1	= 2	; Select Boot Size
                                 .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
                                 .equ	WDTON	= 4	; Watchdog timer always on
                                 .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
                                 .equ	JTAGEN	= 6	; Enable JTAG
                                 .equ	OCDEN	= 7	; Enable OCD
                                 
                                 ; EXTENDED fuse bits
                                 .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
                                 .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
                                 .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
                                 .equ	HWBE	= 3	; Hardware Boot Enable
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x3fff	; Note: Word address
                                 .equ	IOEND	= 0x00ff
                                 .equ	SRAM_START	= 0x0100
                                 .equ	SRAM_SIZE	= 2560
                                 .equ	RAMEND	= 0x0aff
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x03ff
                                 .equ	EEPROMEND	= 0x03ff
                                 .equ	EEADRBITS	= 10
                                 #pragma AVRPART MEMORY PROG_FLASH 32768
                                 #pragma AVRPART MEMORY EEPROM 1024
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 2560
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	NRWW_START_ADDR	= 0x3800
                                 .equ	NRWW_STOP_ADDR	= 0x3fff
                                 .equ	RWW_START_ADDR	= 0x0
                                 .equ	RWW_STOP_ADDR	= 0x37ff
                                 .equ	PAGESIZE	= 64
                                 .equ	FIRSTBOOTSTART	= 0x3f00
                                 .equ	SECONDBOOTSTART	= 0x3e00
                                 .equ	THIRDBOOTSTART	= 0x3c00
                                 .equ	FOURTHBOOTSTART	= 0x3800
                                 .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
                                 .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	INT1addr	= 0x0004	; External Interrupt Request 1
                                 .equ	INT2addr	= 0x0006	; External Interrupt Request 2
                                 .equ	INT3addr	= 0x0008	; External Interrupt Request 3
                                 .equ	Reserved1addr	= 0x000a	; Reserved1
                                 .equ	Reserved2addr	= 0x000c	; Reserved2
                                 .equ	INT6addr	= 0x000e	; External Interrupt Request 6
                                 .equ	Reserved3addr	= 0x0010	; Reserved3
                                 .equ	PCI0addr	= 0x0012	; Pin Change Interrupt Request 0
                                 .equ	USB_GENaddr	= 0x0014	; USB General Interrupt Request
                                 .equ	USB_COMaddr	= 0x0016	; USB Endpoint/Pipe Interrupt Communication Request
                                 .equ	WDTaddr	= 0x0018	; Watchdog Time-out Interrupt
                                 .equ	Reserved4addr	= 0x001a	; Reserved4
                                 .equ	Reserved5addr	= 0x001c	; Reserved5
                                 .equ	Reserved6addr	= 0x001e	; Reserved6
                                 .equ	ICP1addr	= 0x0020	; Timer/Counter1 Capture Event
                                 .equ	OC1Aaddr	= 0x0022	; Timer/Counter1 Compare Match A
                                 .equ	OC1Baddr	= 0x0024	; Timer/Counter1 Compare Match B
                                 .equ	OC1Caddr	= 0x0026	; Timer/Counter1 Compare Match C
                                 .equ	OVF1addr	= 0x0028	; Timer/Counter1 Overflow
                                 .equ	OC0Aaddr	= 0x002a	; Timer/Counter0 Compare Match A
                                 .equ	OC0Baddr	= 0x002c	; Timer/Counter0 Compare Match B
                                 .equ	OVF0addr	= 0x002e	; Timer/Counter0 Overflow
                                 .equ	SPIaddr	= 0x0030	; SPI Serial Transfer Complete
                                 .equ	URXC1addr	= 0x0032	; USART1, Rx Complete
                                 .equ	UDRE1addr	= 0x0034	; USART1 Data register Empty
                                 .equ	UTXC1addr	= 0x0036	; USART1, Tx Complete
                                 .equ	ACIaddr	= 0x0038	; Analog Comparator
                                 .equ	ADCCaddr	= 0x003a	; ADC Conversion Complete
                                 .equ	ERDYaddr	= 0x003c	; EEPROM Ready
                                 .equ	ICP3addr	= 0x003e	; Timer/Counter3 Capture Event
                                 .equ	OC3Aaddr	= 0x0040	; Timer/Counter3 Compare Match A
                                 .equ	OC3Baddr	= 0x0042	; Timer/Counter3 Compare Match B
                                 .equ	OC3Caddr	= 0x0044	; Timer/Counter3 Compare Match C
                                 .equ	OVF3addr	= 0x0046	; Timer/Counter3 Overflow
                                 .equ	TWIaddr	= 0x0048	; 2-wire Serial Interface
                                 .equ	SPMRaddr	= 0x004a	; Store Program Memory Read
                                 .equ	OC4Aaddr	= 0x004c	; Timer/Counter4 Compare Match A
                                 .equ	OC4Baddr	= 0x004e	; Timer/Counter4 Compare Match B
                                 .equ	OC4Daddr	= 0x0050	; Timer/Counter4 Compare Match D
                                 .equ	OVF4addr	= 0x0052	; Timer/Counter4 Overflow
                                 .equ	TIMER4_FPFaddr	= 0x0054	; Timer/Counter4 Fault Protection Interrupt
                                 
                                 .equ	INT_VECTORS_SIZE	= 86	; size in words
                                 
                                 #endif  /* _M32U4DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;***********************************************************
                                 ;*
                                 ;*	This is the TRANSMIT skeleton file for Lab 7 of ECE 375
                                 ;*
                                 ;*  	Rock Paper Scissors
                                 ;* 	Requirement:
                                 ;* 	1. USART1 communication
                                 ;* 	2. Timer/counter1 Normal mode to create a 1.5-sec delay
                                 ;***********************************************************
                                 ;*
                                 ;*	 Author: Ian Kiser, Evan Shishido
                                 ;*	   Date: 12/6/2024
                                 ;*
                                 ;***********************************************************
                                 
                                 .include "m32U4def.inc"         ; Include definition file
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32U4.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32U4def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32U4
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32U4
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32U4DEF_INC_
                                 #endif  /* _M32U4DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ;***********************************************************
                                 ;*  Internal Register Definitions and Constants
                                 ;***********************************************************
                                 .def    mpr = r16    ; Multi-Purpose Register		
                                 .def	choice_left = r17
                                 .def	choice_right = r18 ;makes sense to store choice values seperately from LCD because it will be easier to send between boards and interract with LCD
                                 .def	data = r19
                                 .def	interrupt_select = r23
                                 ;r20-r22 reserved by LCD driver
                                 
                                 ; Use this signal code between two boards for their game ready
                                 .equ    SendReady = 0b11111111
                                 
                                 ;***********************************************************
                                 ;*  Start of Code Segment
                                 ;***********************************************************
                                 .cseg                           ; Beginning of code segment
                                 
                                 ;***********************************************************
                                 ;*  Interrupt Vectors
                                 ;***********************************************************
                                 .org    $0000                   ; Beginning of IVs
000000 c055                      	    rjmp    INIT            	; Reset interrupt
                                 
                                 .org		$0002 ;int 0, will be tied to PD4, interrupts will need EIMSK, and EICRA/B registers set correctly
                                 		;select choice left
000002 d118                      		rcall interrupt_left
000003 9518                      		reti
                                 
                                 .org		$0004 ;int 1, might be tied to PD5, for extra credit
                                 		;select choice right
000004 d10b                      		rcall interrupt_right
000005 9518                      		reti
                                 
                                 .org	$0028 ;timer counter 1 overflow interrupt
                                 		
000028 d0c9                      		rcall timer_interrupt
000029 9518                      		reti
                                 .org	$0032 ; recieve flag interrupt
000032 d15d                      rcall recieve
000033 9518                      reti
                                 
                                 ;.org read interrupt vector on usart 1
                                 
                                 .org    $0056                   ; End of Interrupt Vectors
                                 
                                 ;***********************************************************
                                 ;*  Program Initialization
                                 ;***********************************************************
                                 INIT:
                                 	;Stack Pointer (VERY IMPORTANT!!!!)
000056 ef0f                      	ldi mpr, low(RAMEND) ;retrieve ramend low from program memory
000057 bf0d                      	out SPL, mpr ;load ramend low into stack pointer low via mpr, out is needed as SP(stack pointer) is in io mem
000058 e00a                      	ldi mpr, high(RAMEND);retrieve ramend high from program memory
000059 bf0e                      	out SPH, mpr ;load ramend high into stack pointer low via mpr
                                 	
                                 
                                 
                                 	;I/O Ports
                                 	;port D -> input for button presses, 
00005a e000                      	ldi mpr, 0
00005b b90a                      	out DDRD, mpr ;set portD for input
00005c ef0f                      	ldi mpr, $FF
00005d b90b                      	out PORTD, mpr ;set pull up resistors
                                 
                                 	;port B -> PORTB[4:7] output for LED countdown/timer counter, PB[0:2] used by LCD driver
00005e ef0f                      	ldi mpr, $FF
00005f b904                      	out DDRB, mpr; set PORTB for output 
                                 
                                 	;configure external interrupts to trigger on falling edge ie button pressed, pin shorted to ground, for int0 and int1
                                 	;EICRA gets 0b00001010
000060 e00a                      	ldi mpr, 0b00001010
000061 9300 0069                 	sts EICRA, mpr
                                 
                                 	 
                                 
                                 
                                 
                                 	;USART1
                                 	;Set baudrate at 2400bps -> I believe system clock is 8MHz, therefore UBRR gets 207 by table 18-4 in data sheet
                                 	;Enable receiver and transmitter
                                 	;Set frame format: 8 data bits, 2 stop bits
                                 	;do not use SBI and CBI, and sbis sbic because of fifo 
                                 
                                 	;UCSR1A: bit 7 RXC1(recieve complete) -> 0, bit 6 TXC1 (transmit complete) -> 0, bit 5 UDRE1 (data reg empty) -> 1, error bits[4:2] -> 0
                                 	; bit 1 U2X1 (double transmit speed) -> 0 for normal speed, bit 0 MPCM1 (multi processor communication) -> 0 (do not want to send address info)
                                 
                                 	;UCSR1B: bit 7 RXCIE1 (RX complete interrupt enable) -> set for interrupt, bit 6 TXCIE1 (TX interrupt) -> set for interrupt, bit 5 UDRIE1 (interrupt for UDRE1 flag) -> set for interrupt
                                 	;bit 4 RXEN1 (reciever enable) -> 1, bit 3 TXEN1 (transmit enable) -> 1, bit 2 UCSZ12 (character size) -> 0 for 8 bit characters, bits[1:0] RX/TX 81 (recieve and transmit data bit 8) -> 0 I think since frams will be 8 bit  
                                 	
                                 	;UCSR1C: bits [7:6] UMSEL1 1/0 (usart mode select) -> 00 for asychronous, UPM1 1/0 (parit mode) -> 00 for disabled, bit 3 USBS1 (stop bit select) -> 1 for 2 bit, bits [2:1] UCSZ1 [1:0] (character size) -> 11 for 8 bit,
                                 	; bit 0 UCPOL1 (clock polarity) -> 0 for falling edge
                                 
                                 	;UCSR1D: might need to set bits 1:0 but probably not, they control something called transmission and reception flow control
                                 
                                 	;UCSR1A need not be loaded
                                 	;UCSR1B gets 0b10011000 -> enable read interrupt
                                 	;UCSR1C gets 0b00001110
                                 	;UBRRH1 gets 0b00000000
                                 	;UBRRL1 gets $CF -> 207
                                 
                                 
000063 e908                      	ldi mpr, 0b10011000 ; enable read interrupt
000064 9300 00c9                 	sts UCSR1B, mpr
000066 e00e                      	ldi mpr, 0b00001110
000067 9300 00ca                 	sts UCSR1C, mpr
                                 
000069 e000                      	ldi mpr, 0
00006a 9300 00cd                 	sts UBRR1H, mpr
00006c ec0f                      	ldi mpr, $CF
00006d 9300 00cc                 	sts UBRR1L, mpr
                                 
                                 
                                 	;TIMER/COUNTER1
                                 	;Set Normal mode
                                 	;No need for external pin interrupts -> all OC bits set low, Normal mode -> WGM bits low as well
                                 	;TCCR1A gets 0b00000000, This is initial value by default, no need to load
                                 	;no ICN stabilization, normal mode, and 1/256 prescaling -> TOV flag set about every 1.5 seconds when TCNT initially gets 48E4
                                 	;TCCR1B gets 0b00000010
00006f e000                      	ldi mpr, 0b00000000
000070 9300 0080                 	sts TCCR1A, mpr
000072 e004                      	ldi mpr, 0b00000100
000073 9300 0081                 	sts TCCR1B, mpr
                                 
                                 	
                                 
                                 	
                                 
                                 	;Other
000075 d256                      	rcall LCDInit
000076 d277                      	rcall LCDBacklightOn 
000077 d293                      	rcall LCDClr
                                 	
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*  Main Program
                                 ;***********************************************************
                                 MAIN:
000078 9478                      sei
                                 
                                 
000079 e010                      ldi choice_left, 0
00007a e020                      ldi choice_right, 0
00007b e030                      ldi data, 0
00007c e070                      ldi interrupt_select, 0; interrupts now do choice select
                                 
00007d 9478                      sei
                                 ;launch to welcome screen, poll for PD7
                                 ;loop until PD7 pressed
00007e d122                      rcall welcome
                                 
                                 
                                 ;welcome start
                                 
                                 ;PD7 pressed
                                 ;begin continuously transmitting ready signal
                                 ;enable recieve interrupt 
                                 ;display ready and waiting screen
                                 
00007f ef0f                      ldi mpr, SendReady
000080 d0a5                      rcall transmit
                                 
                                 
                                 ;display game start
000081 d289                      rcall LCDClr
                                 
                                 ;simulated button presses
                                 
                                 
000082 d0fe                      rcall game_start
000083 e003                      ldi mpr, 0b00000011
000084 bb0d                      out EIMSK, mpr ;make sure pd4 and pd5 on correct interrupts
                                 
                                 ;welcome end
                                 
                                 ;select start
                                 
                                 
                                 ;wait 1.5 seconds
                                 ;start LED timer
000085 d061                      rcall LED_countdown
                                 
                                 
                                 
                                 ;timer ends
                                 ;disable int 0 (and possibly int 1 if extra credit) in interrupt mask
000086 e000                      ldi mpr, 0
000087 bb0d                      out EIMSK, mpr
000088 d282                      rcall LCDClr
                                 
                                 ;select end
                                 
                                 
                                 
                                 
                                 ;transmit select start
                                 
                                 ;choice_left and choice right now hold user choices 
                                 ;store on stack
000089 931f                      push choice_left
00008a 932f                      push choice_right;user choices now saved
                                 
00008b e830                      ldi data, 0b10000000 ;like verify in transmit, but needed to ensure read was succsessful
00008c d0ef                      rcall send_recieve_choice_left
                                 
                                 main_loop_recieve_left:
00008d d10c                      rcall check_UDR1
00008e 3830                      cpi data, 0b10000000
00008f f3e9                      breq main_loop_recieve_left ;wait until left recieved
                                 
                                 ;data now holds opponant choice left
000090 2f13                      mov choice_left, data; choice left now holds opponant choice left
                                 
000091 e830                      ldi data, 0b10000000
000092 d0e4                      rcall send_recieve_choice_right
                                 
                                 main_loop_recieve_choice_right:
000093 d106                      rcall check_UDR1
000094 3830                      cpi data, 0b10000000
000095 f3e9                      breq main_loop_recieve_choice_right
                                 
000096 2f23                      mov choice_right, data; choice right now holds opponant choice right
                                 
                                 
                                 
                                 ;display opponant choices
000097 d234                      rcall LCDInit
000098 d13d                      rcall load_choice_left
000099 d18c                      rcall print_zy_top
00009a d159                      rcall load_choice_right
00009b d1a0                      rcall print_yz_top
                                 
                                 
                                 ;swap stack values
00009c 910f                      pop mpr ;mpr now has user choice right
00009d 913f                      pop data ;data now has user choice left
00009e 931f                      push choice_left
00009f 932f                      push choice_right ;opponant choices now on stack
                                 
0000a0 2f20                      mov choice_right, mpr 
0000a1 2f13                      mov choice_left, data ;choice registers now have user choices
                                 
0000a2 d229                      rcall LCDInit
                                 ;display user choices
0000a3 d132                      rcall load_choice_left
0000a4 d1b7                      rcall print_zy_bottom
0000a5 d14e                      rcall load_choice_right
0000a6 d1cb                      rcall print_yz_bottom
                                 
                                 
                                 ;transmit select end
                                 
                                 
                                 
0000a7 d178                      rcall timer_1_5
                                 
                                 
                                 
                                 ;shoot start
                                 
                                 
                                 
                                 
                                 
                                 ;enable EIMSk
0000a8 e001                      ldi mpr, 1 ;defualt shoot select
0000a9 e071                      ldi interrupt_select, 1 ;interrupts now do shoot
0000aa e003                      ldi mpr, 0b00000011
0000ab bb0d                      out EIMSK, mpr ;
                                 ;timer start again
                                 
                                 
0000ac d03a                      rcall LED_countdown
                                 
                                 ;timer ends
                                 ;disable EIMSK again
0000ad e070                      ldi interrupt_select,0
0000ae bb0d                      out EIMSK, mpr
0000af e071                      ldi interrupt_select,1
                                 
                                 ;shoot end
                                 
                                 
                                 ;transmit shoot start
                                 ;mpr now holds user shoot value, data holds opponant shoot value
                                 ;do shoot func
0000b0 3003                      cpi mpr, 3
0000b1 f011                      breq main_do_shoot_left
0000b2 3004                      cpi mpr, 4
0000b3 f011                      breq main_do_shoot_right
                                 
                                 
                                 main_do_shoot_left:
0000b4 d093                      rcall do_shoot_left
0000b5 c001                      rjmp main_end_do_shoot
                                 
                                 main_do_shoot_right:
0000b6 d0a9                      rcall do_shoot_right
                                 
                                 
                                 
                                 main_end_do_shoot:
                                 
                                 ;transmit shoot end
                                 
                                 
                                 ;finish
                                 
0000b7 d253                      rcall LCDClr
                                 ;display win/lose screen
0000b8 d003                      rcall calculate_results
                                 ;timer start again
0000b9 d02d                      rcall LED_countdown
                                 
                                 ;timer ends
                                 ;restart code
0000ba d250                      rcall LCDClr
0000bb cfbc                      rjmp MAIN
                                 
                                 ;***********************************************************
                                 ;*	Functions and Subroutines
                                 ;***********************************************************
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	func: calculate results
                                 ;*	desc: based on choice left and choice right displays the correct win or lose screen 
                                 ;***********************************************************
                                 calculate_results:
0000bc 930f                      push mpr
0000bd 931f                      push choice_left
0000be 932f                      push choice_right
                                 
                                 
0000bf d116                      rcall load_choice_left
0000c0 d19b                      rcall print_zy_bottom
0000c1 d20a                      rcall LCDInit ;werid LCD driver errors happen without this
                                 
                                 ;left - right
                                 ; 0-0 = 0 tie
                                 ; 0-1 = -1 lose
                                 ; 0-2 = -2 lose < 1
                                 ; 0-3 = -3 lose
                                 ; 1-0 = 1 win
                                 ; 1-1 = 0 tie
                                 ; 1-2 = -1 lose
                                 ; 1-3 = -2 win < 1
                                 ; 2-0 = 2 win < 2
                                 ; 2-1 = 1 win
                                 ; 2-2 = 0 tie
                                 ; 2-3 = -1 lose
                                 ; 3-0 = 3 win
                                 ; 3-1 = 2 lose < 2
                                 ; 3-2 = 1 win
                                 ; 3-3 = 0 tie
                                 
                                 
                                 ;0 is tie
                                 ;left is 0 is lose
                                 ;right is 0 is win 
                                 ; -1 is lose
                                 ; -2 is win (lose case is handled by left is 0 is lose)
                                 ; -3 is lose (redundant since left has to be zero here)
                                 ; 1 is win
                                 ; 2 is lose (win case is handled by right is 0 is win)
                                 ; 3 is win (redundant since right has to be zero here)
                                 
                                 
0000c2 2f01                      mov mpr, choice_left
0000c3 1b02                      sub mpr, choice_right
                                 
0000c4 3000                      cpi mpr, 0
0000c5 f091                      breq draw
                                 
0000c6 3010                      cpi choice_left, 0
0000c7 f0b1                      breq lose
                                 
0000c8 3020                      cpi choice_right, 0
0000c9 f041                      breq win
                                 
0000ca 3f0f                      cpi mpr, -1
0000cb f091                      breq lose
                                 
0000cc 3f0e                      cpi mpr, -2
0000cd f021                      breq win
                                 
0000ce 3001                      cpi mpr, 1
0000cf f011                      breq win
                                 
0000d0 3002                      cpi mpr, 2
0000d1 f061                      breq lose
                                 
                                 
                                  
                                 win:
                                 
0000d2 e4ec                      ldi ZL, low(str_win<<1)
0000d3 e0f5                      ldi ZH, high(str_win<<1)
0000d4 e5c4                      ldi YL, low(str_win_end<<1)
0000d5 e0d5                      ldi YH, high(str_win_end<<1)
                                 
0000d6 d14f                      rcall print_zy_top
                                 
0000d7 c00b                      rjmp calculate_results_end
                                 
                                 
                                 draw:
                                 
0000d8 e3e2                      ldi ZL, low(str_draw<<1)
0000d9 e0f5                      ldi ZH, high(str_draw<<1)
0000da e3cc                      ldi YL, low(str_draw_end<<1)
0000db e0d5                      ldi YH, high(str_draw_end<<1)
                                 
0000dc d149                      rcall print_zy_top
                                 
0000dd c005                      rjmp calculate_results_end
                                 
                                 
                                 lose:
0000de e4e4                      ldi ZL, low(str_lose<<1)
0000df e0f5                      ldi ZH, high(str_lose<<1)
0000e0 e4cc                      ldi YL, low(str_lose_end<<1)
0000e1 e0d5                      ldi YH, high(str_lose_end<<1)
                                 
0000e2 d143                      rcall print_zy_top
                                 
                                 calculate_results_end:
                                 
0000e3 912f                      pop choice_right
0000e4 911f                      pop choice_left
0000e5 910f                      pop mpr
0000e6 9508                      ret
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: led_countdown
                                 ;*	desc: uses interrupts for countdown
                                 ;***********************************************************
                                 led_countdown:
0000e7 930f                      push mpr
                                 
0000e8 e001                      ldi mpr, 1
0000e9 9300 006f                 sts TIMSK1, mpr ;overflow interrupt now enabled
                                 
0000eb b105                      in mpr, PORTB
0000ec 6f00                      ori mpr, 0b11110000
0000ed b905                      out PORTB, mpr
                                 
                                 timer_loop:
0000ee 992f                      sbic PORTB,7
0000ef cffe                      rjmp timer_loop
                                 
                                 
                                 
0000f0 910f                      pop mpr
0000f1 9508                      ret
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: timer_interrupt
                                 ;*	desc: turns off correct LED in PORTB
                                 ;***********************************************************
                                 timer_interrupt:
                                 
                                 	;set TCNT1 so that an overflow is 1.5 seconds
0000f2 e408                      	ldi mpr, $48
0000f3 9300 0085                 	sts TCNT1H, mpr
0000f5 ee04                      	ldi mpr, $E4
0000f6 9300 0084                 	sts TCNT1L, mpr
                                 
                                 
0000f8 930f                      push mpr
0000f9 b70f                      in mpr, SREG
0000fa 930f                      push mpr
                                 
0000fb 992c                      sbic PORTB, 4
0000fc c005                      rjmp B4
                                 
0000fd 992d                      sbic PORTB, 5
0000fe c005                      rjmp B5
                                 
0000ff 992e                      sbic PORTB, 6
000100 c005                      rjmp B6
                                 
000101 c006                      rjmp B7
                                 
                                 
                                 B4:
000102 982c                      cbi PORTB, 4
000103 c008                      rjmp timer_interrupt_end
                                 
                                 B5:
000104 982d                      cbi PORTB, 5
000105 c006                      rjmp timer_interrupt_end
                                 
                                 B6:
000106 982e                      cbi PORTB, 6
000107 c004                      rjmp timer_interrupt_end
                                 
                                 B7:
000108 982f                      cbi PORTB, 7
000109 e000                      ldi mpr,0
00010a 9300 006f                 sts TIMSK1, mpr ;overflow interrupt now disabled
                                 
                                 timer_interrupt_end:
                                 
                                 
00010c 910f                      pop mpr
00010d bf0f                      out SREG, mpr
00010e 910f                      pop mpr
00010f 9508                      ret
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: interrupt_right
                                 ;*	desc: interrupt choice on PD4
                                 ;***********************************************************
                                 
                                 interrupt_right:
                                 
000110 930f                      push mpr
000111 b70f                      in mpr, SREG
000112 930f                      push mpr
                                 
                                 
                                 
000113 ff70                      sbrs interrupt_select, 0 ;if 0 bit is set, we want shoot interrupt
000114 d0b0                      rcall select_choice_right
                                 
000115 fd70                      sbrc interrupt_select, 0; if 0 bit is clear, we want select choice interrupt
000116 d027                      rcall shoot_right
                                 
                                 
                                 
000117 910f                      pop mpr
000118 bf0f                      out SREG, mpr
000119 910f                      pop mpr
00011a 9508                      ret
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: interrupt_left
                                 ;*	desc: interrupt choice on PD5
                                 ;***********************************************************
                                 
                                 interrupt_left:
00011b 930f                      push mpr
00011c b70f                      in mpr, SREG
00011d 930f                      push mpr
                                 
                                 
                                 
00011e ff70                      sbrs interrupt_select, 0 ;if 0 bit is set, we want shoot interrupt
00011f d094                      rcall select_choice_left
                                 
000120 fd70                      sbrc interrupt_select, 0; if 0 bit is clear, we want select choice interrupt
000121 d012                      rcall shoot_left
                                 
                                 
000122 910f                      pop mpr
000123 bf0f                      out SREG, mpr
000124 910f                      pop mpr
                                 
000125 9508                      ret
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: transmit
                                 ;*	desc: transmits mpr to UDR1
                                 ;***********************************************************
                                 transmit:
000126 930f                      push mpr
                                 
                                 transmit_loop:
                                 
000127 d072                      rcall check_UDR1
000128 94f8                      cli ;disable recieve interrupt
                                 
000129 e830                      ldi data, 0b10000000
00012a 9300 00ce                 sts UDR1, mpr
00012c d06d                      rcall check_UDR1
00012d 9478                      sei
00012e 0000                      nop
00012f d06a                      rcall check_UDR1; if recieve happens give it time to finish
000130 3830                      cpi data, 0b10000000
000131 f3a9                      breq transmit_loop
                                 
                                 
                                 
000132 910f                      pop mpr
000133 9508                      ret
                                 
                                 ;***********************************************************
                                 ;*	Func: shoot_left
                                 ;*	desc: loads mpr with correct shoot value then sends via usart, then disables interrupts, so only one shoot allowed
                                 ;***********************************************************
                                 shoot_left:
                                 
                                 
000134 e000                      ldi mpr, 0
000135 bb0d                      out EIMSK, mpr
                                 
                                 
000136 e2e4                      ldi ZL, low(str_clear<<1)
000137 e0f5                      ldi ZH, high(str_clear<<1)
                                 
000138 e2cc                      ldi YL, low(str_clear_end<<1)
000139 e0d5                      ldi YH, high(str_clear_end<<1)
                                 
00013a d0eb                      rcall print_zy_top
                                 
                                 
                                 
00013b e003                      ldi mpr, 3
00013c dfe9                      rcall transmit
                                 
00013d 9508                      ret ;save mpr shoot value
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: shoot_right
                                 ;*	desc: loads mpr with correct shoot value then sends via usart, then disables interrupts, so only one shoot allowed
                                 ;***********************************************************
                                 shoot_right:
                                 
                                 
00013e e000                      ldi mpr, 0
00013f bb0d                      out EIMSK, mpr
                                 
                                 
000140 e2e4                      ldi ZL, low(str_clear<<1)
000141 e0f5                      ldi ZH, high(str_clear<<1)
                                 
000142 e2cc                      ldi YL, low(str_clear_end<<1)
000143 e0d5                      ldi YH, high(str_clear_end<<1)
                                 
000144 d0f7                      rcall print_yz_top
                                 
                                 
                                 
                                 
000145 e004                      ldi mpr, 4
000146 dfdf                      rcall transmit
                                 
                                 
000147 9508                      ret ;save mpr shoot value
                                 
                                 
                                 
                                 ;**************************************************
                                 ;*	func: do_shoot_left
                                 ;*	desc: loads correct values into choice left and choice right, where respectively each is final user choice then final opponant choice
                                 ;**************************************************
                                 do_shoot_left:
                                 
                                 
                                 
                                 ;data now holds shoot value
                                 
                                 
                                 
000148 3031                      cpi data, 1
000149 f011                      breq do_shoot_left_left
00014a 3032                      cpi data, 2
00014b f039                      breq do_shoot_left_right
                                 
                                 
                                 do_shoot_left_left:
00014c 2f12                      mov choice_left, choice_right
                                 
00014d e2e4                      ldi ZL, low(str_clear<<1)
00014e e0f5                      ldi ZH, high(str_clear<<1)
                                 
00014f e2cc                      ldi YL, low(str_clear_end<<1)
000150 e0d5                      ldi YH, high(str_clear_end<<1)
                                 
000151 d10a                      rcall print_zy_bottom
                                 
000152 c005                      rjmp do_shoot_left_end_shoot
                                 
                                 do_shoot_left_right:
                                 ;nothing needs to be done, left already holds user choice
                                 
000153 e2e4                      ldi ZL, low(str_clear<<1)
000154 e0f5                      ldi ZH, high(str_clear<<1)
                                 
000155 e2cc                      ldi YL, low(str_clear_end<<1)
000156 e0d5                      ldi YH, high(str_clear_end<<1)
                                 
000157 d11a                      rcall print_yz_bottom
                                 
                                 do_shoot_left_end_shoot:
                                 
                                 ;opponant choice now shot and final now in choice_left
                                 
                                 
                                 
                                 ;stack has 
                                 ;opponant left
                                 ;opponant right
                                 ;do shoot call low or high
                                 ;do shoot call high or low
                                 
                                 
                                 ;save stack
                                 
000158 910f                      pop mpr
000159 913f                      pop data ;return call now saved
00015a 912f                      pop choice_right ; -> this will be saved
00015b 917f                      pop interrupt_select ;-> discard opponant left
00015c e071                      ldi interrupt_select, 1; restore interrupt select
                                 
                                 ;restore stack
00015d 933f                      push data
00015e 930f                      push mpr
                                 
                                 ;stack now restored without opponant choices
                                 ;choice left has user choice, choice right has opponant choice
                                 
                                 
00015f 9508                      ret
                                 
                                 
                                 
                                 
                                 
                                 ;**************************************************
                                 ;*	func: do_shoot_right
                                 ;*	desc: loads correct values into choice left and choice right, where respectively each is final user choice then final opponant choice
                                 ;**************************************************
                                 do_shoot_right:
                                 
                                 ;data now holds shoot value
                                 
                                 
                                 
000160 3031                      cpi data, 1
000161 f011                      breq do_shoot_right_left
000162 3032                      cpi data, 2
000163 f039                      breq do_shoot_right_right
                                 
                                 
                                 do_shoot_right_left:
000164 2f12                      mov choice_left, choice_right
                                 
000165 e2e4                      ldi ZL, low(str_clear<<1)
000166 e0f5                      ldi ZH, high(str_clear<<1)
                                 
000167 e2cc                      ldi YL, low(str_clear_end<<1)
000168 e0d5                      ldi YH, high(str_clear_end<<1)
                                 
000169 d0f2                      rcall print_zy_bottom
                                 
00016a c005                      rjmp do_shoot_right_end_shoot
                                 
                                 do_shoot_right_right:
                                 ;nothing needs to be done, left already holds user choice
                                 
                                 
00016b e2e4                      ldi ZL, low(str_clear<<1)
00016c e0f5                      ldi ZH, high(str_clear<<1)
                                 
00016d e2cc                      ldi YL, low(str_clear_end<<1)
00016e e0d5                      ldi YH, high(str_clear_end<<1)
                                 
00016f d102                      rcall print_yz_bottom
                                 
                                 do_shoot_right_end_shoot:
                                 
                                 ;user choice now in choice_left
                                 
                                 
                                 ;stack has 
                                 ;opponant left
                                 ;opponant right
                                 ;do shoot call high or low
                                 ;do shoot call low or high
                                 ;saved mpr
                                 
                                 ;save stack
000170 910f                      pop mpr
000171 913f                      pop data ;ret call now saved
000172 912f                      pop choice_right ; -> this will be discarded
000173 912f                      pop choice_right ; -> discard choice right, save choice left
                                 
                                 ;restore stack
000174 933f                      push data
000175 930f                      push mpr
                                 ;stack now restored without opponant choices
                                 ;choice left has user choice, choice right has opponant choice
                                 
                                 
000176 9508                      ret
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: send_recieve_choice_right
                                 ;*	desc: transmits choice left and waits for verfication of reception
                                 ;***********************************************************
                                 send_recieve_choice_right:
000177 930f                      push mpr
                                 
                                 ;load data with known value
                                 ;load mpr with choice_left
                                 ;call transmit
                                 ;compare data with value
                                 ;if data not value continue otherwise loop
                                 
                                 send_recieve_choice_right_loop:
                                 
000178 2f01                      mov mpr, choice_left
000179 dfac                      rcall transmit
                                 
                                 
                                 
00017a 910f                      pop mpr
00017b 9508                      ret
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: send_recieve_choice_left
                                 ;*	desc: transmits choice left and waits for verfication of reception
                                 ;***********************************************************
                                 send_recieve_choice_left:
00017c 930f                      push mpr
                                 
                                 ;load data with known value
                                 ;load mpr with choice_left
                                 ;call transmit
                                 ;compare data with value
                                 ;if data not value continue otherwise loop
                                 
                                 
00017d 2f01                      mov mpr, choice_left
00017e dfa7                      rcall transmit
                                 
                                 
                                 
00017f 910f                      pop mpr
000180 9508                      ret
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: game_start
                                 ;*	desc: display game start and start countdown 
                                 ;***********************************************************
                                 game_start:
000181 93ef                      push ZL
000182 93ff                      push ZH
000183 93cf                      push YL
000184 93df                      push YH
                                 
000185 e8ea                      ldi ZL, low(str_game<<1)
000186 e0f5                      ldi ZH, high(str_game<<1)
000187 e9c4                      ldi YL, low(str_game_end<<1)
000188 e0d5                      ldi YH, high(str_game_end<<1)
000189 d09c                      rcall print_zy_top
00018a d095                      rcall timer_1_5
                                 
                                 
00018b 91df                      pop YH
00018c 91cf                      pop YL
00018d 91ff                      pop ZH
00018e 91ef                      pop ZL
00018f 9508                      ret
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: recieve
                                 ;*	desc: loads data register with usart reception value
                                 ;***********************************************************
                                 recieve:
000190 930f                      push mpr
000191 b70f                      in mpr, SREG
000192 930f                      push mpr
                                 
                                 
000193 9130 00ce                 lds data, UDR1
000195 d004                      rcall check_UDR1
                                 
                                 
000196 910f                      pop mpr
000197 bf0f                      out SREG, mpr
000198 910f                      pop mpr
000199 9508                      ret
                                 
                                 ;***********************************************************
                                 ;*	Func: check_UDR1
                                 ;*	desc: returns once the UDR1 register has been cleared, uses 
                                 ;***********************************************************
                                 check_UDR1:
00019a 930f                      push mpr
                                 
                                 check_UDR1_not_clear:
00019b 9100 00c8                 lds mpr, UCSR1A
00019d ff05                      sbrs mpr, 5
00019e f7e1                      brne check_UDR1_not_clear ;if data reg not empty wait for it to be empty
                                 
                                 
                                 
00019f 910f                      pop mpr
0001a0 9508                      ret
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: welcome
                                 ;*	desc: display welcome screen and poll for PD7, exit when pressed and then released
                                 ;***********************************************************
                                 welcome:
0001a1 930f                      push mpr
                                 
                                 
0001a2 e5e4                      ldi ZL, low(str_welcome1<<1)
0001a3 e0f5                      ldi ZH, high(str_welcome1<<1)
                                 
0001a4 e5cc                      ldi YL, low(str_welcome1_end<<1)
0001a5 e0d5                      ldi YH, high(str_welcome1_end<<1)
                                 
0001a6 d07f                      rcall print_zy_top
                                 
0001a7 e5ec                      ldi ZL, low(str_welcome2<<1)
0001a8 e0f5                      ldi ZH, high(str_welcome2<<1)
                                 
0001a9 e6cc                      ldi YL, low(str_welcome2_end<<1)
0001aa e0d5                      ldi YH, high(str_welcome2_end<<1)
                                 
0001ab d0b0                      rcall print_zy_bottom
                                 
                                 
                                 welcome_not_pressed:
0001ac 994f                      sbic PIND, PD7
0001ad cffe                      rjmp welcome_not_pressed
                                 ;PD7 is now pressed
0001ae 0000                      nop
0001af 0000                      nop ;avoid some debouncing
                                 welcome_pressed:
0001b0 9b4f                      sbis PIND, PD7
0001b1 cffe                      rjmp welcome_pressed
                                 ;PD7 is now released
                                 
                                 
                                 
0001b2 910f                      pop mpr
0001b3 9508                      ret
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: select_choice_left
                                 ;*	desc: cycles through choices for rock paper scissors and prints them to the LCD on the left hand side, preserves right hand side of LCD
                                 ;***********************************************************
                                 select_choice_left:
0001b4 930f                      push mpr
                                 
0001b5 994d                      sbic PIND, 5
0001b6 c00c                      rjmp select_choice_left_end
                                 
                                 ;changes made to choice left will be saved globally
                                 
                                 ;valid choice values include 1,2,3, for rock paper and scissors respectively. 0 will be initialization value so when button is first pressed rock is shown 
                                 ;check if choice left is 10, load with 00 if so
                                 ;otherwise increment choice left
                                 
0001b7 3013                      cpi choice_left, 3
0001b8 f011                      breq select_choice_left_rollover ;if at two do not increment
                                 
0001b9 9513                      inc choice_left
                                 
0001ba c001                      rjmp select_choice_left_chosen ;do not roll over if unneeded 
                                 
                                 select_choice_left_rollover:
0001bb e011                      ldi choice_left, 1
                                 
                                 select_choice_left_chosen:
                                 ;load z and y with labels for str clear
                                 ;call zy print function to write spaces to left hand side of LCD without clearing right hand side
                                 ;based on choice left value load Z and Y with appropriate labels for word
                                 ;call zy print function
                                 
0001bc e2e4                      ldi ZL, low(str_clear<<1)
0001bd e0f5                      ldi ZH, high(str_clear<<1)
                                 
0001be e2cc                      ldi YL, low(str_clear_end<<1)
0001bf e0d5                      ldi YH, high(str_clear_end<<1)
                                 
0001c0 d09b                      rcall print_zy_bottom ;write clear string to left side of LCD
0001c1 d014                      rcall load_choice_left ;load Z and Y registers with correct string lables
0001c2 d099                      rcall print_zy_bottom ;print correct choice of string to LCD
                                 
                                 select_choice_left_end:
                                 
0001c3 910f                      pop mpr
0001c4 9508                      ret
                                 ;end select_choice_left
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: select_choice_right
                                 ;*	desc: cycles through choices for rock paper scissors and prints them to the LCD on the left hand side, preserves right hand side of LCD
                                 ;***********************************************************
                                 select_choice_right:
0001c5 930f                      push mpr
                                 
0001c6 994c                      sbic PIND, 4
0001c7 c00c                      rjmp select_choice_right_end
                                 
                                 ;changes made to choice left will be saved globally
                                 
                                 ;valid choice values include 1,2,3, for rock paper and scissors respectively. 0 will be initialization value so when button is first pressed rock is shown 
                                 ;check if choice left is 10, load with 00 if so
                                 ;otherwise increment choice left
                                 
0001c8 3023                      cpi choice_right, 3
0001c9 f011                      breq select_choice_right_rollover ;if at two do not increment
                                 
0001ca 9523                      inc choice_right
                                 
0001cb c001                      rjmp select_choice_right_chosen ;do not roll over if unneeded 
                                 
                                 select_choice_right_rollover:
0001cc e021                      ldi choice_right, 1
                                 
                                 select_choice_right_chosen:
                                 ;load z and y with labels for str clear
                                 ;call zy print function to write spaces to left hand side of LCD without clearing right hand side
                                 ;based on choice left value load Z and Y with appropriate labels for word
                                 ;call zy print function
                                 
0001cd e2e4                      ldi ZL, low(str_clear<<1)
0001ce e0f5                      ldi ZH, high(str_clear<<1)
                                 
0001cf e2cc                      ldi YL, low(str_clear_end<<1)
0001d0 e0d5                      ldi YH, high(str_clear_end<<1)
                                 
0001d1 d0a0                      rcall print_yz_bottom ;write clear string to left side of LCD
0001d2 d021                      rcall load_choice_right ;load Z and Y registers with correct string lables
0001d3 d09e                      rcall print_yz_bottom ;print correct choice of string to LCD
                                 
                                 select_choice_right_end:
                                 
0001d4 910f                      pop mpr
0001d5 9508                      ret
                                 ;end select_choice_right
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: load_choice_left
                                 ;*	desc: loads correct string into Z and Y registers depending on choice left value
                                 ;***********************************************************
                                 load_choice_left:
0001d6 930f                      push mpr
                                 
                                 
0001d7 3010                      cpi choice_left, 0
0001d8 f031                      breq load_choice_left_clear
                                 
0001d9 3011                      cpi choice_left, 1
0001da f049                      breq load_choice_left_rock
                                 
0001db 3012                      cpi choice_left, 2
0001dc f061                      breq load_choice_left_paper		;find choice_left value
                                 
0001dd 3013                      cpi choice_left, 3
0001de f079                      breq load_choice_left_scissors
                                 
                                 load_choice_left_clear:
                                 
0001df e2e4                      ldi ZL, low(str_clear<<1)
0001e0 e0f5                      ldi ZH, high(str_clear<<1)
                                 
0001e1 e2cc                      ldi YL, low(str_clear_end<<1)
0001e2 e0d5                      ldi YH, high(str_clear_end<<1)
                                 
0001e3 c00e                      rjmp load_choice_left_end
                                 
                                 load_choice_left_rock:
0001e4 e9e4                      ldi ZL, low(str_rock<<1)
0001e5 e0f5                      ldi ZH, high(str_rock<<1)
                                 
0001e6 e9c8                      ldi YL, low(str_rock_end<<1)
0001e7 e0d5                      ldi YH, high(str_rock_end<<1)
                                 
0001e8 c009                      rjmp load_choice_left_end
                                 
                                 load_choice_left_paper:				;load correct string beginning into Z, and end into Y
0001e9 e2ec                      ldi ZL, low(str_paper<<1)
0001ea e0f5                      ldi ZH, high(str_paper<<1)
                                 
0001eb e3c2                      ldi YL, low(str_paper_end<<1)
0001ec e0d5                      ldi YH, high(str_paper_end<<1)
                                 
0001ed c004                      rjmp load_choice_left_end
                                 
                                 load_choice_left_scissors:
0001ee e3ec                      ldi ZL, low(str_scissors<<1)
0001ef e0f5                      ldi ZH, high(str_scissors<<1)
                                 
0001f0 e4c4                      ldi YL, low(str_scissors_end<<1)
0001f1 e0d5                      ldi YH, high(str_scissors_end<<1)
                                 
                                 load_choice_left_end:
0001f2 910f                      pop mpr
0001f3 9508                      ret
                                 ;end load_choice_left
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: load_choice_right
                                 ;*	desc: loads correct string into Z and Y registers depending on choice right value
                                 ;***********************************************************
                                 load_choice_right:
0001f4 930f                      push mpr
                                 
0001f5 3020                      cpi choice_right, 0
0001f6 f031                      breq load_choice_right_clear
                                 
0001f7 3021                      cpi choice_right, 1
0001f8 f049                      breq load_choice_right_rock
                                 
0001f9 3022                      cpi choice_right, 2
0001fa f061                      breq load_choice_right_paper		;find choice_left value
                                 
0001fb 3023                      cpi choice_right, 3
0001fc f079                      breq load_choice_right_scissors
                                 
                                 load_choice_right_clear:
                                 
0001fd e2e4                      ldi ZL, low(str_clear<<1)
0001fe e0f5                      ldi ZH, high(str_clear<<1)
                                 
0001ff e2cc                      ldi YL, low(str_clear_end<<1)
000200 e0d5                      ldi YH, high(str_clear_end<<1)
                                 
000201 c00e                      rjmp load_choice_right_end
                                 
                                 load_choice_right_rock:
000202 e9e4                      ldi ZL, low(str_rock<<1)
000203 e0f5                      ldi ZH, high(str_rock<<1)
                                 
000204 e9c8                      ldi YL, low(str_rock_end<<1)
000205 e0d5                      ldi YH, high(str_rock_end<<1)
                                 
000206 c009                      rjmp load_choice_right_end
                                 
                                 load_choice_right_paper:				;load correct string beginning into Z, and end into Y
000207 e2ec                      ldi ZL, low(str_paper<<1)
000208 e0f5                      ldi ZH, high(str_paper<<1)
                                 
000209 e3c2                      ldi YL, low(str_paper_end<<1)
00020a e0d5                      ldi YH, high(str_paper_end<<1)
                                 
00020b c004                      rjmp load_choice_right_end
                                 
                                 load_choice_right_scissors:
00020c e3ec                      ldi ZL, low(str_scissors<<1)
00020d e0f5                      ldi ZH, high(str_scissors<<1)
                                 
00020e e4c4                      ldi YL, low(str_scissors_end<<1)
00020f e0d5                      ldi YH, high(str_scissors_end<<1)
                                 
                                 load_choice_right_end:
000210 910f                      pop mpr
000211 9508                      ret
                                 
                                 ;end load_choice_right
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: led_countdown_n
                                 ;*	desc: uses polling for countdown
                                 ;***********************************************************
                                 led_countdown_n:
000212 930f                      push mpr
                                 
000213 b105                      in mpr, PORTB
000214 6f00                      ori mpr, 0b11110000
000215 b905                      out PORTB, mpr ;all led's are now set
                                 
000216 d009                      rcall timer_1_5 ;wait
000217 982c                      cbi PORTB, 4
000218 d007                      rcall timer_1_5 ;repeat for other bits
000219 982d                      cbi PORTB, 5
00021a d005                      rcall timer_1_5
00021b 982e                      cbi PORTB, 6
00021c d003                      rcall timer_1_5
00021d 982f                      cbi PORTB, 7
                                 
00021e 910f                      pop mpr
00021f 9508                      ret
                                 ;end led_countdown
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: timer_1_5
                                 ;*	desc: uses timer counter 1 over flow to count 
                                 ;***********************************************************
                                 timer_1_5:
                                 ;push stuff to stack
000220 930f                      push mpr
                                 
                                 	timer_1_5_NoFlag:
000221 9bb0                      sbis TIFR1, 0 ;skip loop if TOV1 is set
000222 cffe                      rjmp timer_1_5_NoFlag
                                 
000223 9ab0                      sbi TIFR1, 0 ;reset TOV1
                                 
000224 910f                      pop mpr
000225 9508                      ret
                                 ;end timer_1_5
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: print_zy_top
                                 ;*	desc: stores string stored in program memory and writes it to the top line of the LCD screen
                                 ;*	REMEMBER: the address stored in z and in y must be initially bit shifted by 1 due to least sig bit being low or high indicator.
                                 ;*	WARNING - assumes Z stores the address of the beginning of the string and Y stores the end of the string to print.
                                 ;***********************************************************
                                 print_zy_top:
000226 930f                      push mpr
000227 93af                      push XL
000228 93bf                      push XH
000229 93ef                      push ZL
00022a 93ff                      push ZH
00022b 93cf                      push YL
00022c 93df                      push YH
                                 
                                 
00022d e0a0                      ldi XL, LOW(lcd_buffer_addr) ;point X to the top line of the LCD buffer address in data memory
00022e e0b1                      ldi XH, HIGH(lcd_buffer_addr)
                                 
                                 print_zy_top_loop:
00022f 9105                      lpm mpr, Z+ ;load value stored at the address to the beginning of the string (stored in X) to mpr, then inc X to point to next char. ie. first character of string is loaded into mpr
000230 930d                      st X+, mpr ;Store that character to the beginning of the LCD buffer, then increment to next spot in LCD buffer
                                 
000231 17ec                      cp ZL, YL  ;compare where Z points (current address) to Y (end of string), we only need Low byte since start and end are definitely far enough away to cause roll over errors
000232 f7e1                      brne print_zy_top_loop ;if not at end keep loading LCD buffer
                                 
000233 d0c1                      rcall	LCDWrLn1 ;once done write to LCD
                                 
000234 91df                      pop YH
000235 91cf                      pop YL
000236 91ff                      pop ZH
000237 91ef                      pop ZL
000238 91bf                      pop XH
000239 91af                      pop XL 
00023a 910f                      pop mpr
00023b 9508                      ret
                                 ;end print_zy_top
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: print_yz_top
                                 ;*	desc: stores string stored in program memory and writes it to the top line of the LCD screen on the right
                                 ;*	REMEMBER: the address stored in z and in y must be initially bit shifted by 1 due to least sig bit being low or high indicator. 
                                 ;*	REMEMBER: you must clear line outside of this function to prevent overwriting
                                 ;*	WARNING: assumes Z stores the address of the beginning of the string and Y stores the end of the string to print.
                                 ;***********************************************************
                                 print_yz_top:
00023c 930f                      push mpr
00023d 93af                      push XL
00023e 93bf                      push XH
00023f 93ef                      push ZL
000240 93ff                      push ZH
000241 93cf                      push YL
000242 93df                      push YH
                                 
                                 ;must call lpm on Z, and need to call at end adress so shift Z->Y, and Y->Z for sake of function
000243 2fae                      mov XL, ZL
000244 2fbf                      mov XH, ZH ;X now temporarily holds old Z
                                 
000245 2fec                      mov ZL, YL
000246 2ffd                      mov ZH, YH ;Z now holds old Y 
                                 
000247 2fca                      mov YL, XL
000248 2fdb                      mov YH, XH ;Y now holds old Z via X
                                 
000249 e1a0                      ldi XL, LOW(lcd_buffer_addr+16) ;point x to the bottom line of the LCD buffer address in data memory
00024a e0b1                      ldi XH, HIGH(lcd_buffer_addr+16)
                                 
                                 print_yz_top_loop:
00024b 9104                      lpm mpr, Z ;load value stored at the address to the beginning of the string (stored in X) to mpr, then inc X to point to next char. ie. first character of string is loaded into mpr
00024c 930c                      st X, mpr ;Store that character to the beginning of the LCD buffer, then increment to next spot in LCD buffer
                                 
00024d 9731                      sbiw ZH:ZL, 1
00024e 9711                      sbiw XH:XL, 1
                                 
                                 
00024f 17ec                      cp ZL, YL ;compare where Z points (beginning of string) to Y (Current address), we only need Low byte since start and end are definitely not far enough away to cause roll over errors
000250 f7d1                      brne print_yz_top_loop ;if not at end keep loading LCD buffer
                                 
000251 9104                      lpm mpr, Z; store last character (dec YL inside loop triggers reset interrupt for some reason)
000252 930c                      st X, mpr
                                 
000253 d0a1                      rcall	LCDWrLn1 ;once done write to LCD 
                                 
000254 91df                      pop YH
000255 91cf                      pop YL
000256 91ff                      pop ZH
000257 91ef                      pop ZL
000258 91bf                      pop XH
000259 91af                      pop XL 
00025a 910f                      pop mpr
00025b 9508                      ret
                                 ;end print_yz_top
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: print_zy_bottom
                                 ;*	desc: stores string stored in program memory and writes it to the bottom line of the LCD screen on the left
                                 ;*	REMEMBER: the address stored in z and in y must be initially bit shifted by 1 due to least sig bit being low or high indicator. 
                                 ;*	REMEMBER: you must clear line outside of this function to prevent overwriting
                                 ;*	WARNING: assumes Z stores the address of the beginning of the string and Y stores the end of the string to print.
                                 ;***********************************************************
                                 print_zy_bottom:
00025c 930f                      push mpr
00025d 93af                      push XL
00025e 93bf                      push XH
00025f 93ef                      push ZL
000260 93ff                      push ZH
000261 93cf                      push YL
000262 93df                      push YH
                                 
                                 
000263 e1a0                      ldi XL, LOW(lcd_buffer_addr+16) ;point x to the bottom line of the LCD buffer address in data memory
000264 e0b1                      ldi XH, HIGH(lcd_buffer_addr+16)
                                 
                                 print_zy_bottom_left_loop:
000265 9105                      lpm mpr, Z+ ;load value stored at the address to the beginning of the string (stored in X) to mpr, then inc X to point to next char. ie. first character of string is loaded into mpr
000266 930d                      st X+, mpr ;Store that character to the beginning of the LCD buffer, then increment to next spot in LCD buffer
                                 
000267 17ec                      cp ZL, YL ;compare where Z points (current address) to Y (end of string), we only need Low byte since start and end are definitely not far enough away to cause roll over errors
000268 f7e1                      brne print_zy_bottom_left_loop ;if not at end keep loading LCD buffer
                                 
000269 d096                      rcall	LCDWrLn2 ;once done write to LCD 
                                 
00026a 91df                      pop YH
00026b 91cf                      pop YL
00026c 91ff                      pop ZH
00026d 91ef                      pop ZL
00026e 91bf                      pop XH
00026f 91af                      pop XL 
000270 910f                      pop mpr
000271 9508                      ret
                                 ;end print_zy_bottom
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Func: print_yz_bottom
                                 ;*	desc: stores string stored in program memory and writes it to the bottom line of the LCD screen on the right
                                 ;*	REMEMBER: the address stored in z and in y must be initially bit shifted by 1 due to least sig bit being low or high indicator. 
                                 ;*	REMEMBER: you must clear line outside of this function to prevent overwriting
                                 ;*	WARNING: assumes Z stores the address of the beginning of the string and Y stores the end of the string to print.
                                 ;***********************************************************
                                 print_yz_bottom:
000272 930f                      push mpr
000273 93af                      push XL
000274 93bf                      push XH
000275 93ef                      push ZL
000276 93ff                      push ZH
000277 93cf                      push YL
000278 93df                      push YH
                                 
                                 ;must call lpm on Z, and need to call at end adress so shift Z->Y, and Y->Z for sake of function
000279 2fae                      mov XL, ZL
00027a 2fbf                      mov XH, ZH ;X now temporarily holds old Z
                                 
00027b 2fec                      mov ZL, YL
00027c 2ffd                      mov ZH, YH ;Z now holds old Y 
                                 
00027d 2fca                      mov YL, XL
00027e 2fdb                      mov YH, XH ;Y now holds old Z via X
                                 
00027f e2a0                      ldi XL, LOW(lcd_buffer_addr+32) ;point x to the bottom line of the LCD buffer address in data memory
000280 e0b1                      ldi XH, HIGH(lcd_buffer_addr+32)
                                 
                                 print_yz_bottom_loop:
000281 9104                      lpm mpr, Z ;load value stored at the address to the beginning of the string (stored in X) to mpr, then inc X to point to next char. ie. first character of string is loaded into mpr
000282 930c                      st X, mpr ;Store that character to the beginning of the LCD buffer, then increment to next spot in LCD buffer
                                 
000283 9731                      sbiw ZH:ZL, 1
000284 9711                      sbiw XH:XL, 1
                                 
                                 
000285 17ec                      cp ZL, YL ;compare where Z points (beginning of string) to Y (Current address), we only need Low byte since start and end are definitely not far enough away to cause roll over errors
000286 f7d1                      brne print_yz_bottom_loop ;if not at end keep loading LCD buffer
                                 
000287 9104                      lpm mpr, Z; store last character (dec YL inside loop triggers reset interrupt for some reason)
000288 930c                      st X, mpr
                                 
000289 d076                      rcall	LCDWrLn2 ;once done write to LCD 
                                 
00028a 91df                      pop YH
00028b 91cf                      pop YL
00028c 91ff                      pop ZH
00028d 91ef                      pop ZL
00028e 91bf                      pop XH
00028f 91af                      pop XL 
000290 910f                      pop mpr
000291 9508                      ret
                                 ;end print_yz_bottom
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 ;***********************************************************
                                 ;*	Stored Program Data
                                 ;***********************************************************
                                 
                                 ;-----------------------------------------------------------
                                 ; An example of storing a string. Note the labels before and
                                 ; after the .DB directive; these can help to access the data
                                 ;-----------------------------------------------------------
                                 
                                 str_clear:
000292 2020
000293 2020
000294 2020
000295 2020                      .db "        "
                                 str_clear_end:
                                 
                                 str_paper:
000296 6170
000297 6570
000298 2072                      .db "paper "
                                 str_paper_end:
                                 
                                 
                                 str_draw:
000299 6f59
00029a 2075
00029b 7244
00029c 7761
00029d 2021                      .db "You Draw! "
                                 str_draw_end:
                                 
                                 
                                 str_scissors:
00029e 6373
00029f 7369
0002a0 6f73
0002a1 2072                      .db "scissor "
                                 str_scissors_end:
                                 
                                 str_lose:
0002a2 6f59
0002a3 2075
0002a4 6f4c
0002a5 6573                      .db "You Lose"
                                 str_lose_end:
                                 
                                 str_win:
0002a6 6f59
0002a7 2075
0002a8 6957
0002a9 216e                      .db "You Win!"
                                 str_win_end:
                                 
                                 
                                 
                                 str_welcome1:
0002aa 6577
0002ab 636c
0002ac 6d6f
0002ad 2065                      .db "welcome "
                                 str_welcome1_end:
                                 
                                 str_welcome2:
0002ae 6c50
0002af 6165
0002b0 6573
0002b1 5020
0002b2 6572
0002b3 7373
0002b4 5020
0002b5 3744                      .db "Please Press PD7"
                                 str_welcome2_end:
                                 
                                 str_start1:
0002b6 6552
0002b7 6461
0002b8 2c79
0002b9 5720
0002ba 6961
0002bb 6974
0002bc 676e                      .db "Ready, Waiting"
                                 str_start1_end:
                                 
                                 str_start2:
0002bd 6f66
0002be 2072
0002bf 6874
0002c0 2065
0002c1 706f
0002c2 6f70
0002c3 656e
0002c4 746e                      .db "for the opponent"
                                 str_start2_end:
                                 
                                 str_game:
0002c5 6147
0002c6 656d
0002c7 5320
0002c8 6174
0002c9 7472                      .db "Game Start"
                                 str_game_end:
                                 
                                 
                                 str_rock:
0002ca 6f52
0002cb 6b63                      .db	"Rock"		
                                 str_rock_end:
                                 
                                 ;***********************************************************
                                 ;*	Additional Program Includes
                                 ;***********************************************************
                                 .include "LCDDriver.asm"		; Include the LCD Driver
                                 
                                 ;*	Oregon State University
                                 ;*	ST7565R LCD Driver
                                 ;*	This code configures the graphical LCD and emulates
                                 ;*	the behavior of a 2x16 character display.
                                 ;*
                                 ;*	The LCD has room for 32 characters in total
                                 ;*	(16 on the top and 16 on the bottom).
                                 ;*	The upper 16 characters should be located in SRAM starting at 0x0100.
                                 ;*	The lower 16 characters should be located in SRAM starting at 0x0110.
                                 ;*
                                 ;*	NOTE: Register r16 MUST be named 'mpr' in the Main Code
                                 ;*	Something like this:
                                 ;*	.def	mpr = r16
                                 ;*
                                 ;*	WARNING: Register r20-r22 are reserved and cannot be
                                 ;*		renamed outside of the LCD Driver functions. Doing
                                 ;*		so will damage the functionality of the LCD Driver
                                 ;*
                                 ;*	Acknowledgements: the Bin2ASCII and div10 procedures were written by
                                 ;*	David Zier for a previous board. The code has been retained intact.
                                 ;*
                                 ;*********************************************************************
                                 ;*	Rev	Date		Name			Description
                                 ;*--------------------------------------------------------------------
                                 ;*	-	8/18/22	Justin Goins	Version 1.0
                                 ;*
                                 ;*
                                 ;*********************************************************************
                                 
                                 .include "m32U4def.inc"				; Include definition file
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATmega32U4.xml **********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "m32U4def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATmega32U4
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATmega32U4
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _M32U4DEF_INC_
                                 #endif  /* _M32U4DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; Register definitions
                                 .def	count = r20			; Character Counter
                                 .def	q = r21			; Quotient for div10
                                 .def	r = r22			; Remander for div10
                                 
                                 ; The following constants are not intended to be modified.
                                 .equ 	lcd_buffer_addr = 0x0100 ; define the SRAM base address of the LCD buffer
                                 
                                 ; This information is gathered from the ST7565R datasheet.
                                 ; define some command patterns
                                 .equ	lcd_c_disp_en = 0b10101110 ; lsb indicates whether the LCD is on (1) or off (0)
                                 .equ	lcd_c_disp_set_start_ln = 0b01000000 ; lower 6 bits indicate the line index (0 - 63)
                                 .equ	lcd_c_disp_set_page_addr = 0b10110000 ; lower 4 bits indicate the page address (page 3 is at top and page 0 is at bottom)
                                 ; together, these commands allow you to specify a column index from (0 - 131):
                                 .equ	lcd_c_disp_set_col_addr_h = 0b00010000 ; lower 4 bits indicate the 4 high bits of the column address
                                 .equ	lcd_c_disp_set_col_addr_l = 0b00000000 ; lower 4 bits indicate the 4 low bits of the column address
                                 .equ	lcd_c_disp_set_invert = 0b10100110 ; lsb indicates whether the LCD is normal (0) or inverted (1)
                                 .equ	lcd_c_disp_fill = 0b10100100 ; lsb indicates whether the LCD is normal (0) or filled with dots (1)
                                 .equ	lcd_c_disp_reset = 0b11100010 ; resets the line/page addresses and other stuff, does not affect data RAM
                                 .equ	lcd_c_disp_set_bias = 0xA2 ; 1/6 bias (in 1/33 duty mode)
                                 .equ	lcd_c_disp_set_scandir = 0b11000000 ; select normal scan direction (most significant bit is placed at top of LCD)
                                 .equ	lcd_c_disp_set_contrast_1 = 0b10000001 ; first we send this command then we pass the value
                                 .equ	lcd_c_disp_set_contrast_2 = 15 ; can select a contrast value between 1 and 63
                                 .equ	lcd_c_disp_set_res_ratio = 0x22 ; see the datasheet
                                 .equ	lcd_c_disp_vreg_on = 0x2F ; enable voltage booster, voltage regulator, and voltage follower
                                 
                                 ; use this command to write into the LCD RAM:
                                 .equ	lcd_c_disp_write = 0b00000000 ; these 8 bits are the data to be placed in the target. 
                                 ; note that the column address is automatically incremented by 1 after each write to the LCD data
                                 
                                 ; everything in this driver file needs to go into the code segment
                                 .cseg
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDInit
                                 ;* Desc:	This function initializes the LCD control pins and
                                 ;*		sets reasonable values for the configuration registers.
                                 ;*****************************************************************
                                 LCDInit:
0002cc 930f                      	push	mpr
                                 
                                 	; set MOSI, SCL, and SS as outputs
0002cd 9a22                      	sbi	DDRB, DDB2	; Port B 2
0002ce 9a21                      	sbi	DDRB, DDB1	; Port B 1
0002cf 9a20                      	sbi	DDRB, DDB0	; Port B 0
                                 	; ensure that SS is deactivated (active low)
0002d0 9a28                      	sbi	PORTB, 0
                                 	; set lcd_A0 as output
0002d1 9a81                      	sbi	DDRF, DDF1	; Port F 1
                                 	; enable LCD backlight control
0002d2 9a3f                      	sbi	DDRC, DDC7	; Port C 7
                                 	; set lcd_RST_N as output
0002d3 9a80                      	sbi	DDRF, DDF0	; Port F 0
                                 	; we pull lcd_RST_N low for 1 millisecond
0002d4 9888                      	cbi	PORTF, 0
0002d5 940e 03b7                 	call	LCDDelay
0002d7 9a88                      	sbi	PORTF, 0
                                 	; Enable SPI mode 3, master configuration, set clock rate fck/2 using SPI2X
0002d8 e50c                      	ldi	mpr, (1<<SPE)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)
0002d9 bd0c                      	out	SPCR, mpr
0002da e001                      	ldi	mpr, (1<<SPI2X)
0002db bd0d                      	out	SPSR, mpr
                                 	; Note: after transmitting a byte, the SPI interrupt flag will
                                 	; be automatically cleared next time we: 1) read SPSR and ALSO 2) access SPDR
                                 
0002dc 9828                      	cbi	PORTB, 0	; activate slave select
                                 	; send a string of initialization commands
0002dd ea02                      	ldi	mpr, lcd_c_disp_set_bias
0002de d0d2                      	rcall	LCD_Internal_WriteCMD
0002df ec00                      	ldi	mpr, lcd_c_disp_set_scandir
0002e0 d0d0                      	rcall	LCD_Internal_WriteCMD
0002e1 e801                      	ldi	mpr, lcd_c_disp_set_contrast_1
0002e2 d0ce                      	rcall	LCD_Internal_WriteCMD
0002e3 e00f                      	ldi	mpr, lcd_c_disp_set_contrast_2
0002e4 d0cc                      	rcall	LCD_Internal_WriteCMD
0002e5 e202                      	ldi	mpr, lcd_c_disp_set_res_ratio
0002e6 d0ca                      	rcall	LCD_Internal_WriteCMD
0002e7 e20f                      	ldi	mpr, lcd_c_disp_vreg_on
0002e8 d0c8                      	rcall	LCD_Internal_WriteCMD
0002e9 ea0f                      	ldi	mpr, (lcd_c_disp_en | 1 << 0)
0002ea d0c6                      	rcall	LCD_Internal_WriteCMD
0002eb 9a28                      	sbi	PORTB, 0	; deactivate slave select
                                 
0002ec 910f                      	pop	mpr
0002ed 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDBacklightOn
                                 ;* Desc:	Enables the backlight
                                 ;*****************************************************************
                                 LCDBacklightOn:
0002ee 9a47                      	sbi	PORTC, 7
0002ef 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDBacklightOff
                                 ;* Desc:	Disables the backlight
                                 ;*****************************************************************
                                 LCDBacklightOff:
0002f0 9847                      	cbi	PORTC, 7
0002f1 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDWrite
                                 ;* Desc:	This function writes 32 characters to the LCD screen...
                                 ;*		16 chars on the top line and 16 chars on the bottom line.
                                 ;*****************************************************************
                                 LCDWrite:
                                 	
0002f2 d002                      	rcall	LCDWrLn1
0002f3 d00c                      	rcall	LCDWrLn2
0002f4 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDWrLn1
                                 ;* Desc:	This function writes 16 characters to the top line.
                                 ;*****************************************************************
                                 LCDWrLn1:
0002f5 93bf                      	push	XH
0002f6 93af                      	push	XL
0002f7 931f                      	push 	r17
                                 	; r17 specifies the destination bank in LCD RAM
0002f8 e013                      	ldi	r17, 3
                                 	; point X at the ASCII data
0002f9 e0b1                      	ldi	XH, HIGH(lcd_buffer_addr)
0002fa e0a0                      	ldi	XL, LOW(lcd_buffer_addr)
0002fb d05c                      	rcall	LCD_Internal_WriteLn
0002fc 911f                      	pop	r17
0002fd 91af                      	pop	XL
0002fe 91bf                      	pop	XH
0002ff 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDWrLn2
                                 ;* Desc:	This function writes 16 characters to the bottom line.
                                 ;*****************************************************************
                                 LCDWrLn2:
000300 93bf                      	push	XH
000301 93af                      	push	XL
000302 931f                      	push	 r17
                                 	; r17 specifies the destination bank in LCD RAM
000303 e011                      	ldi	r17, 1
                                 	; point X at the ASCII data
000304 e0b1                      	ldi	XH, HIGH(lcd_buffer_addr+16)
000305 e1a0                      	ldi	XL, LOW(lcd_buffer_addr+16)
000306 d051                      	rcall	LCD_Internal_WriteLn
000307 911f                      	pop	r17
000308 91af                      	pop	XL
000309 91bf                      	pop	XH
00030a 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDClr
                                 ;* Desc:	This function clears the entire LCD screen.
                                 ;*****************************************************************
                                 LCDClr:
00030b d022                      	rcall	LCDClrLn1
00030c d027                      	rcall	LCDClrLn2
                                 
00030d 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	CLRDM1
                                 ;* Desc:	This function clears Data Memory by writing 16 
                                 ;*		consecutive ASCII spaces $20 to the memory at $0100.
                                 ;*****************************************************************
                                 CLRDM1:
                                     ; Set X register points to $0100
00030e 93bf                      	   push	   XH
00030f 93af                      	   PUSH	   XL
000310 930f                                 push    r16
000311 931f                                 push    r17
                                 
000312 e0b1                                 ldi     XH, HIGH(lcd_buffer_addr)
000313 e0a0                                 ldi     XL, LOW(lcd_buffer_addr)
000314 e110                                 ldi     r17, 16
000315 e200                                 ldi     r16, ' '
                                    CLRloop1:
000316 930d                                 st      X+, r16         ; load data to DM
000317 951a                                 dec     r17
000318 f7e9                                 brne    CLRloop1
                                 
000319 911f                      	   pop	   r17
00031a 910f                      	   pop	   r16
00031b 91af                      	   pop	   XL
00031c 91bf                      	   pop	   XH
                                 
00031d 9508                                 ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	CLRDM2
                                 ;* Desc:	This function clears Data Memory by writing 16 
                                 ;*		consecutive ASCII spaces $20 to the memory at $0110.
                                 ;*****************************************************************
                                 CLRDM2:
                                     ; Set X register points to $0110
00031e 93bf                      	   push	   XH
00031f 93af                      	   PUSH	   XL
000320 930f                                 push    r16
000321 931f                                 push    r17
                                 
000322 e0b1                                 ldi     XH, HIGH(lcd_buffer_addr+16)
000323 e1a0                                 ldi     XL, LOW(lcd_buffer_addr+16)
000324 e110                                 ldi     r17, 16
000325 e200                                 ldi     r16, ' '
                                    CLRloop2:
000326 930d                                 st      X+, r16         ; load data to DM
000327 951a                                 dec     r17
000328 f7e9                                 brne    CLRloop2
                                 
000329 911f                      	   pop	   r17
00032a 910f                      	   pop	   r16
00032b 91af                      	   pop	   XL
00032c 91bf                      	   pop	   XH
                                 
00032d 9508                                 ret
                                 ;*****************************************************************
                                 ;* Func:	LCDClrLn1
                                 ;* Desc:	This function clears the top line of the LCD screen.
                                 ;*****************************************************************
                                 LCDClrLn1:
00032e 931f                      	push	 r17
                                 	; r17 specifies the target bank in LCD RAM
00032f e013                      	ldi	r17, 3
000330 d060                      	rcall	LCD_Internal_ClearLn
000331 dfdc                      	rcall	CLRDM1
000332 911f                      	pop	r17
000333 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDClrLn2
                                 ;* Desc:	This function clears the bottom line of the LCD screen.
                                 ;*****************************************************************
                                 LCDClrLn2:
000334 931f                      	push	 r17
                                 	; r17 specifies the target bank in LCD RAM
000335 e011                      	ldi	r17, 1
000336 d05a                      	rcall	LCD_Internal_ClearLn
000337 dfe6                      	rcall	CLRDM2
000338 911f                      	pop	r17
000339 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	Bin2ASCII
                                 ;* Desc:	Converts a binary number into an ASCII 
                                 ;*			text string equivalent. 
                                 ;*			- The binary number needs to be in the mpr
                                 ;*			- The Start Address of where the text will
                                 ;*			 	be placed needs to be in the X Register
                                 ;*			- The count of the characters created are 
                                 ;*				added to the count register
                                 ;*****************************************************************
                                 Bin2ASCII:
00033a 930f                      	push	 mpr			; save mpr
00033b 936f                      	push	 r			; save r
00033c 935f                      	push	 q			; save q
00033d 93bf                      	push	 XH			; save X-pointer
00033e 93af                      	push	 XL			;
                                 
                                 	; Determine the range of mpr
00033f 3604                      	cpi	mpr, 100		; is mpr >= 100
000340 f018                      	brlo	 B2A_1			; goto next check
000341 e043                      	ldi	count, 3		; Three chars are written
000342 9613                      	adiw	 XL, 3			; Increment X 3 address spaces
000343 c007                      	rjmp	 B2A_3			; Continue with program
                                 B2A_1:
000344 300a                      	cpi	mpr, 10		; is mpr >= 10
000345 f018                      	brlo	 B2A_2			; Continue with program
000346 e042                      	ldi	count, 2		; Two chars are written
000347 9612                      	adiw	 XL, 2			; Increment X 2 address spaces
000348 c002                      	rjmp	 B2A_3			; Continue with program
                                 B2A_2:
000349 9611                      	adiw	 XL, 1			; Increment X 1 address space
00034a e041                      	ldi	count, 1		; One char is written
                                 
                                 B2A_3:
                                 	; Do-While statement that converts Binary to ASCII
00034b d076                      	rcall	div10			; Call the div10 function
00034c e300                      	ldi	mpr, '0'		; Set the base ASCII integer value
00034d 0f06                      	add	mpr, r		; Create the ASCII integer value
00034e 930e                      	st	-X, mpr		; Load ASCII value to memory
00034f 2f05                      	mov	mpr, q		; Set mpr to quotient value
000350 3000                      	cpi	mpr, 0		; does mpr == 0
000351 f7c9                      	brne 	B2A_3			; do while (mpr != 0)
                                 
000352 91af                      	pop	XL			; restore X-pointer
000353 91bf                      	pop	XH			;
000354 915f                      	pop	q			; restore q
000355 916f                      	pop	r			; restore r
000356 910f                      	pop	mpr			; restore mpr
000357 9508                      	ret				; return from function
                                 
                                 ;*****************************************************************
                                 ;*	The functions below here are intended for internal use only.
                                 ;*****************************************************************
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCD_Internal_WriteLn
                                 ;* Desc:	Sends 16 characters of information to the LCD panel
                                 ;*		This is slightly more complicated than it sounds because the
                                 ;*		characters straddle two banks of the LCD memory.
                                 ;*		X is pointing at the first ASCII character to be displayed.
                                 ;*		r17 holds the index of the destination bank in LCD RAM.
                                 ;*		
                                 ;*****************************************************************
                                 LCD_Internal_WriteLn:
000358 920f                      	push	 r0
000359 921f                      	push	 r1
00035a 930f                      	push	 mpr
00035b 932f                      	push	 r18
00035c 933f                      	push	 r19
00035d 938f                      	push	 r24
00035e 939f                      	push	 r25
00035f 93ef                      	push	 ZL
000360 93ff                      	push	 ZH
                                 
                                 	; r25:24 holds a pointer to the base address of the bitmap array
000361 e097                      	ldi	r25, HIGH(FontBitmap << 1);
000362 ed80                      	ldi	r24, LOW(FontBitmap << 1);
                                 
000363 9828                      	cbi	PORTB, 0	; activate slave select
                                 
                                 	; use a counter to track if we are on the top chunk or bottom chunk of each char
000364 e022                      	ldi	r18, 2
                                 
                                 LCD_WL_display_bank:
                                 	; set the column to 0
000365 e100                      	ldi	mpr, lcd_c_disp_set_col_addr_h
000366 d04a                      	rcall	LCD_Internal_WriteCMD
000367 e000                      	ldi	mpr, lcd_c_disp_set_col_addr_l
000368 d048                      	rcall	LCD_Internal_WriteCMD
                                 	; we need to select the appropriate page
000369 eb00                      	ldi	mpr, lcd_c_disp_set_page_addr
00036a 2b01                      	or	mpr, r17	; set the lower 4 bits
00036b d045                      	rcall	LCD_Internal_WriteCMD
                                 
00036c e130                      	ldi	r19, 16	; there are 16 characters per line
                                 
                                 LCD_WL_next_char:
                                 	; get ascii code point & determine location of corresponding character bitmap
00036d 900d                      	ld	r0, X+	; this should be a value from 0 to 255
00036e e100                      	ldi	mpr, 16	; there are 16 bytes per character
00036f 9e00                      	mul	r0, mpr	; determine the byte offset for the desired char
000370 01fc                      	movw	 ZH:ZL, r25:r24	; copy the base address to Z
000371 0de0                      	add	ZL, r0	; finally, compute a pointer to the char bitmap
000372 1df1                      	adc	ZH, r1
                                 
000373 e008                      	ldi	mpr, 8	; there are 8 columns for each character
                                 
                                 	; this is where we display the chunk of character (either a top chunk or bottom chunk)
000374 9004                      	lpm	r0, Z
                                 LCD_WL_next_col:
000375 bc0e                      	out	SPDR, r0
000376 9a89                      	sbi	PORTF, 1	; set lcd_A0 to specify data mode
000377 9632                      	adiw	 ZH:ZL, 2	; point Z at the next column for this bank
000378 9004                      	lpm	r0, Z		; this is a sneaky way to save a few clock cycles (since we are waiting for the SPI communication)
                                 LCD_WL_wait_spi:
000379 b41d                      	in	r1, SPSR
00037a fe17                      	sbrs	 r1, SPIF	; wait for SPI to finish
00037b cffd                      	rjmp	 LCD_WL_wait_spi
                                 
                                 	; keep going until we have displayed all the columns for this character
00037c 950a                      	dec	mpr
00037d f7b9                      	brne	 LCD_WL_next_col
                                 
                                 	; move to the next character
00037e 953a                      	dec	r19
00037f f769                      	brne	 LCD_WL_next_char
                                 
                                 	; if we are at the end of the line, configure the bank and starting array offset for the bottom half of each char
000380 952a                      	dec	r18		; did we display both banks yet?
000381 f021                      	breq	 LCD_WL_all_done
                                 	; if not, then prepare to display the bottom chunk of each character
000382 951a                      	dec	r17		; decrement the bank number
000383 9750                      	sbiw	 XH:XL, 16	; X needs to point back at the beginning character of the line
000384 9601                      	adiw	 r25:r24, 1	; increment the base address pointer (now it will point to the second chunk of each char)
000385 cfdf                      	rjmp	 LCD_WL_display_bank
                                 
                                 LCD_WL_all_done:
000386 9a28                      	sbi	PORTB, 0	; deactivate slave select
                                 
000387 91ff                      	pop	ZH
000388 91ef                      	pop	ZL
000389 919f                      	pop	r25
00038a 918f                      	pop	r24
00038b 913f                      	pop	r19
00038c 912f                      	pop	r18
00038d 910f                      	pop	mpr
00038e 901f                      	pop	r1
00038f 900f                      	pop	r0
000390 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCD_Internal_ClearLn
                                 ;* Desc:	This function clears two of the LCD memory banks.
                                 ;*		r17 specifies the starting bank to wipe.
                                 ;*****************************************************************
                                 LCD_Internal_ClearLn:
000391 930f                      	push 	mpr
000392 921f                      	push 	r1
000393 932f                      	push	 r18
000394 933f                      	push	 r19
                                 
000395 9828                      	cbi	PORTB, 0	; activate slave select
000396 e032                      	ldi	r19, 2	; we are going to clear two banks
                                 
                                 LCD_CLRLN_clear_bank:
                                 	; set the column to 0
000397 e100                      	ldi	mpr, lcd_c_disp_set_col_addr_h
000398 d018                      	rcall	LCD_Internal_WriteCMD
000399 e000                      	ldi	mpr, lcd_c_disp_set_col_addr_l
00039a d016                      	rcall	LCD_Internal_WriteCMD
                                 	; we need to select the appropriate page
00039b eb00                      	ldi	mpr, lcd_c_disp_set_page_addr
00039c 2b01                      	or	mpr, r17	; configure the lower 4 bits
00039d d013                      	rcall	LCD_Internal_WriteCMD
                                 
00039e e820                      	ldi	r18, 128	; there are 128 columns on the LCD
00039f 2700                      	clr	mpr		; we will fill each column with empty dots (i.e. blank space)
0003a0 9a89                      	sbi	PORTF, 1	; set lcd_A0 to specify data mode
                                 
                                 LCD_CLRLN_write_col:
0003a1 bd0e                      	out	SPDR, mpr	; send an empty column to the LCD via SPI
                                 LCD_CLRLN_wait_spi:
0003a2 b41d                      	in	r1, SPSR
0003a3 fe17                      	sbrs	 r1, SPIF	; wait for SPI to finish
0003a4 cffd                      	rjmp 	LCD_CLRLN_wait_spi
                                 
0003a5 952a                      	dec	r18
0003a6 f7d1                      	brne	LCD_CLRLN_write_col	; cycle through all 128 columns
                                 
                                 	; clear the remaining bank if we haven't done so already
0003a7 953a                      	dec	r19
0003a8 f011                      	breq	LCD_CLRLN_all_done
0003a9 951a                      	dec	r17		; decrement the bank index
0003aa cfec                      	rjmp	LCD_CLRLN_clear_bank
                                 
                                 LCD_CLRLN_all_done:
0003ab 9a28                      	sbi	PORTB, 0	; deactivate slave select	
                                 	
                                 	; pop registers...
0003ac 913f                      	pop	r19
0003ad 912f                      	pop	r18
0003ae 901f                      	pop	r1
0003af 910f                      	pop	mpr
0003b0 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCD_Internal_WriteCMD
                                 ;* Desc:	Sends the byte in mpr
                                 ;*		If you use this function directly,
                                 ;*		YOU ARE RESPONSIBLE for handling the slave select line!
                                 ;*****************************************************************
                                 LCD_Internal_WriteCMD:
0003b1 bd0e                      	out	SPDR, mpr	; initiate transmission
0003b2 9889                      	cbi	PORTF, 1	; clear lcd_A0 to put the lcd into command mode
                                 				; (this just has to be done before the 8th bit
                                 				; is transmitted via SPI)
                                 LCD_IWC_L1:
0003b3 b50d                      	in	mpr, SPSR
0003b4 ff07                      	sbrs	 mpr, SPIF	; wait for SPI to finish
0003b5 cffd                      	rjmp LCD_IWC_L1
0003b6 9508                      	ret
                                 
                                 ;*****************************************************************
                                 ;* Func:	LCDDelay
                                 ;* Desc:	A wait loop that will consume roughly 1ms
                                 ;*		Note that a CALL takes 4 cycles on top of this delay.
                                 ;*****************************************************************
                                 LCDDelay:
0003b7 930f                      	push 	mpr		; 2 cycles
0003b8 931f                      	push	 r17		; 2 cycles
0003b9 e01b                      	ldi	r17, 11	; 1 cycle
                                 LCDDelay_L1:
0003ba ef02                      	ldi	mpr, 242	; 1 cycle
                                 LCDDelay_L2:
0003bb 950a                      	dec	mpr		; 1 cycle
0003bc f7f1                      	brne	LCDDelay_L2	; 2 cycles on branch, 1 if no branch
0003bd 951a                      	dec	r17		; 1 cycle
0003be f7d9                      	brne	LCDDelay_L1	; 2 cycles on branch, 1 if no branch
0003bf 911f                      	pop	r17		; 2 cycles
0003c0 910f                      	pop	mpr		; 2 cycles
0003c1 9508                      	ret			; 4 cycles
                                 
                                 ;*****************************************************************
                                 ;* Func:	div10
                                 ;* Desc:	Divides the value in the mpr by 10 and 
                                 ;*			puts the remainder in the 'r' register
                                 ;*			and the quotient in the 'q' register.
                                 ;*	DO NOT modify this function, trust me, it does
                                 ;*	divide by 10 :)  ~DZ		
                                 ;*****************************************************************
                                 div10:
0003c2 920f                      	push	r0		; Save register
                                 
                                 	; q = mpr / 10 = mpr * 0.000110011001101b
0003c3 2f50                      	mov	q, mpr	; q = mpr * 1.0b
0003c4 9556                      	lsr	q		; q >> 2
0003c5 9556                      	lsr	q		; q = mpr * 0.01b
0003c6 0f50                      	add	q, mpr	; q = (q + mpr) >> 1
0003c7 9556                      	lsr	q		; q = mpr * 0.101b
0003c8 0f50                      	add	q, mpr	; q = (q + mpr) >> 3
0003c9 9556                      	lsr	q
0003ca 9556                      	lsr	q
0003cb 9556                      	lsr	q		; q = mpr * 0.001101b
0003cc 0f50                      	add	q, mpr	; q = (q + mpr) >> 1
0003cd 9556                      	lsr	q		; q = mpr * 0.1001101b
0003ce 0f50                      	add	q, mpr	; q = (q + mpr) >> 3
0003cf 9556                      	lsr	q				
0003d0 9556                      	lsr	q
0003d1 9556                      	lsr	q		; q = mpr * 0.0011001101b
0003d2 0f50                      	add	q, mpr	; q = (q + mpr) >> 1
0003d3 9556                      	lsr	q		; q = mpr * 0.10011001101b
0003d4 0f50                      	add	q, mpr	; q = (q + mpr) >> 4
0003d5 9556                      	lsr	q
0003d6 9556                      	lsr	q
0003d7 9556                      	lsr	q
0003d8 9556                      	lsr	q		; q = mpr * 0.000110011001101b
                                 
                                 	; compute the remainder as r = i - 10 * q
                                 	; calculate r = q * 10 = q * 1010b
0003d9 2f65                      	mov	r, q		; r = q * 1
0003da 0f66                      	lsl	r		; r << 2
0003db 0f66                      	lsl	r		; r = q * 100b
0003dc 0f65                      	add	r, q		; r = (r + q) << 1
0003dd 0f66                      	lsl	r		; r = q * 1010b
0003de 2e06                      	mov	r0, r		; r0 = 10 * q
0003df 2f60                      	mov	r, mpr	; r = mpr
0003e0 1960                      	sub	r, r0		; r = mpr - 10 * q
                                 
                                 	; Fix any errors that occur
                                 div10_1:
0003e1 306a                      	cpi	r, 10		; Compare with 10
0003e2 f018                      	brlo	 div10_2	; do nothing if r < 10
0003e3 9553                      	inc	q		; fix quotient
0003e4 506a                      	subi	r, 10		; fix remainder
0003e5 cffb                      	rjmp	 div10_1	; Continue until error is corrected
                                 
                                 div10_2:
0003e6 900f                      	pop	r0		; Restore registers
0003e7 9508                      	ret			; Return from function
                                 
                                 ;*********************************************************************
                                 ;*	Bitmap Font Information
                                 ;*	Adapted into assembly code by Justin Goins.
                                 ;*	You can edit characters or add symbols if you choose (by modifying the data below)
                                 ;*	Each character is represented as a 8 x 16 pattern of dots (8 dots wide and 16 dots high).
                                 ;*	This implies that 16 bytes are allocated to represent each character.
                                 ;*
                                 ;*	The character information is arranged so that each line below equates to a single character.
                                 ;*	The first line is ASCII character 0, the next line is ASCII character 1,
                                 ;*	the next line is ASCII character 2, and so on.
                                 ;*	You can assign characters to any index within the extended ASCII range (0 to 255).
                                 ;*	With a bit of experimentation it's possible to define and display emojis (or any other graphical output).
                                 ;*	Be creative and have fun!
                                 ;*
                                 ;*	From original license file:
                                 ;*	Copyright 2011 Suraj N. Kurapati <https://github.com/sunaku/tamzen-font>
                                 ;*	Tamzen font is free.  You are hereby granted permission to use, copy, modify, and distribute it as you see fit.
                                 ;*	Tamzen font is provided "as is" without any express or implied warranty.
                                 ;*********************************************************************
                                 FontBitmap:
0003e8 0000
0003e9 f00f
0003ea 1008
0003eb 1008
0003ec 1008
0003ed 1008
0003ee f00f
0003ef 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x0F, 0xF0, 0x00, 0x00	; U+0000
0003f0 fe03
0003f1 fa7f
0003f2 f683
0003f3 ea83
0003f4 d683
0003f5 aa83
0003f6 567f
0003f7 fe03                      .DB	0x03, 0xFE, 0x7F, 0xFA, 0x83, 0xF6, 0x83, 0xEA, 0x83, 0xD6, 0x83, 0xAA, 0x7F, 0x56, 0x03, 0xFE	; U+E0A2
0003f8 5455
0003f9 aaaa
0003fa 5455
0003fb aaaa
0003fc 5455
0003fd aaaa
0003fe 5455
0003ff aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; U+2592
000400 5455
000401 aaaa
000402 5455
000403 aaaa
000404 5455
000405 aaaa
000406 5455
000407 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000408 5455
000409 aaaa
00040a 5455
00040b aaaa
00040c 5455
00040d aaaa
00040e 5455
00040f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000410 5455
000411 aaaa
000412 5455
000413 aaaa
000414 5455
000415 aaaa
000416 5455
000417 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000418 5455
000419 aaaa
00041a 5455
00041b aaaa
00041c 5455
00041d aaaa
00041e 5455
00041f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000420 0000
000421 0007
000422 8008
000423 8008
000424 8008
000425 0007
000426 0000
000427 0000                      .DB	0x00, 0x00, 0x07, 0x00, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00B0
000428 5455
000429 aaaa
00042a 5455
00042b aaaa
00042c 5455
00042d aaaa
00042e 5455
00042f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000430 5455
000431 aaaa
000432 5455
000433 aaaa
000434 5455
000435 aaaa
000436 5455
000437 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000438 5455
000439 aaaa
00043a 5455
00043b aaaa
00043c 5455
00043d aaaa
00043e 5455
00043f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000440 8000
000441 8000
000442 8000
000443 8000
000444 80ff
000445 0000
000446 0000
000447 0000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2518
000448 8000
000449 8000
00044a 8000
00044b 8000
00044c fe00
00044d 0000
00044e 0000
00044f 0000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2510
000450 0000
000451 0000
000452 0000
000453 0000
000454 fe00
000455 8000
000456 8000
000457 8000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+250C
000458 0000
000459 0000
00045a 0000
00045b 0000
00045c 80ff
00045d 8000
00045e 8000
00045f 8000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+2514
000460 8000
000461 8000
000462 8000
000463 8000
000464 feff
000465 8000
000466 8000
000467 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+253C
000468 5455
000469 aaaa
00046a 5455
00046b aaaa
00046c 5455
00046d aaaa
00046e 5455
00046f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000470 5455
000471 aaaa
000472 5455
000473 aaaa
000474 5455
000475 aaaa
000476 5455
000477 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000478 8000
000479 8000
00047a 8000
00047b 8000
00047c 8000
00047d 8000
00047e 8000
00047f 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+2500
000480 5455
000481 aaaa
000482 5455
000483 aaaa
000484 5455
000485 aaaa
000486 5455
000487 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000488 5455
000489 aaaa
00048a 5455
00048b aaaa
00048c 5455
00048d aaaa
00048e 5455
00048f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000490 0000
000491 0000
000492 0000
000493 0000
000494 feff
000495 8000
000496 8000
000497 8000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+251C
000498 8000
000499 8000
00049a 8000
00049b 8000
00049c feff
00049d 0000
00049e 0000
00049f 0000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2524
0004a0 8000
0004a1 8000
0004a2 8000
0004a3 8000
0004a4 80ff
0004a5 8000
0004a6 8000
0004a7 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0xFF, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+2534
0004a8 8000
0004a9 8000
0004aa 8000
0004ab 8000
0004ac fe00
0004ad 8000
0004ae 8000
0004af 8000                      .DB	0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0xFE, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+252C
0004b0 0000
0004b1 0000
0004b2 0000
0004b3 0000
0004b4 feff
0004b5 0000
0004b6 0000
0004b7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+2502
0004b8 5455
0004b9 aaaa
0004ba 5455
0004bb aaaa
0004bc 5455
0004bd aaaa
0004be 5455
0004bf aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004c0 5455
0004c1 aaaa
0004c2 5455
0004c3 aaaa
0004c4 5455
0004c5 aaaa
0004c6 5455
0004c7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004c8 5455
0004c9 aaaa
0004ca 5455
0004cb aaaa
0004cc 5455
0004cd aaaa
0004ce 5455
0004cf aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004d0 5455
0004d1 aaaa
0004d2 5455
0004d3 aaaa
0004d4 5455
0004d5 aaaa
0004d6 5455
0004d7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004d8 0000
0004d9 1001
0004da 2001
0004db e007
0004dc 2009
0004dd 1009
0004de 1008
0004df 2004                      .DB	0x00, 0x00, 0x01, 0x10, 0x01, 0x20, 0x07, 0xE0, 0x09, 0x20, 0x09, 0x10, 0x08, 0x10, 0x04, 0x20	; U+00A3
0004e0 5455
0004e1 aaaa
0004e2 5455
0004e3 aaaa
0004e4 5455
0004e5 aaaa
0004e6 5455
0004e7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0004e8 0000
0004e9 0000
0004ea 0000
0004eb 0000
0004ec 0000
0004ed 0000
0004ee 0000
0004ef 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0020
0004f0 0000
0004f1 0000
0004f2 0000
0004f3 301f
0004f4 0000
0004f5 0000
0004f6 0000
0004f7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0021
0004f8 0000
0004f9 0000
0004fa 001e
0004fb 0000
0004fc 0000
0004fd 001e
0004fe 0000
0004ff 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0022
000500 0000
000501 4002
000502 f00f
000503 4002
000504 4002
000505 f00f
000506 4002
000507 0000                      .DB	0x00, 0x00, 0x02, 0x40, 0x0F, 0xF0, 0x02, 0x40, 0x02, 0x40, 0x0F, 0xF0, 0x02, 0x40, 0x00, 0x00	; U+0023
000508 0000
000509 0000
00050a 2006
00050b 2009
00050c 3839
00050d 2009
00050e c008
00050f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x06, 0x20, 0x09, 0x20, 0x39, 0x38, 0x09, 0x20, 0x08, 0xC0, 0x00, 0x00	; U+0024
000510 0000
000511 200c
000512 4012
000513 8012
000514 600d
000515 9002
000516 9004
000517 6008                      .DB	0x00, 0x00, 0x0C, 0x20, 0x12, 0x40, 0x12, 0x80, 0x0D, 0x60, 0x02, 0x90, 0x04, 0x90, 0x08, 0x60	; U+0025
000518 0000
000519 e00c
00051a 1013
00051b 1013
00051c 900c
00051d 6000
00051e 6000
00051f 9001                      .DB	0x00, 0x00, 0x0C, 0xE0, 0x13, 0x10, 0x13, 0x10, 0x0C, 0x90, 0x00, 0x60, 0x00, 0x60, 0x01, 0x90	; U+0026
000520 0000
000521 0000
000522 0000
000523 001e
000524 0000
000525 0000
000526 0000
000527 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0027
000528 0000
000529 0000
00052a 0000
00052b e003
00052c 180c
00052d 0410
00052e 0000
00052f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE0, 0x0C, 0x18, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00	; U+0028
000530 0000
000531 0000
000532 0410
000533 180c
000534 e003
000535 0000
000536 0000
000537 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0x0C, 0x18, 0x03, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0029
000538 0000
000539 8000
00053a a002
00053b c001
00053c c001
00053d a002
00053e 8000
00053f 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x02, 0xA0, 0x01, 0xC0, 0x01, 0xC0, 0x02, 0xA0, 0x00, 0x80, 0x00, 0x00	; U+002A
000540 0000
000541 8000
000542 8000
000543 8000
000544 f007
000545 8000
000546 8000
000547 8000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x07, 0xF0, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80	; U+002B
000548 0000
000549 0000
00054a 0000
00054b 3200
00054c 3c00
00054d 0000
00054e 0000
00054f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+002C
000550 0000
000551 8000
000552 8000
000553 8000
000554 8000
000555 8000
000556 8000
000557 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00	; U+002D
000558 0000
000559 0000
00055a 0000
00055b 3000
00055c 3000
00055d 0000
00055e 0000
00055f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+002E
000560 0000
000561 0c00
000562 3000
000563 c000
000564 0003
000565 000c
000566 0000
000567 0000                      .DB	0x00, 0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x03, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00	; U+002F
000568 0000
000569 e007
00056a 5008
00056b 9008
00056c 1009
00056d 100a
00056e e007
00056f 0000                      .DB	0x00, 0x00, 0x07, 0xE0, 0x08, 0x50, 0x08, 0x90, 0x09, 0x10, 0x0A, 0x10, 0x07, 0xE0, 0x00, 0x00	; U+0030
000570 0000
000571 0000
000572 1002
000573 1004
000574 f00f
000575 1000
000576 1000
000577 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x04, 0x10, 0x0F, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+0031
000578 0000
000579 1004
00057a 3008
00057b 5008
00057c 9008
00057d 1009
00057e 1006
00057f 0000                      .DB	0x00, 0x00, 0x04, 0x10, 0x08, 0x30, 0x08, 0x50, 0x08, 0x90, 0x09, 0x10, 0x06, 0x10, 0x00, 0x00	; U+0032
000580 0000
000581 2008
000582 1008
000583 1009
000584 100b
000585 100d
000586 e008
000587 0000                      .DB	0x00, 0x00, 0x08, 0x20, 0x08, 0x10, 0x09, 0x10, 0x0B, 0x10, 0x0D, 0x10, 0x08, 0xE0, 0x00, 0x00	; U+0033
000588 0000
000589 c000
00058a 4001
00058b 4002
00058c 4004
00058d f00f
00058e 4000
00058f 0000                      .DB	0x00, 0x00, 0x00, 0xC0, 0x01, 0x40, 0x02, 0x40, 0x04, 0x40, 0x0F, 0xF0, 0x00, 0x40, 0x00, 0x00	; U+0034
000590 0000
000591 200f
000592 1009
000593 1009
000594 1009
000595 1009
000596 e008
000597 0000                      .DB	0x00, 0x00, 0x0F, 0x20, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0xE0, 0x00, 0x00	; U+0035
000598 0000
000599 e003
00059a 1005
00059b 1009
00059c 1009
00059d 1001
00059e e000
00059f 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x05, 0x10, 0x09, 0x10, 0x09, 0x10, 0x01, 0x10, 0x00, 0xE0, 0x00, 0x00	; U+0036
0005a0 0000
0005a1 0008
0005a2 0008
0005a3 3008
0005a4 c008
0005a5 000b
0005a6 000c
0005a7 0000                      .DB	0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x30, 0x08, 0xC0, 0x0B, 0x00, 0x0C, 0x00, 0x00, 0x00	; U+0037
0005a8 0000
0005a9 e006
0005aa 1009
0005ab 1009
0005ac 1009
0005ad 1009
0005ae e006
0005af 0000                      .DB	0x00, 0x00, 0x06, 0xE0, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x06, 0xE0, 0x00, 0x00	; U+0038
0005b0 0000
0005b1 0007
0005b2 8008
0005b3 9008
0005b4 9008
0005b5 a008
0005b6 c007
0005b7 0000                      .DB	0x00, 0x00, 0x07, 0x00, 0x08, 0x80, 0x08, 0x90, 0x08, 0x90, 0x08, 0xA0, 0x07, 0xC0, 0x00, 0x00	; U+0039
0005b8 0000
0005b9 0000
0005ba 0000
0005bb 3006
0005bc 3006
0005bd 0000
0005be 0000
0005bf 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x30, 0x06, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+003A
0005c0 0000
0005c1 0000
0005c2 0000
0005c3 3206
0005c4 3c06
0005c5 0000
0005c6 0000
0005c7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x06, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+003B
0005c8 0000
0005c9 0000
0005ca 8000
0005cb 4001
0005cc 2002
0005cd 1004
0005ce 0000
0005cf 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00	; U+003C
0005d0 0000
0005d1 4002
0005d2 4002
0005d3 4002
0005d4 4002
0005d5 4002
0005d6 4002
0005d7 0000                      .DB	0x00, 0x00, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x02, 0x40, 0x00, 0x00	; U+003D
0005d8 0000
0005d9 0000
0005da 1004
0005db 2002
0005dc 4001
0005dd 8000
0005de 0000
0005df 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00	; U+003E
0005e0 0000
0005e1 0008
0005e2 0010
0005e3 3011
0005e4 0012
0005e5 0014
0005e6 0008
0005e7 0000                      .DB	0x00, 0x00, 0x08, 0x00, 0x10, 0x00, 0x11, 0x30, 0x12, 0x00, 0x14, 0x00, 0x08, 0x00, 0x00, 0x00	; U+003F
0005e8 0000
0005e9 f007
0005ea 0808
0005eb c411
0005ec 2412
0005ed 2412
0005ee 440a
0005ef e407                      .DB	0x00, 0x00, 0x07, 0xF0, 0x08, 0x08, 0x11, 0xC4, 0x12, 0x24, 0x12, 0x24, 0x0A, 0x44, 0x07, 0xE4	; U+0040
0005f0 0000
0005f1 f003
0005f2 8004
0005f3 8008
0005f4 8008
0005f5 8004
0005f6 f003
0005f7 0000                      .DB	0x00, 0x00, 0x03, 0xF0, 0x04, 0x80, 0x08, 0x80, 0x08, 0x80, 0x04, 0x80, 0x03, 0xF0, 0x00, 0x00	; U+0041
0005f8 0000
0005f9 f00f
0005fa 1009
0005fb 1009
0005fc 1009
0005fd 1009
0005fe e006
0005ff 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x06, 0xE0, 0x00, 0x00	; U+0042
000600 0000
000601 c003
000602 2004
000603 1008
000604 1008
000605 1008
000606 1008
000607 0000                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+0043
000608 0000
000609 f00f
00060a 1008
00060b 1008
00060c 1008
00060d 2004
00060e c003
00060f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x04, 0x20, 0x03, 0xC0, 0x00, 0x00	; U+0044
000610 0000
000611 f00f
000612 1009
000613 1009
000614 1009
000615 1009
000616 1008
000617 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10, 0x00, 0x00	; U+0045
000618 0000
000619 f00f
00061a 0009
00061b 0009
00061c 0009
00061d 0009
00061e 0008
00061f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x08, 0x00, 0x00, 0x00	; U+0046
000620 0000
000621 c003
000622 2004
000623 1008
000624 1008
000625 9008
000626 f008
000627 0000                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x08, 0x10, 0x08, 0x10, 0x08, 0x90, 0x08, 0xF0, 0x00, 0x00	; U+0047
000628 0000
000629 f00f
00062a 0001
00062b 0001
00062c 0001
00062d 0001
00062e f00f
00062f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x0F, 0xF0, 0x00, 0x00	; U+0048
000630 0000
000631 0000
000632 1008
000633 1008
000634 f00f
000635 1008
000636 1008
000637 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x08, 0x10, 0x0F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+0049
000638 0000
000639 6000
00063a 1000
00063b 1000
00063c 1000
00063d 1000
00063e e00f
00063f 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+004A
000640 0000
000641 f00f
000642 8001
000643 8001
000644 4002
000645 2004
000646 1008
000647 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x01, 0x80, 0x01, 0x80, 0x02, 0x40, 0x04, 0x20, 0x08, 0x10, 0x00, 0x00	; U+004B
000648 0000
000649 f00f
00064a 1000
00064b 1000
00064c 1000
00064d 1000
00064e 1000
00064f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+004C
000650 0000
000651 f00f
000652 0004
000653 0002
000654 8001
000655 0002
000656 0004
000657 f00f                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x04, 0x00, 0x02, 0x00, 0x01, 0x80, 0x02, 0x00, 0x04, 0x00, 0x0F, 0xF0	; U+004D
000658 0000
000659 f00f
00065a 0004
00065b 0002
00065c 0001
00065d 8000
00065e f00f
00065f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x04, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x80, 0x0F, 0xF0, 0x00, 0x00	; U+004E
000660 0000
000661 e007
000662 1008
000663 1008
000664 1008
000665 1008
000666 e007
000667 0000                      .DB	0x00, 0x00, 0x07, 0xE0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x07, 0xE0, 0x00, 0x00	; U+004F
000668 0000
000669 f00f
00066a 8008
00066b 8008
00066c 8008
00066d 8008
00066e 0007
00066f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x07, 0x00, 0x00, 0x00	; U+0050
000670 0000
000671 e007
000672 1008
000673 1008
000674 1008
000675 1808
000676 e407
000677 0000                      .DB	0x00, 0x00, 0x07, 0xE0, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x08, 0x18, 0x07, 0xE4, 0x00, 0x00	; U+0051
000678 0000
000679 f00f
00067a 8008
00067b 8008
00067c c008
00067d a008
00067e 1007
00067f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x08, 0x80, 0x08, 0x80, 0x08, 0xC0, 0x08, 0xA0, 0x07, 0x10, 0x00, 0x00	; U+0052
000680 0000
000681 1006
000682 1009
000683 1009
000684 9008
000685 9008
000686 6008
000687 0000                      .DB	0x00, 0x00, 0x06, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0x90, 0x08, 0x90, 0x08, 0x60, 0x00, 0x00	; U+0053
000688 0000
000689 0008
00068a 0008
00068b 0008
00068c f00f
00068d 0008
00068e 0008
00068f 0008                      .DB	0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x0F, 0xF0, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00	; U+0054
000690 0000
000691 e00f
000692 1000
000693 1000
000694 1000
000695 1000
000696 e00f
000697 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+0055
000698 0000
000699 000f
00069a c000
00069b 3000
00069c 3000
00069d c000
00069e 000f
00069f 0000                      .DB	0x00, 0x00, 0x0F, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x30, 0x00, 0xC0, 0x0F, 0x00, 0x00, 0x00	; U+0056
0006a0 0000
0006a1 f00f
0006a2 1000
0006a3 2000
0006a4 c000
0006a5 2000
0006a6 1000
0006a7 f00f                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x00, 0x10, 0x00, 0x20, 0x00, 0xC0, 0x00, 0x20, 0x00, 0x10, 0x0F, 0xF0	; U+0057
0006a8 0000
0006a9 300c
0006aa 4002
0006ab 8001
0006ac 8001
0006ad 4002
0006ae 300c
0006af 0000                      .DB	0x00, 0x00, 0x0C, 0x30, 0x02, 0x40, 0x01, 0x80, 0x01, 0x80, 0x02, 0x40, 0x0C, 0x30, 0x00, 0x00	; U+0058
0006b0 0000
0006b1 000c
0006b2 0002
0006b3 0001
0006b4 f000
0006b5 0001
0006b6 0002
0006b7 000c                      .DB	0x00, 0x00, 0x0C, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x0C, 0x00	; U+0059
0006b8 0000
0006b9 3008
0006ba 5008
0006bb 9008
0006bc 1009
0006bd 100a
0006be 100c
0006bf 1008                      .DB	0x00, 0x00, 0x08, 0x30, 0x08, 0x50, 0x08, 0x90, 0x09, 0x10, 0x0A, 0x10, 0x0C, 0x10, 0x08, 0x10	; U+005A
0006c0 0000
0006c1 0000
0006c2 0000
0006c3 fc1f
0006c4 0410
0006c5 0410
0006c6 0410
0006c7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFC, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x00, 0x00	; U+005B
0006c8 0000
0006c9 000c
0006ca 0003
0006cb c000
0006cc 3000
0006cd 0c00
0006ce 0000
0006cf 0000                      .DB	0x00, 0x00, 0x0C, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00	; U+005C
0006d0 0000
0006d1 0410
0006d2 0410
0006d3 0410
0006d4 fc1f
0006d5 0000
0006d6 0000
0006d7 0000                      .DB	0x00, 0x00, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+005D
0006d8 0000
0006d9 0002
0006da 0004
0006db 0008
0006dc 0004
0006dd 0002
0006de 0000
0006df 0000                      .DB	0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00	; U+005E
0006e0 0400
0006e1 0400
0006e2 0400
0006e3 0400
0006e4 0400
0006e5 0400
0006e6 0400
0006e7 0400                      .DB	0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x04	; U+005F
0006e8 0000
0006e9 0000
0006ea 0000
0006eb 0010
0006ec 0008
0006ed 0004
0006ee 0000
0006ef 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x08, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00	; U+0060
0006f0 0000
0006f1 6000
0006f2 9002
0006f3 9002
0006f4 9002
0006f5 9002
0006f6 f001
0006f7 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+0061
0006f8 0000
0006f9 f01f
0006fa 1001
0006fb 1002
0006fc 1002
0006fd 1002
0006fe e001
0006ff 0000                      .DB	0x00, 0x00, 0x1F, 0xF0, 0x01, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+0062
000700 0000
000701 e001
000702 1002
000703 1002
000704 1002
000705 1002
000706 2001
000707 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0x20, 0x00, 0x00	; U+0063
000708 0000
000709 e001
00070a 1002
00070b 1002
00070c 1002
00070d 2002
00070e f01f
00070f 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x20, 0x1F, 0xF0, 0x00, 0x00	; U+0064
000710 0000
000711 e001
000712 9002
000713 9002
000714 9002
000715 9002
000716 9001
000717 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0x90, 0x00, 0x00	; U+0065
000718 0000
000719 0002
00071a 0002
00071b f00f
00071c 0012
00071d 0012
00071e 0012
00071f 0000                      .DB	0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0F, 0xF0, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x00, 0x00	; U+0066
000720 0000
000721 e001
000722 1202
000723 1202
000724 1202
000725 1202
000726 fc03
000727 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x03, 0xFC, 0x00, 0x00	; U+0067
000728 0000
000729 f01f
00072a 0001
00072b 0002
00072c 0002
00072d 0002
00072e f001
00072f 0000                      .DB	0x00, 0x00, 0x1F, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0, 0x00, 0x00	; U+0068
000730 0000
000731 0000
000732 1002
000733 1002
000734 f01b
000735 1000
000736 1000
000737 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x02, 0x10, 0x1B, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+0069
000738 0000
000739 0000
00073a 0200
00073b 0202
00073c 0202
00073d fc1b
00073e 0000
00073f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x1B, 0xFC, 0x00, 0x00, 0x00, 0x00	; U+006A
000740 0000
000741 f01f
000742 4000
000743 8000
000744 4001
000745 2002
000746 1000
000747 0000                      .DB	0x00, 0x00, 0x1F, 0xF0, 0x00, 0x40, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x00, 0x10, 0x00, 0x00	; U+006B
000748 0000
000749 0010
00074a 0010
00074b e01f
00074c 1000
00074d 1000
00074e 1000
00074f 0000                      .DB	0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x1F, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+006c
000750 0000
000751 f003
000752 0002
000753 0002
000754 f001
000755 0002
000756 0002
000757 f001                      .DB	0x00, 0x00, 0x03, 0xF0, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0	; U+006d
000758 0000
000759 f003
00075a 0001
00075b 0002
00075c 0002
00075d 0002
00075e f001
00075f 0000                      .DB	0x00, 0x00, 0x03, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0xF0, 0x00, 0x00	; U+006e
000760 0000
000761 e001
000762 1002
000763 1002
000764 1002
000765 1002
000766 e001
000767 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+006F
000768 0000
000769 fe03
00076a 1001
00076b 1002
00076c 1002
00076d 1002
00076e e001
00076f 0000                      .DB	0x00, 0x00, 0x03, 0xFE, 0x01, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+0070
000770 0000
000771 e001
000772 1002
000773 1002
000774 1002
000775 2002
000776 fe03
000777 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x20, 0x03, 0xFE, 0x00, 0x00	; U+0071
000778 0000
000779 f003
00077a 0001
00077b 0002
00077c 0002
00077d 0002
00077e 0001
00077f 0000                      .DB	0x00, 0x00, 0x03, 0xF0, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00	; U+0072
000780 0000
000781 1001
000782 9002
000783 9002
000784 5002
000785 5002
000786 2002
000787 0000                      .DB	0x00, 0x00, 0x01, 0x10, 0x02, 0x90, 0x02, 0x90, 0x02, 0x50, 0x02, 0x50, 0x02, 0x20, 0x00, 0x00	; U+0073
000788 0000
000789 0002
00078a 0002
00078b e00f
00078c 1002
00078d 1002
00078e 1002
00078f 0000                      .DB	0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0F, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x00, 0x00	; U+0074
000790 0000
000791 e003
000792 1000
000793 1000
000794 1000
000795 2000
000796 f003
000797 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x20, 0x03, 0xF0, 0x00, 0x00	; U+0075
000798 0000
000799 0003
00079a c000
00079b 3000
00079c 3000
00079d c000
00079e 0003
00079f 0000                      .DB	0x00, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x30, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00	; U+0076
0007a0 0000
0007a1 e003
0007a2 1000
0007a3 1000
0007a4 e001
0007a5 1000
0007a6 1000
0007a7 e003                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x01, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x03, 0xE0	; U+0077
0007a8 0000
0007a9 1002
0007aa 2001
0007ab c000
0007ac c000
0007ad 2001
0007ae 1002
0007af 0000                      .DB	0x00, 0x00, 0x02, 0x10, 0x01, 0x20, 0x00, 0xC0, 0x00, 0xC0, 0x01, 0x20, 0x02, 0x10, 0x00, 0x00	; U+0078
0007b0 0000
0007b1 e003
0007b2 1200
0007b3 1200
0007b4 1200
0007b5 2200
0007b6 fc03
0007b7 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x22, 0x03, 0xFC, 0x00, 0x00	; U+0079
0007b8 0000
0007b9 1002
0007ba 3002
0007bb 5002
0007bc 9002
0007bd 1003
0007be 1002
0007bf 0000                      .DB	0x00, 0x00, 0x02, 0x10, 0x02, 0x30, 0x02, 0x50, 0x02, 0x90, 0x03, 0x10, 0x02, 0x10, 0x00, 0x00	; U+007A
0007c0 0000
0007c1 0000
0007c2 8000
0007c3 8000
0007c4 780f
0007c5 0410
0007c6 0410
0007c7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x0F, 0x78, 0x10, 0x04, 0x10, 0x04, 0x00, 0x00	; U+007B
0007c8 0000
0007c9 0000
0007ca 0000
0007cb 0000
0007cc fc3f
0007cd 0000
0007ce 0000
0007cf 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+007C
0007d0 0000
0007d1 0410
0007d2 0410
0007d3 780f
0007d4 8000
0007d5 8000
0007d6 0000
0007d7 0000                      .DB	0x00, 0x00, 0x10, 0x04, 0x10, 0x04, 0x0F, 0x78, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00	; U+007D
0007d8 0000
0007d9 0006
0007da 0008
0007db 0008
0007dc 0004
0007dd 0002
0007de 0002
0007df 000c                      .DB	0x00, 0x00, 0x06, 0x00, 0x08, 0x00, 0x08, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0C, 0x00	; U+007E
0007e0 5455
0007e1 aaaa
0007e2 5455
0007e3 aaaa
0007e4 5455
0007e5 aaaa
0007e6 5455
0007e7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007e8 5455
0007e9 aaaa
0007ea 5455
0007eb aaaa
0007ec 5455
0007ed aaaa
0007ee 5455
0007ef aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007f0 5455
0007f1 aaaa
0007f2 5455
0007f3 aaaa
0007f4 5455
0007f5 aaaa
0007f6 5455
0007f7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0007f8 5455
0007f9 aaaa
0007fa 5455
0007fb aaaa
0007fc 5455
0007fd aaaa
0007fe 5455
0007ff aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000800 5455
000801 aaaa
000802 5455
000803 aaaa
000804 5455
000805 aaaa
000806 5455
000807 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000808 5455
000809 aaaa
00080a 5455
00080b aaaa
00080c 5455
00080d aaaa
00080e 5455
00080f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000810 5455
000811 aaaa
000812 5455
000813 aaaa
000814 5455
000815 aaaa
000816 5455
000817 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000818 5455
000819 aaaa
00081a 5455
00081b aaaa
00081c 5455
00081d aaaa
00081e 5455
00081f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000820 5455
000821 aaaa
000822 5455
000823 aaaa
000824 5455
000825 aaaa
000826 5455
000827 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000828 5455
000829 aaaa
00082a 5455
00082b aaaa
00082c 5455
00082d aaaa
00082e 5455
00082f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000830 5455
000831 aaaa
000832 5455
000833 aaaa
000834 5455
000835 aaaa
000836 5455
000837 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000838 5455
000839 aaaa
00083a 5455
00083b aaaa
00083c 5455
00083d aaaa
00083e 5455
00083f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000840 5455
000841 aaaa
000842 5455
000843 aaaa
000844 5455
000845 aaaa
000846 5455
000847 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000848 5455
000849 aaaa
00084a 5455
00084b aaaa
00084c 5455
00084d aaaa
00084e 5455
00084f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000850 5455
000851 aaaa
000852 5455
000853 aaaa
000854 5455
000855 aaaa
000856 5455
000857 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000858 5455
000859 aaaa
00085a 5455
00085b aaaa
00085c 5455
00085d aaaa
00085e 5455
00085f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000860 5455
000861 aaaa
000862 5455
000863 aaaa
000864 5455
000865 aaaa
000866 5455
000867 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000868 5455
000869 aaaa
00086a 5455
00086b aaaa
00086c 5455
00086d aaaa
00086e 5455
00086f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000870 5455
000871 aaaa
000872 5455
000873 aaaa
000874 5455
000875 aaaa
000876 5455
000877 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000878 5455
000879 aaaa
00087a 5455
00087b aaaa
00087c 5455
00087d aaaa
00087e 5455
00087f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000880 5455
000881 aaaa
000882 5455
000883 aaaa
000884 5455
000885 aaaa
000886 5455
000887 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000888 5455
000889 aaaa
00088a 5455
00088b aaaa
00088c 5455
00088d aaaa
00088e 5455
00088f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000890 5455
000891 aaaa
000892 5455
000893 aaaa
000894 5455
000895 aaaa
000896 5455
000897 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000898 5455
000899 aaaa
00089a 5455
00089b aaaa
00089c 5455
00089d aaaa
00089e 5455
00089f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008a0 5455
0008a1 aaaa
0008a2 5455
0008a3 aaaa
0008a4 5455
0008a5 aaaa
0008a6 5455
0008a7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008a8 5455
0008a9 aaaa
0008aa 5455
0008ab aaaa
0008ac 5455
0008ad aaaa
0008ae 5455
0008af aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008b0 5455
0008b1 aaaa
0008b2 5455
0008b3 aaaa
0008b4 5455
0008b5 aaaa
0008b6 5455
0008b7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008b8 5455
0008b9 aaaa
0008ba 5455
0008bb aaaa
0008bc 5455
0008bd aaaa
0008be 5455
0008bf aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008c0 5455
0008c1 aaaa
0008c2 5455
0008c3 aaaa
0008c4 5455
0008c5 aaaa
0008c6 5455
0008c7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008c8 5455
0008c9 aaaa
0008ca 5455
0008cb aaaa
0008cc 5455
0008cd aaaa
0008ce 5455
0008cf aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008d0 5455
0008d1 aaaa
0008d2 5455
0008d3 aaaa
0008d4 5455
0008d5 aaaa
0008d6 5455
0008d7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008d8 5455
0008d9 aaaa
0008da 5455
0008db aaaa
0008dc 5455
0008dd aaaa
0008de 5455
0008df aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008e0 5455
0008e1 aaaa
0008e2 5455
0008e3 aaaa
0008e4 5455
0008e5 aaaa
0008e6 5455
0008e7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0008e8 0000
0008e9 0000
0008ea 0000
0008eb 0000
0008ec 0000
0008ed 0000
0008ee 0000
0008ef 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A0
0008f0 0000
0008f1 0000
0008f2 0000
0008f3 3e03
0008f4 0000
0008f5 0000
0008f6 0000
0008f7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A1
0008f8 0000
0008f9 c003
0008fa 2004
0008fb 2004
0008fc f81f
0008fd 2004
0008fe 2004
0008ff 4002                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x04, 0x20, 0x1F, 0xF8, 0x04, 0x20, 0x04, 0x20, 0x02, 0x40	; U+00A2
000900 0000
000901 1001
000902 2001
000903 e007
000904 2009
000905 1009
000906 1008
000907 2004                      .DB	0x00, 0x00, 0x01, 0x10, 0x01, 0x20, 0x07, 0xE0, 0x09, 0x20, 0x09, 0x10, 0x08, 0x10, 0x04, 0x20	; U+00A3
000908 0000
000909 2004
00090a c003
00090b 4002
00090c 4002
00090d c003
00090e 2004
00090f 0000                      .DB	0x00, 0x00, 0x04, 0x20, 0x03, 0xC0, 0x02, 0x40, 0x02, 0x40, 0x03, 0xC0, 0x04, 0x20, 0x00, 0x00	; U+00A4
000910 0000
000911 0008
000912 4005
000913 4003
000914 f001
000915 4003
000916 4005
000917 0008                      .DB	0x00, 0x00, 0x08, 0x00, 0x05, 0x40, 0x03, 0x40, 0x01, 0xF0, 0x03, 0x40, 0x05, 0x40, 0x08, 0x00	; U+00A5
000918 0000
000919 0000
00091a 0000
00091b 0000
00091c 3c0f
00091d 0000
00091e 0000
00091f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A6
000920 5455
000921 aaaa
000922 5455
000923 aaaa
000924 5455
000925 aaaa
000926 5455
000927 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000928 0000
000929 0000
00092a 0060
00092b 0000
00092c 0000
00092d 0060
00092e 0000
00092f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00A8
000930 0000
000931 c003
000932 2004
000933 9009
000934 500a
000935 500a
000936 2004
000937 c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x09, 0x90, 0x0A, 0x50, 0x0A, 0x50, 0x04, 0x20, 0x03, 0xC0	; U+00A9
000938 5455
000939 aaaa
00093a 5455
00093b aaaa
00093c 5455
00093d aaaa
00093e 5455
00093f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000940 0000
000941 8000
000942 4001
000943 2002
000944 9004
000945 4001
000946 2002
000947 1004                      .DB	0x00, 0x00, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x04, 0x90, 0x01, 0x40, 0x02, 0x20, 0x04, 0x10	; U+00AB
000948 5455
000949 aaaa
00094a 5455
00094b aaaa
00094c 5455
00094d aaaa
00094e 5455
00094f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000950 0000
000951 8000
000952 8000
000953 8000
000954 8000
000955 8000
000956 8000
000957 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00	; U+00AD
000958 5455
000959 aaaa
00095a 5455
00095b aaaa
00095c 5455
00095d aaaa
00095e 5455
00095f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000960 5455
000961 aaaa
000962 5455
000963 aaaa
000964 5455
000965 aaaa
000966 5455
000967 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000968 0000
000969 0007
00096a 8008
00096b 8008
00096c 8008
00096d 0007
00096e 0000
00096f 0000                      .DB	0x00, 0x00, 0x07, 0x00, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00B0
000970 5455
000971 aaaa
000972 5455
000973 aaaa
000974 5455
000975 aaaa
000976 5455
000977 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000978 5455
000979 aaaa
00097a 5455
00097b aaaa
00097c 5455
00097d aaaa
00097e 5455
00097f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000980 5455
000981 aaaa
000982 5455
000983 aaaa
000984 5455
000985 aaaa
000986 5455
000987 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000988 5455
000989 aaaa
00098a 5455
00098b aaaa
00098c 5455
00098d aaaa
00098e 5455
00098f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000990 5455
000991 aaaa
000992 5455
000993 aaaa
000994 5455
000995 aaaa
000996 5455
000997 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
000998 5455
000999 aaaa
00099a 5455
00099b aaaa
00099c 5455
00099d aaaa
00099e 5455
00099f aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009a0 5455
0009a1 aaaa
0009a2 5455
0009a3 aaaa
0009a4 5455
0009a5 aaaa
0009a6 5455
0009a7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009a8 0000
0009a9 0000
0009aa 0200
0009ab 0200
0009ac 0c00
0009ad 0000
0009ae 0000
0009af 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00	; U+00B8
0009b0 5455
0009b1 aaaa
0009b2 5455
0009b3 aaaa
0009b4 5455
0009b5 aaaa
0009b6 5455
0009b7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009b8 5455
0009b9 aaaa
0009ba 5455
0009bb aaaa
0009bc 5455
0009bd aaaa
0009be 5455
0009bf aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009c0 0000
0009c1 1004
0009c2 2002
0009c3 4001
0009c4 9004
0009c5 2002
0009c6 4001
0009c7 8000                      .DB	0x00, 0x00, 0x04, 0x10, 0x02, 0x20, 0x01, 0x40, 0x04, 0x90, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80	; U+00BB
0009c8 5455
0009c9 aaaa
0009ca 5455
0009cb aaaa
0009cc 5455
0009cd aaaa
0009ce 5455
0009cf aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009d0 5455
0009d1 aaaa
0009d2 5455
0009d3 aaaa
0009d4 5455
0009d5 aaaa
0009d6 5455
0009d7 aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009d8 5455
0009d9 aaaa
0009da 5455
0009db aaaa
0009dc 5455
0009dd aaaa
0009de 5455
0009df aaaa                      .DB	0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA, 0x55, 0x54, 0xAA, 0xAA	; Unused character
0009e0 0000
0009e1 0000
0009e2 0c00
0009e3 1200
0009e4 2203
0009e5 0200
0009e6 0400
0009e7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x12, 0x03, 0x22, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00	; U+00BF
0009e8 0000
0009e9 7000
0009ea c043
0009eb 402c
0009ec 400c
0009ed c003
0009ee 7000
0009ef 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x43, 0xC0, 0x2C, 0x40, 0x0C, 0x40, 0x03, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C0
0009f0 0000
0009f1 7000
0009f2 c003
0009f3 400c
0009f4 402c
0009f5 c043
0009f6 7000
0009f7 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x03, 0xC0, 0x0C, 0x40, 0x2C, 0x40, 0x43, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C1
0009f8 0000
0009f9 7000
0009fa c023
0009fb 404c
0009fc 404c
0009fd c023
0009fe 7000
0009ff 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x23, 0xC0, 0x4C, 0x40, 0x4C, 0x40, 0x23, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C2
000a00 0000
000a01 7020
000a02 c043
000a03 404c
000a04 402c
000a05 c023
000a06 7040
000a07 0000                      .DB	0x00, 0x00, 0x20, 0x70, 0x43, 0xC0, 0x4C, 0x40, 0x2C, 0x40, 0x23, 0xC0, 0x40, 0x70, 0x00, 0x00	; U+00C3
000a08 0000
000a09 7000
000a0a c063
000a0b 400c
000a0c 400c
000a0d c063
000a0e 7000
000a0f 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x63, 0xC0, 0x0C, 0x40, 0x0C, 0x40, 0x63, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C4
000a10 0000
000a11 7000
000a12 c033
000a13 404c
000a14 404c
000a15 c033
000a16 7000
000a17 0000                      .DB	0x00, 0x00, 0x00, 0x70, 0x33, 0xC0, 0x4C, 0x40, 0x4C, 0x40, 0x33, 0xC0, 0x00, 0x70, 0x00, 0x00	; U+00C5
000a18 0000
000a19 7000
000a1a c003
000a1b 400c
000a1c f00f
000a1d 1009
000a1e 1009
000a1f 1008                      .DB	0x00, 0x00, 0x00, 0x70, 0x03, 0xC0, 0x0C, 0x40, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10	; U+00C6
000a20 0000
000a21 c003
000a22 2204
000a23 1208
000a24 1c08
000a25 1008
000a26 1008
000a27 0000                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x22, 0x08, 0x12, 0x08, 0x1C, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00C7
000a28 0000
000a29 f00f
000a2a 1049
000a2b 1029
000a2c 1009
000a2d 1009
000a2e 1008
000a2f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x49, 0x10, 0x29, 0x10, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00C8
000a30 0000
000a31 f00f
000a32 1009
000a33 1009
000a34 1029
000a35 1049
000a36 1008
000a37 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x29, 0x10, 0x49, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00C9
000a38 0000
000a39 f00f
000a3a 1029
000a3b 1049
000a3c 1049
000a3d 1029
000a3e 1008
000a3f 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x29, 0x10, 0x49, 0x10, 0x49, 0x10, 0x29, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CA
000a40 0000
000a41 f00f
000a42 1069
000a43 1009
000a44 1009
000a45 1069
000a46 1008
000a47 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x69, 0x10, 0x09, 0x10, 0x09, 0x10, 0x69, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CB
000a48 0000
000a49 0000
000a4a 1008
000a4b 1048
000a4c f02f
000a4d 1008
000a4e 1008
000a4f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x48, 0x10, 0x2F, 0xF0, 0x08, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CC
000a50 0000
000a51 0000
000a52 1008
000a53 1008
000a54 f02f
000a55 1048
000a56 1008
000a57 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x08, 0x10, 0x2F, 0xF0, 0x48, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CD
000a58 0000
000a59 0000
000a5a 1008
000a5b 1028
000a5c f04f
000a5d 1028
000a5e 1008
000a5f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x28, 0x10, 0x4F, 0xF0, 0x28, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CE
000a60 0000
000a61 0000
000a62 1008
000a63 1068
000a64 f00f
000a65 1068
000a66 1008
000a67 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x68, 0x10, 0x0F, 0xF0, 0x68, 0x10, 0x08, 0x10, 0x00, 0x00	; U+00CF
000a68 0000
000a69 0001
000a6a f00f
000a6b 1009
000a6c 1009
000a6d 1008
000a6e 2004
000a6f c003                      .DB	0x00, 0x00, 0x01, 0x00, 0x0F, 0xF0, 0x09, 0x10, 0x09, 0x10, 0x08, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D0
000a70 0000
000a71 f02f
000a72 0044
000a73 0042
000a74 0021
000a75 8020
000a76 f04f
000a77 0000                      .DB	0x00, 0x00, 0x2F, 0xF0, 0x44, 0x00, 0x42, 0x00, 0x21, 0x00, 0x20, 0x80, 0x4F, 0xF0, 0x00, 0x00	; U+00D1
000a78 0000
000a79 c003
000a7a 2004
000a7b 1048
000a7c 1028
000a7d 1008
000a7e 2004
000a7f c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x48, 0x10, 0x28, 0x10, 0x08, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D2
000a80 0000
000a81 c003
000a82 2004
000a83 1008
000a84 1028
000a85 1048
000a86 2004
000a87 c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x08, 0x10, 0x28, 0x10, 0x48, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D3
000a88 0000
000a89 c003
000a8a 2004
000a8b 1028
000a8c 1048
000a8d 1028
000a8e 2004
000a8f c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x04, 0x20, 0x28, 0x10, 0x48, 0x10, 0x28, 0x10, 0x04, 0x20, 0x03, 0xC0	; U+00D4
000a90 0000
000a91 c003
000a92 2024
000a93 1048
000a94 1048
000a95 1028
000a96 2024
000a97 c043                      .DB	0x00, 0x00, 0x03, 0xC0, 0x24, 0x20, 0x48, 0x10, 0x48, 0x10, 0x28, 0x10, 0x24, 0x20, 0x43, 0xC0	; U+00D5
000a98 0000
000a99 c003
000a9a 2064
000a9b 1008
000a9c 1008
000a9d 1008
000a9e 2064
000a9f c003                      .DB	0x00, 0x00, 0x03, 0xC0, 0x64, 0x20, 0x08, 0x10, 0x08, 0x10, 0x08, 0x10, 0x64, 0x20, 0x03, 0xC0	; U+00D6
000aa0 0000
000aa1 0000
000aa2 2002
000aa3 4001
000aa4 8000
000aa5 4001
000aa6 2002
000aa7 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x20, 0x01, 0x40, 0x00, 0x80, 0x01, 0x40, 0x02, 0x20, 0x00, 0x00	; U+00D7
000aa8 0000
000aa9 c803
000aaa 3004
000aab 5008
000aac 9009
000aad 100a
000aae 200c
000aaf c013                      .DB	0x00, 0x00, 0x03, 0xC8, 0x04, 0x30, 0x08, 0x50, 0x09, 0x90, 0x0A, 0x10, 0x0C, 0x20, 0x13, 0xC0	; U+00D8
000ab0 0000
000ab1 e00f
000ab2 1040
000ab3 1020
000ab4 1000
000ab5 1000
000ab6 e00f
000ab7 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x40, 0x10, 0x20, 0x10, 0x00, 0x10, 0x00, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00D9
000ab8 0000
000ab9 e00f
000aba 1000
000abb 1000
000abc 1020
000abd 1040
000abe e00f
000abf 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x20, 0x10, 0x40, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00DA
000ac0 0000
000ac1 e00f
000ac2 1020
000ac3 1040
000ac4 1040
000ac5 1020
000ac6 e00f
000ac7 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x20, 0x10, 0x40, 0x10, 0x40, 0x10, 0x20, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00DB
000ac8 0000
000ac9 e00f
000aca 1060
000acb 1000
000acc 1000
000acd 1060
000ace e00f
000acf 0000                      .DB	0x00, 0x00, 0x0F, 0xE0, 0x60, 0x10, 0x00, 0x10, 0x00, 0x10, 0x60, 0x10, 0x0F, 0xE0, 0x00, 0x00	; U+00DC
000ad0 0000
000ad1 000c
000ad2 0062
000ad3 0001
000ad4 f000
000ad5 0001
000ad6 0062
000ad7 000c                      .DB	0x00, 0x00, 0x0C, 0x00, 0x62, 0x00, 0x01, 0x00, 0x00, 0xF0, 0x01, 0x00, 0x62, 0x00, 0x0C, 0x00	; U+00DD
000ad8 0000
000ad9 f00f
000ada 2004
000adb 2004
000adc 2004
000add 2004
000ade c003
000adf 0000                      .DB	0x00, 0x00, 0x0F, 0xF0, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x04, 0x20, 0x03, 0xC0, 0x00, 0x00	; U+00DE
000ae0 0000
000ae1 f007
000ae2 0008
000ae3 0008
000ae4 1009
000ae5 100b
000ae6 e004
000ae7 0000                      .DB	0x00, 0x00, 0x07, 0xF0, 0x08, 0x00, 0x08, 0x00, 0x09, 0x10, 0x0B, 0x10, 0x04, 0xE0, 0x00, 0x00	; U+00DF
000ae8 0000
000ae9 6000
000aea 9012
000aeb 900a
000aec 9002
000aed 9002
000aee f001
000aef 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x12, 0x90, 0x0A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E0
000af0 0000
000af1 6000
000af2 9002
000af3 9002
000af4 900a
000af5 9012
000af6 f001
000af7 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x02, 0x90, 0x02, 0x90, 0x0A, 0x90, 0x12, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E1
000af8 0000
000af9 6000
000afa 900a
000afb 9012
000afc 9012
000afd 900a
000afe f001
000aff 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x0A, 0x90, 0x12, 0x90, 0x12, 0x90, 0x0A, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E2
000b00 0000
000b01 6008
000b02 9012
000b03 9012
000b04 900a
000b05 900a
000b06 f011
000b07 0000                      .DB	0x00, 0x00, 0x08, 0x60, 0x12, 0x90, 0x12, 0x90, 0x0A, 0x90, 0x0A, 0x90, 0x11, 0xF0, 0x00, 0x00	; U+00E3
000b08 0000
000b09 6000
000b0a 901a
000b0b 9002
000b0c 9002
000b0d 901a
000b0e f001
000b0f 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x1A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x1A, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E4
000b10 0000
000b11 6000
000b12 9032
000b13 904a
000b14 904a
000b15 9032
000b16 f001
000b17 0000                      .DB	0x00, 0x00, 0x00, 0x60, 0x32, 0x90, 0x4A, 0x90, 0x4A, 0x90, 0x32, 0x90, 0x01, 0xF0, 0x00, 0x00	; U+00E5
000b18 0000
000b19 6000
000b1a 9002
000b1b 9002
000b1c e001
000b1d 9002
000b1e 9002
000b1f 9001                      .DB	0x00, 0x00, 0x00, 0x60, 0x02, 0x90, 0x02, 0x90, 0x01, 0xE0, 0x02, 0x90, 0x02, 0x90, 0x01, 0x90	; U+00E6
000b20 0000
000b21 e001
000b22 1202
000b23 1202
000b24 1c02
000b25 1002
000b26 2001
000b27 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x12, 0x02, 0x12, 0x02, 0x1C, 0x02, 0x10, 0x01, 0x20, 0x00, 0x00	; U+00E7
000b28 0000
000b29 e001
000b2a 9012
000b2b 900a
000b2c 9002
000b2d 9002
000b2e 9001
000b2f 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x12, 0x90, 0x0A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00E8
000b30 0000
000b31 e001
000b32 9002
000b33 9002
000b34 900a
000b35 9012
000b36 9001
000b37 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x90, 0x02, 0x90, 0x0A, 0x90, 0x12, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00E9
000b38 0000
000b39 e001
000b3a 900a
000b3b 9012
000b3c 9012
000b3d 900a
000b3e 9001
000b3f 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x0A, 0x90, 0x12, 0x90, 0x12, 0x90, 0x0A, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00EA
000b40 0000
000b41 e001
000b42 901a
000b43 9002
000b44 9002
000b45 901a
000b46 9001
000b47 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x1A, 0x90, 0x02, 0x90, 0x02, 0x90, 0x1A, 0x90, 0x01, 0x90, 0x00, 0x00	; U+00EB
000b48 0000
000b49 0000
000b4a 1012
000b4b 100a
000b4c f003
000b4d 1000
000b4e 1000
000b4f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x12, 0x10, 0x0A, 0x10, 0x03, 0xF0, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00EC
000b50 0000
000b51 0000
000b52 1002
000b53 1002
000b54 f00b
000b55 1010
000b56 1000
000b57 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x02, 0x10, 0x0B, 0xF0, 0x10, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00ED
000b58 0000
000b59 0000
000b5a 100a
000b5b 1012
000b5c f013
000b5d 1008
000b5e 1000
000b5f 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x0A, 0x10, 0x12, 0x10, 0x13, 0xF0, 0x08, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00EE
000b60 0000
000b61 0000
000b62 101a
000b63 1002
000b64 f003
000b65 1018
000b66 1000
000b67 0000                      .DB	0x00, 0x00, 0x00, 0x00, 0x1A, 0x10, 0x02, 0x10, 0x03, 0xF0, 0x18, 0x10, 0x00, 0x10, 0x00, 0x00	; U+00EF
000b68 0000
000b69 e001
000b6a 100a
000b6b 102a
000b6c 101a
000b6d 1016
000b6e e021
000b6f 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x0A, 0x10, 0x2A, 0x10, 0x1A, 0x10, 0x16, 0x10, 0x21, 0xE0, 0x00, 0x00	; U+00F0
000b70 0000
000b71 f00b
000b72 0012
000b73 0012
000b74 000a
000b75 000a
000b76 f011
000b77 0000                      .DB	0x00, 0x00, 0x0B, 0xF0, 0x12, 0x00, 0x12, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x11, 0xF0, 0x00, 0x00	; U+00F1
000b78 0000
000b79 e001
000b7a 1012
000b7b 100a
000b7c 1002
000b7d 1002
000b7e e001
000b7f 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x12, 0x10, 0x0A, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F2
000b80 0000
000b81 e001
000b82 1002
000b83 1002
000b84 100a
000b85 1012
000b86 e001
000b87 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x02, 0x10, 0x02, 0x10, 0x0A, 0x10, 0x12, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F3
000b88 0000
000b89 e001
000b8a 100a
000b8b 1012
000b8c 1012
000b8d 100a
000b8e e001
000b8f 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x0A, 0x10, 0x12, 0x10, 0x12, 0x10, 0x0A, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F4
000b90 0000
000b91 e009
000b92 1012
000b93 1012
000b94 100a
000b95 100a
000b96 e011
000b97 0000                      .DB	0x00, 0x00, 0x09, 0xE0, 0x12, 0x10, 0x12, 0x10, 0x0A, 0x10, 0x0A, 0x10, 0x11, 0xE0, 0x00, 0x00	; U+00F5
000b98 0000
000b99 e001
000b9a 101a
000b9b 1002
000b9c 1002
000b9d 101a
000b9e e001
000b9f 0000                      .DB	0x00, 0x00, 0x01, 0xE0, 0x1A, 0x10, 0x02, 0x10, 0x02, 0x10, 0x1A, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00F6
000ba0 0000
000ba1 8000
000ba2 8000
000ba3 b006
000ba4 b006
000ba5 8000
000ba6 8000
000ba7 0000                      .DB	0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x06, 0xB0, 0x06, 0xB0, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00	; U+00F7
000ba8 0000
000ba9 e801
000baa 3002
000bab 5002
000bac 9002
000bad 1003
000bae e005
000baf 0000                      .DB	0x00, 0x00, 0x01, 0xE8, 0x02, 0x30, 0x02, 0x50, 0x02, 0x90, 0x03, 0x10, 0x05, 0xE0, 0x00, 0x00	; U+00F8
000bb0 0000
000bb1 e003
000bb2 1010
000bb3 1008
000bb4 1000
000bb5 1000
000bb6 f003
000bb7 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x10, 0x10, 0x08, 0x10, 0x00, 0x10, 0x00, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00F9
000bb8 0000
000bb9 e003
000bba 1000
000bbb 1000
000bbc 1008
000bbd 1010
000bbe f003
000bbf 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x10, 0x00, 0x10, 0x08, 0x10, 0x10, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00FA
000bc0 0000
000bc1 e003
000bc2 1008
000bc3 1010
000bc4 1010
000bc5 1008
000bc6 f003
000bc7 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x08, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00FB
000bc8 0000
000bc9 e003
000bca 1018
000bcb 1000
000bcc 1000
000bcd 1018
000bce f003
000bcf 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x18, 0x10, 0x00, 0x10, 0x00, 0x10, 0x18, 0x10, 0x03, 0xF0, 0x00, 0x00	; U+00FC
000bd0 0000
000bd1 e003
000bd2 1200
000bd3 1200
000bd4 1208
000bd5 1210
000bd6 fc03
000bd7 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x00, 0x12, 0x00, 0x12, 0x08, 0x12, 0x10, 0x12, 0x03, 0xFC, 0x00, 0x00	; U+00FD
000bd8 0000
000bd9 fe1f
000bda 1002
000bdb 1002
000bdc 1002
000bdd 1002
000bde e001
000bdf 0000                      .DB	0x00, 0x00, 0x1F, 0xFE, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x02, 0x10, 0x01, 0xE0, 0x00, 0x00	; U+00FE
000be0 0000
000be1 e003
000be2 1218
000be3 1200
000be4 1200
000be5 1218
000be6 fc03
000be7 0000                      .DB	0x00, 0x00, 0x03, 0xE0, 0x18, 0x12, 0x00, 0x12, 0x00, 0x12, 0x18, 0x12, 0x03, 0xFC, 0x00, 0x00	; U+00FF
                                 
                                 
                                 
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega32U4" register use summary:
x  :  10 y  :   0 z  :   8 r0 :  12 r1 :   9 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16: 206 r17:  48 r18:  29 r19:  28 r20:   3 
r21:  28 r22:  13 r23:  10 r24:   5 r25:   5 r26:  36 r27:  33 r28:  40 
r29:  36 r30:  47 r31:  43 
Registers used: 20 out of 35 (57.1%)

"ATmega32U4" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   1 add   :   9 adiw  :   5 and   :   0 
andi  :   0 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  28 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   3 brlt  :   0 brmi  :   0 
brne  :  13 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   1 cbi   :  14 cbr   :   0 
clc   :   0 clh   :   0 cli   :   1 cln   :   0 clr   :   1 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   4 cpc   :   0 
cpi   :  30 cpse  :   0 dec   :  11 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   0 in    :   9 inc   :   3 jmp   :   0 
ld    :   1 ldd   :   0 ldi   : 179 lds   :   2 lpm   :  14 lsl   :   3 
lsr   :  15 mov   :  26 movw  :   1 mul   :   1 muls  :   0 mulsu :   0 
neg   :   0 nop   :   3 or    :   2 ori   :   2 out   :  22 pop   : 103 
push  : 101 rcall : 101 ret   :  43 reti  :   4 rjmp  :  36 rol   :   0 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :  15 sbic  :   7 sbis  :   2 
sbiw  :   5 sbr   :   0 sbrc  :   2 sbrs  :   6 sec   :   0 seh   :   0 
sei   :   3 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   0 st    :   9 std   :   0 sts   :  12 
sub   :   2 subi  :   1 swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 45 out of 113 (39.8%)

"ATmega32U4" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0017d0   1730   4212   5942   32768  18.1%
[.dseg] 0x000100 0x000100      0      0      0    2560   0.0%
[.eseg] 0x000000 0x000000      0      0      0    1024   0.0%

Assembly complete, 0 errors, 0 warnings
